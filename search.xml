<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Go-cli</title>
    <url>/undefined/5d128426/</url>
    <content><![CDATA[<p>本文主要介绍Go标准库之cmd命令使用详解，包括go命令的基本使用、go命令的子命令、go命令的参数、go命令的返回值、go命令的错误处理、go命令的环境变量、go命令的模块管理、go命令的编译运行、go命令的单元测试、go命令的代码检查等内容。</p>
<span id="more"></span>
<h1 id="go标准库之cmd命令使用详解"><a class="markdownIt-Anchor" href="#go标准库之cmd命令使用详解"></a> Go标准库之cmd命令使用详解</h1>
<h2 id="go命令"><a class="markdownIt-Anchor" href="#go命令"></a> go命令</h2>
<p>语法：go <command> [arguments]</p>
<p>go命令支持的命令有如下这些：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bug         start a bug report</span><br><span class="line">build       compile packages and dependencies</span><br><span class="line">clean       remove object files and cached files</span><br><span class="line">doc         show documentation <span class="keyword">for</span> <span class="keyword">package</span> or symbol</span><br><span class="line">env         <span class="built_in">print</span> Go environment information</span><br><span class="line">fix         update packages to use <span class="built_in">new</span> APIs</span><br><span class="line">fmt         gofmt (reformat) <span class="keyword">package</span> sources</span><br><span class="line">generate    generate Go files by processing source</span><br><span class="line">get         add dependencies to current module and install them</span><br><span class="line">install     compile and install packages and dependencies</span><br><span class="line">list        list packages or modules</span><br><span class="line">mod         module maintenance</span><br><span class="line">run         compile and run Go program</span><br><span class="line">test        test packages</span><br><span class="line">tool        run specified <span class="keyword">go</span> tool</span><br><span class="line">version     <span class="built_in">print</span> Go version</span><br><span class="line">vet         report likely mistakes in packages</span><br></pre></td></tr></table></figure>
<p>如果不知道这些命令怎么用，可以使用go help <cmd>查看官方说明。</p>
<h3 id="简单的"><a class="markdownIt-Anchor" href="#简单的"></a> 简单的</h3>
<h4 id="go-bug给go语言官方提bug"><a class="markdownIt-Anchor" href="#go-bug给go语言官方提bug"></a> go bug(给go语言官方提bug)</h4>
<p>命令语法：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go bug</span><br></pre></td></tr></table></figure>
<p>在终端(terminal)执行这个命令，会自动跳转到GitHub上的go语言官方repo，自动开1个issue</p>
<h4 id="go-env处理go环境变量"><a class="markdownIt-Anchor" href="#go-env处理go环境变量"></a> go env(处理go环境变量)</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> [-json] [-u] [-w] [var ...]</span><br></pre></td></tr></table></figure>
<p>-json：表示把结果以json格式展示，只在查看环境变量的时候使用，不能和-u, -w放在一起使用</p>
<p>-u: u表示unset，恢复环境变量的默认设置，后面必须有环境变量的名称，表示具体恢复哪个环境变量的值</p>
<p>-w: w表示write，设置环境变量的值，后面必须跟name=value的形式，表示把环境变量name的值设置为value</p>
<p>主要4个场景的用法</p>
<ul>
<li>
<p>查看全部环境变量的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line">go <span class="built_in">env</span></span><br><span class="line"><span class="comment"># 方法2：以json形式展示结果</span></span><br><span class="line">go <span class="built_in">env</span> -json</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看具体某个(1个或者多个)环境变量的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line">go <span class="built_in">env</span> GO111MODULE GOPATH</span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line">go <span class="built_in">env</span> | grep GO111MODULE</span><br><span class="line"><span class="comment"># 方法3</span></span><br><span class="line">go <span class="built_in">env</span> | findstr GO111MODULE</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置某个(1个或者多个)环境变量的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GO111MODULE=on</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>恢复某个(1个或者多个)环境变量的值为默认值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> -u GO111MODULE</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="go-version查看可执行文件的go版本"><a class="markdownIt-Anchor" href="#go-version查看可执行文件的go版本"></a> go version(查看可执行文件的go版本)</h4>
<p>命令语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> version [-m] [-v] [file ...]</span><br></pre></td></tr></table></figure>
<p>go version既可以用来查看当前系统安装的go的版本号，也可以查看可执行文件是使用哪个版本的go编译出来的，命令里最后一个参数既可以是可执行文件，也可以是目录。</p>
<p>-m: m代指module，后面必须带上可执行文件或者目录作为参数，用于展示可执行文件依赖的模块的版本信息</p>
<p>-v: v代指verbose，表示打印更为详细的信息，最后一个参数是目录的时候才真正起作用</p>
<ul>
<li>
<p>查看当前系统安装的go的版本号</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看可执行文件是使用哪个版本的go编译生成的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go version binfile</span><br></pre></td></tr></table></figure>
<p>比如我们使用go build main.go 编译生成了一个可执行文件main，那就可以使用如下命令来查看main这个可执行文件是使用哪个版本的go编译出来的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go version main</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看目录下的所有可执行文件是使用哪个版本的go编译生成的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go version <span class="built_in">dir</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看可执行文件使用的go版本以及可执行文件依赖的模块信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go version -m binfile</span><br><span class="line">go version -m <span class="built_in">dir</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="代码检查"><a class="markdownIt-Anchor" href="#代码检查"></a> 代码检查</h3>
<h4 id="go-fmt"><a class="markdownIt-Anchor" href="#go-fmt"></a> go fmt</h4>
<h4 id="go-vet"><a class="markdownIt-Anchor" href="#go-vet"></a> go vet</h4>
<p>命令语法：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go vet [-n] [-x] [-vettool prog] [build flags] [vet flags] [packages]</span><br></pre></td></tr></table></figure>
<p>vet的中文含义是”审查“，因此这个命令就是对Go代码做检查，报告潜在可能的错误</p>
<h4 id="go-fix"><a class="markdownIt-Anchor" href="#go-fix"></a> go fix</h4>
<h3 id="编译运行"><a class="markdownIt-Anchor" href="#编译运行"></a> 编译运行</h3>
<h4 id="go-build"><a class="markdownIt-Anchor" href="#go-build"></a> go build</h4>
<h4 id="go-clean"><a class="markdownIt-Anchor" href="#go-clean"></a> go clean</h4>
<h4 id="go-run"><a class="markdownIt-Anchor" href="#go-run"></a> go run</h4>
<h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3>
<h4 id="go-test"><a class="markdownIt-Anchor" href="#go-test"></a> go test</h4>
<h3 id="模块管理"><a class="markdownIt-Anchor" href="#模块管理"></a> 模块管理</h3>
<h4 id="go-mod"><a class="markdownIt-Anchor" href="#go-mod"></a> go mod</h4>
<h4 id="go-install"><a class="markdownIt-Anchor" href="#go-install"></a> go install</h4>
<h4 id="go-get"><a class="markdownIt-Anchor" href="#go-get"></a> go get</h4>
<p>更新go.sum?写个example</p>
<h4 id="go-list"><a class="markdownIt-Anchor" href="#go-list"></a> go list</h4>
<h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2>
<ul>
<li><a href="https://pkg.go.dev/cmd/go">https://pkg.go.dev/cmd/go</a></li>
<li><a href="https://github.com/hyper0x/go_command_tutorial">https://github.com/hyper0x/go_command_tutorial</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>17.Go-defer语义</title>
    <url>/undefined/362a394c/</url>
    <content><![CDATA[<p>本文主要介绍Go中defer语义的含义和用途，以及注意事项。</p>
<span id="more"></span>
<h1 id="defer语义"><a class="markdownIt-Anchor" href="#defer语义"></a> defer语义</h1>
<h2 id="defer含义"><a class="markdownIt-Anchor" href="#defer含义"></a> defer含义</h2>
<ul>
<li>
<p>defer是延迟的意思，在Go里可以放在某个函数或者方法调用的前面，让该函数或方法延迟执行</p>
</li>
<li>
<p>语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> function([parameter_list]) <span class="comment">// 延迟执行函数</span></span><br><span class="line"><span class="keyword">defer</span> method([parameter_list]) <span class="comment">// 延迟执行方法</span></span><br></pre></td></tr></table></figure>
<p>defer本身是在某个函数体内执行，比如在函数A内调用了defer func_name()，只要defer func_name()这行代码被执行到了，那func_name这个函数就会<strong>被延迟到函数A return或者panic之前执行</strong>。</p>
<p><strong>注意</strong>：如果是函数是因为调用了<code>os.Exit()</code>而退出，那<code>defer</code>就不会被执行了。参见<a href="https://github.com/jincheng9/go-tutorial/tree/main/workspace/senior/p2">Go语言里被defer的函数一定会执行么？</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> func_name([parameter_list])</span><br><span class="line"><span class="keyword">defer</span> package_name.func_name([parameter_list]) <span class="comment">// 例如defer fmt.Println(&quot;blabla&quot;)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果在函数内调用了<strong>多次defer</strong>，那在函数return之前，defer的函数调用满足LIFO原则，先defer的函数后执行，后defer的函数先执行。比如在函数A内先后执行了defer f1(), defer f2(), defer f3()，那函数A return之前，会按照f3(), f2(), f1()的顺序执行，再return。</p>
</li>
</ul>
<h2 id="defer的用途"><a class="markdownIt-Anchor" href="#defer的用途"></a> defer的用途？</h2>
<p>Answer：defer常用于成对的操作，比如文件打开后要关闭、锁的申请和释放、sync.WaitGroup跟踪的goroutine的计数器的释放等。为了确保资源被释放，可以结合defer一起使用，避免在代码的各种条件分支里去释放资源，容易遗漏和出错。</p>
<ul>
<li>
<p>示例1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumN</span><span class="params">(N <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 调用defer wg.Done()确保sumN执行完之后，可以对wg的计数器减1</span></span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=N; i++ &#123;</span><br><span class="line">		sum += i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;sum from 1 to %d is %d\n&quot;</span>, N, sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设置wg跟踪的计数器数量为1</span></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 开启sumN这个goroutine去计算1到100的和</span></span><br><span class="line">	<span class="keyword">go</span> sumN(<span class="number">100</span>)</span><br><span class="line">	<span class="comment">// Wait会一直等待，直到wg的计数器为0</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	</span><br><span class="line">	fmt.Println(<span class="string">&quot;finish&quot;</span>)		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>defer结合goroutine和闭包一起使用，可以让任务函数内部不用关心Go并发里的同步原语，更多内容可以参考<a href="./workspace/lesson19">goroutine</a>和<a href="./workspace/lesson21">sync.WaitGroup</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    size := <span class="number">10</span></span><br><span class="line">    wg.Add(size)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        i := i </span><br><span class="line">        <span class="comment">/*把worker的调用和defer放在一个闭包里</span></span><br><span class="line"><span class="comment">        这样worker函数内部就不用使用WaitGroup了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            worker(i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2>
<ol>
<li>
<p>defer后面跟的必须是函数或者方法调用，defer后面的表达式不能加括号。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> (fmt.Println(<span class="number">1</span>)) <span class="comment">// 编译报错，因为defer后面跟的表达式不能加括号</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>被defer的函数的参数在执行到defer语句的时候就被确定下来了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(i) <span class="comment">// 最终打印0</span></span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，被defer的函数fmt.Println的参数<strong>i</strong>在执行到defer这一行的时候，<strong>i</strong>的值是0，fmt.Println的参数就被确定下来是0了，因此最终打印的结果是0，而不是1。</p>
</li>
<li>
<p>被defer的函数执行顺序满足LIFO原则，后defer的先执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Print(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，输出的结果是3210，后defer的先执行。</p>
</li>
<li>
<p>被defer的函数可以对defer语句所在的函数的命名返回值做读取和修改操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f returns 42</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// result is accessed after it was set to 6 by the return statement</span></span><br><span class="line">		result *= <span class="number">7</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，被defer的函数func对defer语句所在的函数<strong>f</strong>的命名返回值result做了修改操作。</p>
<p>调用函数<strong>f</strong>，返回的结果是42。</p>
<p>执行顺序是函数<strong>f</strong>先把要返回的值6赋值给result，然后执行被defer的函数func，result被修改为42，然后函数<strong>f</strong>返回result，也就是返回了42。</p>
<p>官方说明如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Each time a <span class="string">&quot;defer&quot;</span> statement executes, the function value and parameters to</span><br><span class="line">the call are evaluated as usual and saved anew but the actual function is not </span><br><span class="line">invoked. Instead, deferred functions are invoked immediately before the </span><br><span class="line">surrounding function returns, in the reverse order they were deferred. That</span><br><span class="line">is, <span class="keyword">if</span> the surrounding function returns through an explicit <span class="keyword">return</span> statement, </span><br><span class="line">deferred functions are executed after any result parameters are set by that </span><br><span class="line"><span class="keyword">return</span> statement but before the function returns to its caller. If a deferred</span><br><span class="line">function value evaluates to <span class="literal">nil</span>, execution panics when the function is </span><br><span class="line">invoked, not when the <span class="string">&quot;defer&quot;</span> statement is executed.</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2>
<ul>
<li>
<p><a href="https://go.dev/blog/defer-panic-and-recover">https://go.dev/blog/defer-panic-and-recover</a></p>
</li>
<li>
<p><a href="https://golang.google.cn/ref/spec#Defer_statements">https://golang.google.cn/ref/spec#Defer_statements</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/52718143/is-golang-defer-statement-execute-before-or-after-return-statement">https://stackoverflow.com/questions/52718143/is-golang-defer-statement-execute-before-or-after-return-statement</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>16.Go-接口interface</title>
    <url>/undefined/f28eaa9a/</url>
    <content><![CDATA[<p>本文主要介绍Go中接口interface的基础语法，包括接口的定义、实现、多个struct类型实现同一个interface、一个struct类型实现多个interface、空接口interface、断言、动态判断数据类型等内容。</p>
<span id="more"></span>
<h1 id="接口interface"><a class="markdownIt-Anchor" href="#接口interface"></a> 接口interface</h1>
<ul>
<li>
<p>定义：接口是一种抽象的类型，是一组method的集合，里头只有method方法，没有数据成员。当两个或两个以上的类型都有相同的处理方法时才需要用到接口。先定义接口，然后多个struct类型去实现接口里的方法，就可以通过接口变量去调用struct类型里实现的方法。</p>
<p>比如动物都会叫唤，那可以先定义一个名为动物的接口，接口里有叫唤方法speak，然后猫和狗这2个struct类型去实现各自的speak方法。</p>
</li>
<li>
<p>语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">  method_name1([参数列表]) [返回值列表]</span><br><span class="line">  method_name2([参数列表]) [返回值列表]</span><br><span class="line">  method_nameN([参数列表]) [返回值列表]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体类型</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">    data_member1 data_type</span><br><span class="line">    data_member2 data_type</span><br><span class="line">    data_memberN data_type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口interface_name里的方法method_name1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(struct_var struct_name)</span></span> method_name1([参数列表])[返回值列表] &#123;</span><br><span class="line">    <span class="comment">/*具体方法实现*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口interface_name里的方法method_name2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(struct_var struct_name)</span></span> method_name2([参数列表])[返回值列表] &#123;</span><br><span class="line">    <span class="comment">/*具体方法实现*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口interface_name里的方法method_name3</span></span><br><span class="line"><span class="comment">注意：下面用了指针接受者。函数可以使用值接受者或者指针接受者，上面的method_name1和method_name1使用的是值接受者。</span></span><br><span class="line"><span class="comment">如果用了指针接受者，那给interface变量赋值的时候要传指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(struct_var *struct_name)</span></span> method_name3([参数列表])[返回值列表] &#123;</span><br><span class="line">    <span class="comment">/*具体方法实现*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// all animals can speak</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cat Cat)</span></span> speak() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;cat miaomiaomiao&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dog</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(dog *Dog)</span></span> speak() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;dog wangwangwang&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> animal Animal = Cat&#123;<span class="string">&quot;gaffe&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">    animal.speak() <span class="comment">// cat miaomiaomiao</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    因为Dog的speak方法用的是指针接受者，因此给interface赋值的时候，要赋指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    animal = &amp;Dog&#123;<span class="string">&quot;caiquan&quot;</span>, <span class="number">2</span>&#125;</span><br><span class="line">    animal.speak() <span class="comment">// dog wangwangwang</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>struct结构体类型在实现interface里的所有方法时，关于interface变量赋值有2个点要<strong>注意</strong></p>
<ul>
<li>
<p>只要有某个方法的实现使用了<strong>指针接受者</strong>，那给包含了这个方法的interface变量赋值的时候要<strong>使用指针</strong>。比如上面的Dog类型要赋值给Animal，必须使用指针，因为Dog实现speak方法用了指针接受者。</p>
</li>
<li>
<p>如果全部方法都使用的是值接受者，那给interface变量赋值的时候用值或者指针都可以。比如上面的例子，animal的初始化用下面的方式一样可以：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> animal Animal = &amp;Cat&#123;<span class="string">&quot;gaffe&quot;</span>, <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>多个struct类型可以实现同一个interface</strong>：多个类型都有共同的方法(行为)。比如上面示例里的猫和狗都会叫唤，猫和狗就是2个类型，叫唤就是speak方法。</p>
</li>
<li>
<p><strong>一个struct类型可以实现多个interface</strong>。比如猫这个类型，既是猫科动物，也是哺乳动物。猫科动物可以是一个interface，哺乳动物可以是另一个interface，猫这个struct类型可以实现猫科动物和哺乳动物这2个interface里的方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// interface1，猫科动物的共同行为</span></span><br><span class="line"><span class="keyword">type</span> Felines <span class="keyword">interface</span> &#123;</span><br><span class="line">    feet() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface2, 哺乳动物的共同行为</span></span><br><span class="line"><span class="keyword">type</span> Mammal <span class="keyword">interface</span> &#123;</span><br><span class="line">    born()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫既是猫科动物也是哺乳动物，2个行为都实现</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cat Cat)</span></span> feet() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;cat feet&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cat *Cat)</span></span> born() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;cat born&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cat := Cat&#123;<span class="string">&quot;rich&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> a Felines = cat</span><br><span class="line">    a.feet()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b Mammal = &amp;cat</span><br><span class="line">    b.born()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>interface可以嵌套：一个interface里包含其它interface</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// interface1</span></span><br><span class="line"><span class="keyword">type</span> Felines <span class="keyword">interface</span> &#123;</span><br><span class="line">    feet() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface2, 嵌套了interface1</span></span><br><span class="line"><span class="keyword">type</span> Mammal <span class="keyword">interface</span> &#123;</span><br><span class="line">    Felines</span><br><span class="line">    born()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫实现Mammal这个interface里的所有方法</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cat Cat)</span></span> feet() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;cat feet&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cat *Cat)</span></span> born() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;cat born&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cat := Cat&#123;<span class="string">&quot;rich&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">    <span class="comment">/*Mammal有feet和born方法，2个都可以调用*/</span></span><br><span class="line">    <span class="keyword">var</span> a Mammal = &amp;cat</span><br><span class="line">    a.feet()</span><br><span class="line">    a.born()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b Felines = cat</span><br><span class="line">    b.feet()</span><br><span class="line">    <span class="comment">// b.born() 调用这个会编译报错，因为Felines没有born方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>空接口interface</p>
<ul>
<li>
<p>如果空interface作为函数参数，可以接受任何类型的实参</p>
<ul>
<li>
<p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印空interface的类型和具体的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T, value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 传map实参给空接口</span></span><br><span class="line">    dict := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line">    <span class="built_in">print</span>(dict) <span class="comment">// type:map[string]int, value:map[a:1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传struct实参给空接口</span></span><br><span class="line">    cat := Cat&#123;<span class="string">&quot;nimo&quot;</span>, <span class="number">2</span>&#125;</span><br><span class="line">    <span class="built_in">print</span>(cat) <span class="comment">// type:main.Cat, value:&#123;nimo 2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>如果空interface作为变量，可以把任何类型的变量赋值给空interface</p>
<ul>
<li>
<p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 空接口x</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印空interface的类型和具体的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T, value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义空接口x</span></span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 将map变量赋值给空接口x</span></span><br><span class="line">    x = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line">    <span class="built_in">print</span>(x) <span class="comment">// type:map[string]int, value:map[a:1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传struct变量估值给空接口x</span></span><br><span class="line">    cat := Cat&#123;<span class="string">&quot;nimo&quot;</span>, <span class="number">2</span>&#125;</span><br><span class="line">    x = cat</span><br><span class="line">    <span class="built_in">print</span>(x) <span class="comment">// type:main.Cat, value:&#123;nimo 2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>空接口作为map的值，可以实现map的value是不同的数据类型</p>
<ul>
<li>
<p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个map类型的变量，key是string类型，value是空接口类型</span></span><br><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;) </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个map类型的变量，key是string类型，value是空接口类型</span></span><br><span class="line">    dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">// value可以是int类型</span></span><br><span class="line">    dict[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span> </span><br><span class="line">    <span class="comment">// value可以是字符串类型</span></span><br><span class="line">    dict[<span class="string">&quot;b&quot;</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">    <span class="comment">// value可以是bool类型</span></span><br><span class="line">    dict[<span class="string">&quot;c&quot;</span>] = <span class="literal">true</span></span><br><span class="line">    fmt.Println(dict) <span class="comment">// map[a:1 b:b c:true]</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T, value:%v\n&quot;</span>, dict[<span class="string">&quot;b&quot;</span>], dict[<span class="string">&quot;b&quot;</span>]) <span class="comment">// type:string, value:b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>x.(T)</p>
<ul>
<li>
<p>断言：断言接口变量x是T类型</p>
<ul>
<li>
<p>语法：value是将x转化为T类型后的变量，ok是布尔值，true表示断言成功，false表示断言失败</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x是接口变量，如果要判断x是不是</span></span><br><span class="line">value, ok := x.(<span class="type">string</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">x = <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="comment">// 断言接口变量x的类型是string</span></span><br><span class="line">v, ok := x.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    <span class="comment">// 断言成功</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;assert true, value:&quot;</span>, v)</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 断言失败</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;assert false&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>动态判断数据类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">/*动态判断x的数据类型*/</span></span><br><span class="line">    <span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type: int, value: %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type: string，value: %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type: bool, value: %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> Cat:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type: Cat, value: %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type: map[string]int, value: %v\n&quot;</span>, v)</span><br><span class="line">        v[<span class="string">&quot;a&quot;</span>] = <span class="number">10</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type: %T, value: %v\n&quot;</span>, x, x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    x = <span class="string">&quot;a&quot;</span></span><br><span class="line">    checkType(x) <span class="comment">//type: string，value: a</span></span><br><span class="line">    </span><br><span class="line">    x = Cat&#123;<span class="string">&quot;hugo&quot;</span>, <span class="number">3</span>&#125;</span><br><span class="line">    checkType(x) <span class="comment">// type: Cat, value: &#123;hugo 3&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在checkType里对map做修改</span></span><br><span class="line"><span class="comment">    会影响外面的实参x</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    x = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line">    checkType(x) <span class="comment">// type: map[string]int, value: map[a:1]</span></span><br><span class="line">    fmt.Println(x) <span class="comment">// map[a:10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意事项</strong></p>
<p>如果把一个结构体变量赋值给interface变量，那结构体需要实现interface里的所有方法，否则会编译报错：xx does not implement yy，表示结构体xx没有实现接口yy</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>15.Go-map集合</title>
    <url>/undefined/c6b790b1/</url>
    <content><![CDATA[<p>本文主要介绍Go语言中map集合的定义、初始化、使用、遍历、删除等操作。</p>
<span id="more"></span>
<h1 id="map集合"><a class="markdownIt-Anchor" href="#map集合"></a> map集合</h1>
<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2>
<p>Go语言里的map底层是通过<strong>hash</strong>实现的，是一种<strong>无序</strong>的基于&lt;key, value&gt;对组成的数据结构，key是唯一的，类似python的dict。</p>
<p>map必须初始化后才能写map。</p>
<p>如果只是声明map，但没有初始化，只能读，不能写。参考下面的例子的说明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> counter <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	map没有初始化，读map相当于读了一个空map</span></span><br><span class="line"><span class="comment">	下例中：value是int的零值0，ok是false</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	value, ok := counter[<span class="string">&quot;a&quot;</span>]</span><br><span class="line">	fmt.Println(value, ok)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*counter没有初始化，给counter赋值会在运行时报错</span></span><br><span class="line"><span class="comment">	  panic: assignment to entry in nil map</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	counter[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">	fmt.Println(counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map_var <span class="keyword">map</span>[key_data_type]value_data_type = <span class="keyword">map</span>[key_data_type]value_data_type&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map_var = <span class="keyword">map</span>[key_data_type]value_data_type&#123;&#125;</span><br><span class="line"></span><br><span class="line">map_var := <span class="keyword">map</span>[key_data_type]value_data_type&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*cap是map容量，超过后会自动扩容*/</span></span><br><span class="line">map_var := <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type, [<span class="built_in">cap</span>]) </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dict <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    dict[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">    fmt.Println(dict)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dict2 = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    dict2[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line">    fmt.Println(dict2)</span><br><span class="line">    </span><br><span class="line">    dict3 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;test&quot;</span>:<span class="number">0</span>&#125;</span><br><span class="line">    dict3[<span class="string">&quot;c&quot;</span>] = <span class="number">3</span></span><br><span class="line">    fmt.Println(dict2)</span><br><span class="line">    </span><br><span class="line">    dict4 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    dict4[<span class="string">&quot;d&quot;</span>] = <span class="number">4</span></span><br><span class="line">    fmt.Println(dict4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h2>
<ul>
<li>
<p>判断key在map里是否存在</p>
<ul>
<li>
<p>语法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, is_exist := <span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure>
<p>如果key存在，那is_exist就是true, value是对应的值。否则is_exist就是false, value是map的value数据类型的零值。</p>
<p><strong>注意</strong>: 如果key不存在，通过map[key]访问不会给map自动插入这个新key。C++是会自动插入新key的，两个语言不一样。如果确定key存在，可以直接使用map[key]拿到value。</p>
</li>
<li>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 构造一个map</span></span><br><span class="line">    str := <span class="string">&quot;aba&quot;</span></span><br><span class="line">    dict := <span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> str&#123;</span><br><span class="line">        dict[value]++</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(dict) <span class="comment">// map[97:2 98:1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问map里不存在的key，并不会像C++一样自动往map里插入这个新key</span></span><br><span class="line">    value, ok := dict[<span class="string">&#x27;z&#x27;</span>]</span><br><span class="line">    fmt.Println(value, ok) <span class="comment">// 0 false</span></span><br><span class="line">    fmt.Println(dict) <span class="comment">// map[97:2 98:1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问map里已有的key</span></span><br><span class="line">    value2 := dict[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    fmt.Println(value2) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>遍历map：使用range迭代。</p>
</li>
<li>
<p>len(map)：通过内置的len()函数可以获取map里&lt;key, value&gt;对的数量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">counter := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(counter))</span><br><span class="line">counter[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(counter))</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>map作为函数形参，可以在函数体内部改变外部实参的值。示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildMap</span><span class="params">(str <span class="type">string</span>, m <span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">/*函数内对map变量m的修改会影响main里的实参mapping*/</span></span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> str &#123;</span><br><span class="line">		m[value]++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mapping := <span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	str := <span class="string">&quot;abc&quot;</span></span><br><span class="line">	buildMap(str, mapping)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	mapping的值被buildMap修改了</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;key:%v, value:%d\n&quot;</span>, key, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="delete函数"><a class="markdownIt-Anchor" href="#delete函数"></a> delete函数</h2>
<ul>
<li>
<p>删除key，参数为map和对应的key。允许删除一个不存在的key，对map无任何影响。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dict :=  <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line">    fmt.Println(dict) <span class="comment">// map[a:1 b:2]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除&quot;a&quot;这个key</span></span><br><span class="line">    <span class="built_in">delete</span>(dict, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    fmt.Println(dict) <span class="comment">// map[b:2]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除&quot;c&quot;这个不在的key，对map结果无影响</span></span><br><span class="line">    <span class="built_in">delete</span>(dict, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    fmt.Println(dict) <span class="comment">// map[b:2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2>
<ul>
<li>
<p>key必须支持==和!=比较，才能用作map的key。</p>
<p>因此切片slice，函数类型function，集合map，不能用作map的key</p>
</li>
<li>
<p>map不是并发安全的，并发读写要加锁</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>14.Gorange迭代</title>
    <url>/undefined/57393c42/</url>
    <content><![CDATA[<p>本文主要介绍Go中range迭代的使用方法，包括对字符串、数组、切片、集合和通道的迭代。</p>
<span id="more"></span>
<h1 id="range迭代"><a class="markdownIt-Anchor" href="#range迭代"></a> range迭代</h1>
<p>range可以用于for循环，对字符串，数组array，切片slice，集合map或通道channel进行迭代</p>
<h2 id="range对字符串string进行迭代"><a class="markdownIt-Anchor" href="#range对字符串string进行迭代"></a> range对字符串string进行迭代</h2>
<ul>
<li>
<p>有2种方法可以对string进行range遍历，一种是只拿到字符串的下标索引，一种是同时拿到下标索引和对应的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;abcdgfg&quot;</span></span><br><span class="line">    <span class="comment">// 方法1：可以通过range拿到字符串的下标索引</span></span><br><span class="line">    <span class="keyword">for</span> index := <span class="keyword">range</span>(str) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index:%d, value:%d\n&quot;</span>, index, str[index])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法2：可以通过range拿到字符串的下标索引和对应的值</span></span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span>(str) &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;index=&quot;</span>, index, <span class="string">&quot;, value=&quot;</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以直接通过len获取字符串长度进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> index:=<span class="number">0</span>; index&lt;<span class="built_in">len</span>(str); index++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index:%d, value:%d\n&quot;</span>, index, str[index])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="range对数组array进行迭代"><a class="markdownIt-Anchor" href="#range对数组array进行迭代"></a> range对数组array进行迭代</h2>
<ul>
<li>
<p>一维数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SIZE = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    注意：数组的大小不能用变量，比如下面的SIZE必须是常量，如果是变量就会编译报错</span></span><br><span class="line"><span class="comment">    non-constant array bound size</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    array := [SIZE]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法1：只拿到数组的下标索引</span></span><br><span class="line">    <span class="keyword">for</span> index := <span class="keyword">range</span> array &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d value=%d &quot;</span>, index, array[index])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法2：同时拿到数组的下标索引和对应的值</span></span><br><span class="line">    <span class="keyword">for</span> index, value:= <span class="keyword">range</span> array &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d value=%d &quot;</span>, index, value)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>二维数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    array := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line">    <span class="comment">// 只拿到行的索引</span></span><br><span class="line">    <span class="keyword">for</span> index := <span class="keyword">range</span> array &#123;</span><br><span class="line">        <span class="comment">// array[index]类型是一维数组</span></span><br><span class="line">        fmt.Println(reflect.TypeOf(array[index]))</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d, value=%v\n&quot;</span>, index, array[index])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拿到行索引和该行的数据</span></span><br><span class="line">    <span class="keyword">for</span> row_index, row_value := <span class="keyword">range</span> array &#123;</span><br><span class="line">        fmt.Println(row_index, reflect.TypeOf(row_value), row_value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双重遍历，拿到每个元素的值</span></span><br><span class="line">    <span class="keyword">for</span> row_index, row_value := <span class="keyword">range</span> array &#123;</span><br><span class="line">        <span class="keyword">for</span> col_index, col_value := <span class="keyword">range</span> row_value &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;array[%d][%d]=%d &quot;</span>, row_index, col_index, col_value)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="range对切片slice进行迭代"><a class="markdownIt-Anchor" href="#range对切片slice进行迭代"></a> range对切片slice进行迭代</h2>
<ul>
<li>
<p>一维切片：会根据切片的长度len()进行遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    <span class="comment">// 方式1</span></span><br><span class="line">    <span class="keyword">for</span> index := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d, value=%d\n&quot;</span>, index, slice[index])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d, value=%d\n&quot;</span>, index, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>二维切片：range遍历方式类似二维数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := [][]<span class="type">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;&#125;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">    <span class="comment">// 方法1，拿到行索引</span></span><br><span class="line">    <span class="keyword">for</span> index := <span class="keyword">range</span> slice&#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d, type:%v, value=%v\n&quot;</span>, index, reflect.TypeOf(slice[index]), slice[index])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法2，拿到行索引和该行的值，每行都是一维切片</span></span><br><span class="line">    <span class="keyword">for</span> row_index, row_value := <span class="keyword">range</span> slice&#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d, type:%v, value=%v\n&quot;</span>, row_index, reflect.TypeOf(row_value), row_value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法3，双重遍历，获取每个元素的值</span></span><br><span class="line">    <span class="keyword">for</span> row_index, row_value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">for</span> col_index, col_value := <span class="keyword">range</span> row_value &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;slice[%d][%d]=%d &quot;</span>, row_index, col_index, col_value)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="range对集合map进行迭代"><a class="markdownIt-Anchor" href="#range对集合map进行迭代"></a> range对集合map进行迭代</h2>
<ul>
<li>
<p>有如下2种方法可以遍历map，一种是拿到key，一种是拿到key,value</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hash := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line">    <span class="comment">// 方法1，拿到key，再根据key获取value</span></span><br><span class="line">    <span class="keyword">for</span> key := <span class="keyword">range</span> hash&#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;key=%s, value=%d\n&quot;</span>, key, hash[key])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法2，同时拿到key和value</span></span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> hash&#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;key=%s, value=%d\n&quot;</span>, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* nil map不能存放key-value键值对，比如下面的方式会报错：panic: assignment to entry in nil map</span></span><br><span class="line"><span class="comment">    var hash2 map[string]int </span></span><br><span class="line"><span class="comment">    hash2[&quot;a&quot;] = 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="range对通道channel进行迭代"><a class="markdownIt-Anchor" href="#range对通道channel进行迭代"></a> range对通道channel进行迭代</h2>
<p>对channel进行range迭代，会循环从channel里取数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addData</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	每3秒往通道ch里发送一次数据</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	size := <span class="built_in">cap</span>(ch)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">		time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 数据发送完毕，关闭通道</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// 开启一个goroutine，用于往通道ch里发送数据</span></span><br><span class="line">	<span class="keyword">go</span> addData(ch)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* range迭代从通道ch里获取数据</span></span><br><span class="line"><span class="comment">	通道close后，range迭代取完通道里的值后，循环会自动结束</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>13.Go切片Slice</title>
    <url>/undefined/fe31314e/</url>
    <content><![CDATA[<p>本文主要介绍Go中切片slice的定义和使用方法，包括切片的定义、切片的底层数据结构、切片的使用、切片截取、切片常用的几个函数、切片的底层原理等内容。</p>
<span id="more"></span>  
<h1 id="切片slice"><a class="markdownIt-Anchor" href="#切片slice"></a> 切片Slice</h1>
<h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2>
<p>切片slice：切片是对数组的抽象。Go数组的长度在定义后是固定的，不可改变的。</p>
<p>切片的长度和容量是不固定的，可以动态增加元素，切片的容量也会根据情况自动扩容</p>
<ul>
<li>
<p>切片的底层数据结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切片slice是个struct结构体，里面实际有个指针array，类型是unsafe.Pointer，也就是个指针，指向存放数据的数组。</p>
<p>len是切片的长度，cap是切片的容量。</p>
</li>
<li>
<p>定义和初始化</p>
<ul>
<li>
<p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice_var []data_type <span class="comment">// 元素类型为data_type的切片</span></span><br><span class="line"><span class="keyword">var</span> slice_var []data_type = <span class="built_in">make</span>([]data_type, <span class="built_in">len</span>, <span class="built_in">cap</span>)<span class="comment">// cap是切片容量，是make的可选参数</span></span><br><span class="line"><span class="keyword">var</span> slice_var []data_type = <span class="built_in">make</span>([]data_type, <span class="built_in">len</span>)</span><br><span class="line">slice_var := []data_type&#123;&#125;</span><br><span class="line">slice_var := <span class="built_in">make</span>([]data_type, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(param []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice len:%d, cap:%d, value:%v\n&quot;</span>, <span class="built_in">len</span>(param), <span class="built_in">cap</span>(param), param)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice1 := []<span class="type">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">    slice2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">100</span>)</span><br><span class="line">    printSlice(slice1)</span><br><span class="line">    printSlice(slice2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>零值nil</p>
<ul>
<li>
<p>如果slice类型的变量定义后没有初始化赋值，那值就是默认值nil。对于nil切片，len和cap函数执行结果都是0。</p>
<p><strong>注意</strong>：下例里的slice有赋值，所以slice!=nil。slice2没有赋值，slice2==nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(param []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;param len:%d, cap:%d, value:%v\n&quot;</span>, <span class="built_in">len</span>(param), <span class="built_in">cap</span>(param), param)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> slice2 []<span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;slice==nil&quot;</span>, slice==<span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">    printSlice(slice)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;slice2==nil&quot;</span>, slice2==<span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">    printSlice(slice2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="切片的使用"><a class="markdownIt-Anchor" href="#切片的使用"></a> 切片的使用</h2>
<p>切片访问：对切片的访问，类似数组一样，可以用下标索引或者range迭代的方式进行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="comment">/*下标访问切片*/</span></span><br><span class="line">	slice[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	slice[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">	slice[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;slice[%d]=%d\n&quot;</span>, i, slice[i])		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*range迭代访问切片*/</span></span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;slice[%d]=%d\n&quot;</span>, index, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片截取"><a class="markdownIt-Anchor" href="#切片截取"></a> 切片截取</h3>
<p>切片截取<code>:</code>类似Python，使用冒号<code>:</code>来对数组或者切片做截取。</p>
<p>冒号<code>:</code>截取后的新slice变量底层有个指针，会指向原数组或者原切片的数组空间，对新切片的修改也会影响原数组或者原切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(param []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;param len:%d, cap:%d, value:%v\n&quot;</span>, <span class="built_in">len</span>(param), <span class="built_in">cap</span>(param), param)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> slice2 []<span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;slice==nil&quot;</span>, slice==<span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">    printSlice(slice)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;slice2==nil&quot;</span>, slice2==<span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">    printSlice(slice2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对数组做切片</span></span><br><span class="line">    array := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">// array是数组</span></span><br><span class="line">    slice3 := array[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// slice3是切片</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;slice3 type:&quot;</span>, reflect.TypeOf(slice3))</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice3=&quot;</span>, slice3) <span class="comment">// slice3= [2 3]</span></span><br><span class="line">    </span><br><span class="line">    slice4 := slice3[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice4=&quot;</span>, slice4) <span class="comment">// slice4= [3]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* slice5-&gt;slice4-&gt;slice3-&gt;array</span></span><br><span class="line"><span class="comment">    对slice5的修改，会影响到slice4, slice3和array</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    slice5 := slice4[:]</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice5=&quot;</span>, slice5) <span class="comment">// slice5= [3]</span></span><br><span class="line">    </span><br><span class="line">    slice5[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;array=&quot;</span>, array) <span class="comment">// array= [1 2 10]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;slice3=&quot;</span>, slice3) <span class="comment">// slice3= [2 10]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;slice4=&quot;</span>, slice4) <span class="comment">// slice4= [10]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;slice5=&quot;</span>, slice5) <span class="comment">// slice5= [10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片常用的几个函数"><a class="markdownIt-Anchor" href="#切片常用的几个函数"></a> 切片常用的几个函数</h3>
<p>len()和cap()函数：类似C++的vector里的size和capacity</p>
<ul>
<li>len()：获取切片的长度，也就是实际存储了多少个元素</li>
<li>cap(): 获取切片的容量。如果切片的元素个数要超过当前容量，会自动扩容</li>
</ul>
<p>append()：通过append函数给切片加元素</p>
<ul>
<li>
<p>append不改变原切片的值，比如下例里的append(slice, 4)并不会改变slice的值</p>
</li>
<li>
<p>只能对切片使用append()函数，不能对数组使用append()</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="comment">// 往原切片里加一个元素</span></span><br><span class="line">    test := <span class="built_in">append</span>(slice, <span class="number">4</span>)</span><br><span class="line">    <span class="comment">// append不会改变slice的值，除非把append的结果重新赋值给slice</span></span><br><span class="line">    fmt.Println(slice) <span class="comment">// [1 2 3]</span></span><br><span class="line">    fmt.Println(test) <span class="comment">// [1 2 3 4]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过append给切片添加切片</span></span><br><span class="line">    temp := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    test = <span class="built_in">append</span>(test, temp...) <span class="comment">// 注意，第2个参数有...结尾</span></span><br><span class="line">    fmt.Println(test) <span class="comment">// [1 2 3 4 1 2]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*下面对array数组做append就会报错:  first argument to append must be slice; have [3]int</span></span><br><span class="line"><span class="comment">    array := [3]int&#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="comment">    array2 := append(array, 1)</span></span><br><span class="line"><span class="comment">    fmt.Println(array2)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>copy()：拷贝一个切片里的数据到另一个切片</p>
<ul>
<li>
<p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>(dstSlice, srcSlice) <span class="comment">// 把srcSlice切片里的元素拷贝到dstSlice切片里</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​	<strong>注意事项</strong>：只从源切片srcSlice拷贝min(len(srcSlice), len(dstSlice))个元素到目标切片dstSlice里。如果dstSlice的长度是0，那一个都不会从srcSlice拷贝到dstSlice里。如果dstSlice的长度M小于srcSlice的长度N，则只会拷贝srcSlice里的前M个元素到目标切片dstSlice里。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>, <span class="number">3</span>) <span class="comment">// 切片b的长度是1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">copy</span>(b, a) <span class="comment">// 只拷贝1个元素到b里</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;a=&quot;</span>, a) <span class="comment">// a= [1 2]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;b=&quot;</span>, b) <span class="comment">// b= [1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数传参"><a class="markdownIt-Anchor" href="#函数传参"></a> 函数传参</h3>
<ul>
<li>
<p>slice切片如果是函数参数，函数体内对切片底层数组的修改会影响到实参。比如下例里的change1函数第一行</p>
</li>
<li>
<p><strong>如果在函数体内通过append直接对切片添加新元素，不会改变外部切片的值</strong>，比如下例里的change1函数第2行。但是如果函数使用切片指针作为参数，在函数体内可以通过切片指针修改外部切片的值，比如下例里的change2函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change1</span><span class="params">(param []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	param[<span class="number">0</span>] = <span class="number">100</span> <span class="comment">// 这个会改变外部切片的值</span></span><br><span class="line">	param = <span class="built_in">append</span>(param, <span class="number">200</span>) <span class="comment">// append不会改变外部切片的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change2</span><span class="params">(param *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	*param = <span class="built_in">append</span>(*param, <span class="number">300</span>) <span class="comment">// 传切片指针，通过这种方式append可以改变外部切片的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line">	fmt.Println(slice) <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line">	change1(slice)</span><br><span class="line">	fmt.Println(slice) <span class="comment">// [100, 0]</span></span><br><span class="line"></span><br><span class="line">	change2(&amp;slice)</span><br><span class="line">	fmt.Println(slice) <span class="comment">// [100, 0, 300]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="切片的底层原理"><a class="markdownIt-Anchor" href="#切片的底层原理"></a> 切片的底层原理</h2>
<ol>
<li><a href="https://github.com/jincheng9/go-tutorial/blob/main/workspace/senior/p8">Go Quiz: 从Go面试题看slice的底层原理和注意事项</a></li>
<li><a href="https://github.com/jincheng9/go-tutorial/blob/main/workspace/senior/p13">Go Quiz: 从Go面试题搞懂slice range遍历的坑</a></li>
</ol>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>12.Go结构体</title>
    <url>/undefined/ffa5bf91/</url>
    <content><![CDATA[<p>本文主要介绍Go中结构体的定义和使用方法，包括结构体的定义、访问结构体内的成员、结构体指针、方法和可见性等内容。</p>
<span id="more"></span>
<h1 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h1>
<h2 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h2>
<ul>
<li>
<p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_type <span class="keyword">struct</span> &#123;</span><br><span class="line">    member_name1 data_type1</span><br><span class="line">    member_name2 data_type2</span><br><span class="line">    member_name3, member_name4 data_type3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1：必须给结构体里每个成员赋值，如果只给部分成员赋值会编译报错</span></span><br><span class="line">struct_var := struct_type&#123;value1, value2, value3, value4&#125;</span><br><span class="line"><span class="comment">// 方式2：可以给部分或者全部成员赋值，没有赋值的成员的值是成员所属类型的零值</span></span><br><span class="line">struct_var2 := struct_type&#123;member_name1:value1, member_name2:value2&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">    title <span class="type">string</span></span><br><span class="line">    author <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">book1 := Book&#123;<span class="number">1</span>, <span class="string">&quot;go tutorial&quot;</span>, <span class="string">&quot;jincheng9&quot;</span>&#125;</span><br><span class="line">book2 := Book&#123;id:<span class="number">2</span>, title:<span class="string">&quot;day day up&quot;</span>, author:<span class="string">&quot;unknown&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="访问结构体内的成员"><a class="markdownIt-Anchor" href="#访问结构体内的成员"></a> 访问结构体内的成员</h2>
<p>访问结构体内的成员使用点<code>.</code>   ，格式为：<strong>结构体变量<code>.</code>成员</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">    author <span class="type">string</span></span><br><span class="line">    title <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> book Book</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">(book Book)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;id:&quot;</span>, book.id)</span><br><span class="line">    fmt.Println(<span class="string">&quot;author:&quot;</span>, book.author)</span><br><span class="line">    fmt.Println(<span class="string">&quot;title:&quot;</span>, book.title)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    book1 := Book&#123;<span class="number">1</span>, <span class="string">&quot;go tutorial&quot;</span>, <span class="string">&quot;jincheng9&quot;</span>&#125;</span><br><span class="line">    book2 := Book&#123;id:<span class="number">2</span>, title:<span class="string">&quot;day day up&quot;</span>, author:<span class="string">&quot;unknown&quot;</span>&#125;</span><br><span class="line">    printBook(book1)</span><br><span class="line">    printBook(book2)</span><br><span class="line">    </span><br><span class="line">    book.id = <span class="number">10</span></span><br><span class="line">    book.author = <span class="string">&quot;test&quot;</span></span><br><span class="line">    book.title = <span class="string">&quot;test&quot;</span></span><br><span class="line">    printBook(book)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体指针"><a class="markdownIt-Anchor" href="#结构体指针"></a> 结构体指针</h2>
<ul>
<li>
<p>语法。<strong>注意</strong>:结构体指针访问结构体里的成员，也是用点<code>.</code>，这个和C++用<code>-&gt;</code>不一样</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> struct_pointer *struct_type <span class="comment">// 指针struct_pointer指向结构体struct_type</span></span><br><span class="line">struct_var := struct_type&#123;&#125; <span class="comment">// 结构体变量</span></span><br><span class="line">struct_pointer = &amp;struct_var <span class="comment">// 指针赋值</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">    author <span class="type">string</span></span><br><span class="line">    title <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">(book *Book)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;id:&quot;</span>, book.id)</span><br><span class="line">    fmt.Println(<span class="string">&quot;author:&quot;</span>, book.author)</span><br><span class="line">    fmt.Println(<span class="string">&quot;title:&quot;</span>, book.title)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    book := Book&#123;<span class="number">1</span>, <span class="string">&quot;expert&quot;</span>, <span class="string">&quot;go&quot;</span>&#125;</span><br><span class="line">    bookPtr := &amp;book</span><br><span class="line">    printBook(bookPtr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h2>
<ul>
<li>
<p>Go没有C++的class概念，但是可以对struct结构体类型定义方法，结构体对象调用该方法，来达到类似效果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">    author <span class="type">string</span></span><br><span class="line">    title <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(book Book)</span></span> printBook() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;id:%d, author:%s, title:%s\n&quot;</span>, book.id, book.author, book.title)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(book *Book)</span></span> changeTitle1() &#123;</span><br><span class="line">    book.title = <span class="string">&quot;new title1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个无法改变调用该方法的结构体变量里的成员的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(book Book)</span></span> changeTitle2() &#123;</span><br><span class="line">    book.title = <span class="string">&quot;new title2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    book := Book&#123;<span class="number">1</span>, <span class="string">&quot;expert&quot;</span>, <span class="string">&quot;go&quot;</span>&#125;</span><br><span class="line">    book.printBook()</span><br><span class="line">    </span><br><span class="line">    book.changeTitle1() <span class="comment">// 会修改变量book里的成员title的值</span></span><br><span class="line">    book.printBook()</span><br><span class="line">    </span><br><span class="line">    book.changeTitle2() <span class="comment">// 不会对book的值有任何影响</span></span><br><span class="line">    book.printBook()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="可见性"><a class="markdownIt-Anchor" href="#可见性"></a> 可见性</h2>
<ul>
<li>结构体标识符和结构体的成员标识符可见性
<ul>
<li>如果结构体要被其它package使用，那结构体的标识符或者说结构体的名称首字母要大写</li>
<li>如果结构体的成员要被其它package使用，那结构体和结构体的成员标识符首字母都要大写，否则只能在当前包里使用</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>11.Go指针</title>
    <url>/undefined/d36541d4/</url>
    <content><![CDATA[<p>本文主要介绍Go中指针的基础语法，包括指针的定义、初始化、默认值、指向数组的指针、指针数组、指向指针的指针、向函数传递指针参数、指向结构体的指针等内容。</p>
<span id="more"></span>
<h1 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h1>
<h2 id="指针的基础语法"><a class="markdownIt-Anchor" href="#指针的基础语法"></a> 指针的基础语法</h2>
<p>指针的值是指向的变量的内存地址。</p>
<ul>
<li>
<p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *var_type</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intPtr *<span class="type">int</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>初始化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">10</span></span><br><span class="line">    <span class="comment">// 方式1</span></span><br><span class="line">    <span class="keyword">var</span> intPtr *<span class="type">int</span> = &amp;i</span><br><span class="line">    fmt.Println(<span class="string">&quot;pointer value:&quot;</span>, intPtr, <span class="string">&quot; point to: &quot;</span>, *intPtr)</span><br><span class="line">    fmt.Println(<span class="string">&quot;type of pointer:&quot;</span>, reflect.TypeOf(intPtr))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    intPtr2 := &amp;i</span><br><span class="line">    fmt.Println(*intPtr2)</span><br><span class="line">    fmt.Println(<span class="string">&quot;type of pointer:&quot;</span>, reflect.TypeOf(intPtr2))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式3</span></span><br><span class="line">    <span class="keyword">var</span> intPtr3 = &amp;i;</span><br><span class="line">    fmt.Println(*intPtr3)</span><br><span class="line">    fmt.Println(<span class="string">&quot;type of pointer:&quot;</span>, reflect.TypeOf(intPtr3))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式4</span></span><br><span class="line">    <span class="keyword">var</span> intPtr4 *<span class="type">int</span></span><br><span class="line">    intPtr4 = &amp;i</span><br><span class="line">    fmt.Println(*intPtr4)</span><br><span class="line">    fmt.Println(<span class="string">&quot;type of pointer:&quot;</span>, reflect.TypeOf(intPtr4))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="默认值"><a class="markdownIt-Anchor" href="#默认值"></a> 默认值</h2>
<ul>
<li>
<p>不赋值的时候，默认值是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intPtr5 *<span class="type">int</span>    </span><br><span class="line">fmt.Println(<span class="string">&quot;intPtr5==nil:&quot;</span>, intPtr5==<span class="literal">nil</span>) <span class="comment">// intPtr5==nil: true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="指向数组的指针"><a class="markdownIt-Anchor" href="#指向数组的指针"></a> 指向数组的指针</h2>
<ul>
<li>
<p>注意这里和C<ins>不一样，C</ins>的数组名就是指向数组首元素的地址，Go不是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arrayPtr *[<span class="number">3</span>]<span class="type">int</span> = &amp;array <span class="comment">// C++赋值就不用加&amp;</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(array); i++ &#123;</span><br><span class="line">  <span class="comment">// arrayPtr[i]的值就是数组array里下标索引i对应的值</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;arrayPtr[%d]=%d\n&quot;</span>, i, arrayPtr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="指针数组"><a class="markdownIt-Anchor" href="#指针数组"></a> 指针数组</h2>
<ul>
<li>
<p>定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ptr [SIZE]*<span class="type">int</span> <span class="comment">// 指向int的指针数组，数组里有多个指针，每个都指向一个int</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SIZE = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ptrArray [SIZE]*<span class="type">int</span></span><br><span class="line">    a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;SIZE; i++ &#123;</span><br><span class="line">        ptrArray[i] = &amp;a[i]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;SIZE; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, *ptrArray[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意字符串不能对其中的字符取地址</p>
</blockquote>
</li>
</ul>
<h2 id="指向指针的指针"><a class="markdownIt-Anchor" href="#指向指针的指针"></a> 指向指针的指针</h2>
<ul>
<li>
<p>定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> ptr1 *<span class="type">int</span> = &amp;a</span><br><span class="line"><span class="keyword">var</span> ptr2 **<span class="type">int</span> = &amp;ptr1</span><br><span class="line"><span class="keyword">var</span> ptr3 ***<span class="type">int</span> = &amp;ptr2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> ptr1 *<span class="type">int</span> = &amp;a</span><br><span class="line">    <span class="keyword">var</span> ptr2 **<span class="type">int</span> = &amp;ptr1</span><br><span class="line">    <span class="keyword">var</span> ptr3 ***<span class="type">int</span> = &amp;ptr2</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;*ptr1=&quot;</span>, *ptr1)</span><br><span class="line">    fmt.Println(<span class="string">&quot;**ptr2=&quot;</span>, **ptr2)</span><br><span class="line">    fmt.Println(<span class="string">&quot;***ptr3=&quot;</span>, ***ptr3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="向函数传递指针参数"><a class="markdownIt-Anchor" href="#向函数传递指针参数"></a> 向函数传递指针参数</h2>
<ul>
<li>
<p>示例：通过指针参数修改实参的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个可以交换外部传入的2个实参的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a *<span class="type">int</span>, b *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *a, *b = *b, *a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个无法交换外部传入的2个实参的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap2</span><span class="params">(a *<span class="type">int</span>, b *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    a, b = b, a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    swap(&amp;a, &amp;b)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a=&quot;</span>, a, <span class="string">&quot; b=&quot;</span>, b) <span class="comment">// a= 2  b= 1</span></span><br><span class="line">    </span><br><span class="line">    swap2(&amp;a, &amp;b)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a=&quot;</span>, a, <span class="string">&quot; b=&quot;</span>, b) <span class="comment">// a= 2  b= 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="指向结构体的指针"><a class="markdownIt-Anchor" href="#指向结构体的指针"></a> 指向结构体的指针</h2>
<p>指向结构体的指针在访问结构体成员的时候使用点<code>.</code>，和C++里用箭头-&gt;不一样。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>10.Go数组</title>
    <url>/undefined/7bc5e1cb/</url>
    <content><![CDATA[<p>本文主要介绍Go中数组的定义和使用方法，包括一维数组和多维数组的定义、初始化、访问等内容，以及数组作为函数参数传递的注意事项。</p>
<span id="more"></span>  
<h1 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h1>
<h2 id="一维数组"><a class="markdownIt-Anchor" href="#一维数组"></a> 一维数组</h2>
<ul>
<li>
<p>声明：数组的大小必须是常量，不能是变量，比如下面的语法里的size必须是常量</p>
<ul>
<li>
<p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [size] variable_type</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num_list [<span class="number">10</span>] <span class="type">int</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>初始化</p>
<ul>
<li>
<p>指定数组大小</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> float_num_list1 [<span class="number">5</span>]<span class="type">float32</span> = [<span class="number">5</span>]<span class="type">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;</span><br><span class="line"><span class="keyword">var</span> float_num_list2 = [<span class="number">5</span>]<span class="type">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;</span><br><span class="line">int_num_list := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> float_num_list1 &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[float_num_list1]index=&quot;</span>, index, <span class="string">&quot;value=&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> float_num_list2 &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[float_num_list2]index=&quot;</span>, index, <span class="string">&quot;value=&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> int_num_list &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[int_num_list]index=&quot;</span>, index, <span class="string">&quot;value=&quot;</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不显式指定数组大小，编译器根据赋的值自行推导</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balance1 []<span class="type">int</span> = [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125; <span class="comment">// 等价于[2]int&#123;1,2&#125;</span></span><br><span class="line"><span class="keyword">var</span> balance2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">balance3 := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;balance1=&quot;</span>, balance1)</span><br><span class="line">fmt.Println(<span class="string">&quot;balance2=&quot;</span>, balance2)</span><br><span class="line">fmt.Println(<span class="string">&quot;balance3=&quot;</span>, balance3)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指定数组大小情况下，特殊的初始化方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">balance := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>:<span class="number">10</span>, <span class="number">3</span>:<span class="number">30</span>&#125; <span class="comment">// 将数组下标为1和3的元素分别初始化为10和30</span></span><br><span class="line">fmt.Println(balance) <span class="comment">// [0, 10, 0, 30, 0]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>访问数组</p>
<ul>
<li>
<p>使用下标访问</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">balance := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>:<span class="number">10</span>, <span class="number">3</span>:<span class="number">30</span>&#125; <span class="comment">// 将数组下标为1和3的元素分别初始化为10和30</span></span><br><span class="line">fmt.Println(balance)</span><br><span class="line"></span><br><span class="line">num := balance[<span class="number">1</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;balance[%d]=%d\n&quot;</span>, i, balance[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>range遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> float_num_list1 [<span class="number">5</span>]<span class="type">float32</span> = [<span class="number">5</span>]<span class="type">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> float_num_list1 &#123;</span><br><span class="line">    <span class="comment">// index是数组下标</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;[float_num_list1]index=&quot;</span>, index) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> float_num_list1 &#123;</span><br><span class="line">    <span class="comment">// index是数组下标，value是对应的数组元素</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;[float_num_list1]index=&quot;</span>, index, <span class="string">&quot;value=&quot;</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取数组长度len(array)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [...]<span class="type">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; </span><br><span class="line">fmt.Println(<span class="string">&quot;array length=&quot;</span>, <span class="built_in">len</span>(a)) <span class="comment">// array length=5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h2>
<ul>
<li>
<p>声明：数组的大小必须是常量，不能是变量，比如下面语法里的size1，size2，…，sizeN必须是常量</p>
<ul>
<li>
<p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [size1][size2]...[sizeN] variable_type</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeDimArray [<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span> <span class="comment">// 三维数组，大小是 2x3x4</span></span><br><span class="line"><span class="keyword">var</span> twoDimArray [<span class="number">2</span>][<span class="number">3</span>] <span class="comment">// 二维数组，大小是2x3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>初始化</p>
<ul>
<li>
<p>初始化直接赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array1 := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span> &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, <span class="comment">// 如果花括号&#125;在下一行，这里必须有逗号。如果花括号在这一行可以不用逗号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>初始化默认值，后续再赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array2 := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">array2[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">array2[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;array2=&quot;</span>, array2)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>append赋值，只能对slice切片类型使用append，不能对数组使用append。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">twoDimArray := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">row1 := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">row2 := []<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">twoDimArray = <span class="built_in">append</span>(twoDimArray, row1)</span><br><span class="line">fmt.Println(<span class="string">&quot;twoDimArray=&quot;</span>, twoDimArray)</span><br><span class="line"></span><br><span class="line">twoDimArray = <span class="built_in">append</span>(twoDimArray, row2)</span><br><span class="line">fmt.Println(<span class="string">&quot;twoDimArray=&quot;</span>, twoDimArray)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>访问二维数组</p>
<ul>
<li>
<p>数组下标遍历具体的元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array1 := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span> &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;array1[%d][%d]=%d &quot;</span>, i, j, array1[i][j])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>数组下标遍历某行元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    array := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> index := <span class="keyword">range</span> array &#123;</span><br><span class="line">        <span class="comment">// array[index]类型是一维数组</span></span><br><span class="line">        fmt.Println(reflect.TypeOf(array[index])) </span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d, value=%v\n&quot;</span>, index, array[index])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>range遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">twoDimArray := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span> &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> twoDimArray &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;row %d is &quot;</span>, index) <span class="comment">//index的值是0,1，表示二维数组的第1行和第2行</span></span><br><span class="line">    fmt.Println(twoDimArray[index]) <span class="comment">//twoDimArray[index]类型就是一维数组</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">for</span> row_index, row_value := <span class="keyword">range</span> twoDimArray &#123;</span><br><span class="line">    <span class="keyword">for</span> col_index, col_value := <span class="keyword">range</span> row_value &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;twoDimArray[%d][%d]=%d &quot;</span>, row_index, col_index, col_value)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>注意事项</p>
<ul>
<li>
<p>slice类型的每一维度的大小可以不相同，比如下例里的第0行size是3，第1行size是2。如果直接访问twoDimArray[2][2]会报错。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">twoDimArray := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">row1 := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">row2 := []<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">twoDimArray = <span class="built_in">append</span>(twoDimArray, row1)</span><br><span class="line">fmt.Println(<span class="string">&quot;twoDimArray=&quot;</span>, twoDimArray)</span><br><span class="line"></span><br><span class="line">twoDimArray = <span class="built_in">append</span>(twoDimArray, row2)</span><br><span class="line">fmt.Println(<span class="string">&quot;twoDimArray=&quot;</span>, twoDimArray)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>数组作为函数参数进行传递</p>
<ul>
<li>
<p>如果数组作为函数参数，实参和形参的定义必须相同，要么都是长度相同的数组，要么都是slice类型。如果实参和形参的类型一个是数组，一个是slice，或者实参和形参都是数组但是长度不一致都会编译报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(array [5]<span class="type">int</span>, size <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        sum += array[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumSlice</span><span class="params">(array []<span class="type">int</span>, size <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        sum += array[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">5</span>]<span class="type">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">// a := [...]int&#123;1, 2, 3, 4, 5&#125;也可以去调用sum，编译器会自动推导出a的长度5</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;type of a:&quot;</span>, reflect.TypeOf(a)) <span class="comment">// type of a: [5]int</span></span><br><span class="line">    ans := sum(a, <span class="number">5</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;ans=&quot;</span>, ans)</span><br><span class="line">    </span><br><span class="line">    b := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    ans2 := sumSlice(b, <span class="number">5</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;ans2=&quot;</span>, ans2)</span><br><span class="line">    </span><br><span class="line">    array := [...]<span class="type">int</span> &#123;<span class="number">1</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;type of array:&quot;</span>, reflect.TypeOf(array)) <span class="comment">// type of array: [1]int，是一个数组类型</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;array=&quot;</span>, array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>值传递和引用传递</p>
<ul>
<li>
<p><strong>Go语言里只有值传递，没有引用传递</strong>。</p>
</li>
<li>
<p>如果数组作为函数参数，在函数体内不能改变外部实参的值。如果使用数组作为形参，想修改实参的值，那就要传指向数组的指针</p>
</li>
<li>
<p>如果slice作为函数参数，在函数体内可以改变外部实参的值，<strong>但是这并不意味着slice是引用传递</strong>，slice传参也是值传递。只不过slice这个结构里有一个指针指向底层的数组，实参把值拷贝给形参的时候，形参slice里的指针和外部实参slice的指针的值相同，也就指向了同一块数组内存空间，所以形参slice对数组元素做修改也会影响外部实参的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// changeArray无法改变实参数组的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeArray</span><span class="params">(array [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// changeArray2可以改变实参的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeArray2</span><span class="params">(array *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// changeArray3可以改变实参的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeArray3</span><span class="params">(array []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">param := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">changeArray(param)</span><br><span class="line">fmt.Println(<span class="string">&quot;param=&quot;</span>, param) <span class="comment">// param= [1 2 3]</span></span><br><span class="line">changeArray2(&amp;param)</span><br><span class="line">fmt.Println(<span class="string">&quot;param=&quot;</span>, param) <span class="comment">// param= [10 2 3]</span></span><br><span class="line"></span><br><span class="line">sliceArray := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">changeArray3(sliceArray)</span><br><span class="line">fmt.Println(<span class="string">&quot;sliceArray=&quot;</span>, sliceArray) <span class="comment">// sliceArray= [10 2 3]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>09.Go函数，闭包和方法</title>
    <url>/undefined/66c36c37/</url>
    <content><![CDATA[<p>本文主要介绍Go函数，闭包和方法的定义和使用方法。</p>
<span id="more"></span>
<h1 id="函数闭包和方法"><a class="markdownIt-Anchor" href="#函数闭包和方法"></a> 函数，闭包和方法</h1>
<h2 id="函数定义"><a class="markdownIt-Anchor" href="#函数定义"></a> 函数定义</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">([parameter list])</span></span> [return_types] &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无参数"><a class="markdownIt-Anchor" href="#无参数"></a> 无参数</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无返回值"><a class="markdownIt-Anchor" href="#无返回值"></a> 无返回值</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回1个值"><a class="markdownIt-Anchor" href="#返回1个值"></a> 返回1个值</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回多个值"><a class="markdownIt-Anchor" href="#返回多个值"></a> 返回多个值</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(a <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(a <span class="type">int</span>, b <span class="type">string</span>)</span></span>(<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(a, b <span class="type">int</span>, c, d <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给返回值命名"><a class="markdownIt-Anchor" href="#给返回值命名"></a> 给返回值命名</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func2.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数add的返回值有2个，类型是int，标识符分别是c和d</span></span><br><span class="line"><span class="comment">可以在函数体内直接给c和d赋值，return后面可以带，也可以不带返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addAndSub</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (c <span class="type">int</span>, d <span class="type">int</span>) &#123;</span><br><span class="line">	c = a + b</span><br><span class="line">	d = a - b</span><br><span class="line">	<span class="keyword">return</span> <span class="comment">// 这一行写为 return c, d 也可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a1, b1 := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">	c1, d1 := addAndSub(a1, b1)</span><br><span class="line">	<span class="comment">/*输出结果是：3 -1*/</span></span><br><span class="line">	fmt.Println(c1, d1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>函数的参数列表不允许部分形参有命名，部分形参没命名，如果违背这个原则，就会报如下的编译错误。</li>
<li>函数的返回值列表不允许部分返回值变量有命名，部分返回值变量没命名，如果违背这个原则，就会报如下的编译错误。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">syntax error: mixed named and unnamed <span class="keyword">function</span> parameters</span><br></pre></td></tr></table></figure>
<p>一句话总结：要么都不命名，要么都命名(都命名的情况下，允许形参或者返回值变量使用<code>_</code>作为命名)。</p>
<h2 id="nil函数"><a class="markdownIt-Anchor" href="#nil函数"></a> nil函数</h2>
<p>函数也是一种类型，函数变量的默认值是<code>nil</code>，执行<code>nil</code>函数会引发panic</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// f是一个函数类型，值是nil</span></span><br><span class="line"><span class="comment">// 编译正常，运行报错panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line">f() </span><br></pre></td></tr></table></figure>
<h2 id="函数参数传递"><a class="markdownIt-Anchor" href="#函数参数传递"></a> 函数参数传递</h2>
<p><strong>Go里的函数传参只有值传递这一种方式</strong>：和C++里的传值一样，参加下例里的swap</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>, c, d <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> a+b, c+d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|swap]a=&quot;</span>, a, <span class="string">&quot;b=&quot;</span>, b)</span><br><span class="line">	a, b = b, a</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|swap]a=&quot;</span>, a, <span class="string">&quot;b=&quot;</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapRef</span><span class="params">(pa *<span class="type">int</span>, pb *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|swapRef]a=&quot;</span>, *pa, <span class="string">&quot;b=&quot;</span>, *pb)</span><br><span class="line">	<span class="keyword">var</span> temp = *pa</span><br><span class="line">	*pa = *pb</span><br><span class="line">	*pb = temp</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|swapRef]a=&quot;</span>, *pa, <span class="string">&quot;b=&quot;</span>, *pb)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">	c, d := <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span></span><br><span class="line">	res1, res2 := add(a, b, c, d)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;res1=&quot;</span>, res1, <span class="string">&quot;res2=&quot;</span>, res2)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|main]a=&quot;</span>, a, <span class="string">&quot;b=&quot;</span>, b)</span><br><span class="line">	swap(a, b)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|main]a=&quot;</span>, a, <span class="string">&quot;b=&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|main]a=&quot;</span>, a, <span class="string">&quot;b=&quot;</span>, b)</span><br><span class="line">	swapRef(&amp;a, &amp;b)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|main]a=&quot;</span>, a, <span class="string">&quot;b=&quot;</span>, b)	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然swap函数无法改变外部实参的值，swapRef函数可以改变外部实参的值，但是swap和swapRef函数其实都是值传递，细节区别是：</p>
<ul>
<li>swap是直接把变量a和b的值拷贝一份给形参</li>
<li>swapRef是把变量a和b的地址拷贝一份给形参</li>
</ul>
<p>所以，要清楚这2个其实都是值传递，Go里的函数传参也只有值传递这一种方式，并没有像C++那样的引用变量和引用传递。</p>
<p>后续学习了Go里的map等变量类型，可以参考这篇文章<a href="../senior/p3">Go有引用变量和引用传递么？</a></p>
<h2 id="函数高级用法"><a class="markdownIt-Anchor" href="#函数高级用法"></a> 函数高级用法</h2>
<p>函数作为其它函数的实参：函数定义后可以作为另一个函数的实参，比如下例的函数realFunc作为函数calValue的实参</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define function getSquareRoot1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSquareRoot1</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deffine a function variable</span></span><br><span class="line"><span class="keyword">var</span> getSquareRoot2 = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define a function type</span></span><br><span class="line"><span class="keyword">type</span> callback_func <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// function calValue accepts a function variable cb as its second argument</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calValue</span><span class="params">(x <span class="type">int</span>, cb callback_func)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[func|calValue]&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> cb(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">realFunc</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[func|realFunc]callback function&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> x*x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="number">100.00</span></span><br><span class="line">	result1 := getSquareRoot1(num)</span><br><span class="line">	result2 := getSquareRoot2(num)</span><br><span class="line">	fmt.Println(<span class="string">&quot;result1=&quot;</span>, result1)</span><br><span class="line">	fmt.Println(<span class="string">&quot;result2=&quot;</span>, result2)</span><br><span class="line"></span><br><span class="line">	value := <span class="number">81</span></span><br><span class="line">	result3 := calValue(value, realFunc) <span class="comment">// use function realFunc as argument of calValue</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;result3=&quot;</span>, result3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="闭包匿名函数-顾名思义就是没有函数名"><a class="markdownIt-Anchor" href="#闭包匿名函数-顾名思义就是没有函数名"></a> 闭包：匿名函数。顾名思义就是没有函数名。</h3>
<p>参考下面的代码示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func3.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		定义2个匿名函数，也就是闭包。</span></span><br><span class="line"><span class="comment">		闭包可以直接调用，也可以赋值给一个变量，后续调用</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	result1 := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b</span><br><span class="line">	&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> sub = <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a - b</span><br><span class="line">	&#125;</span><br><span class="line">	result2 := sub(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="comment">/*输出结果：3 -1*/</span></span><br><span class="line">	fmt.Println(result1, result2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法类似c-class里的方法只是go没有class的概念"><a class="markdownIt-Anchor" href="#方法类似c-class里的方法只是go没有class的概念"></a> 方法：类似C++ class里的方法，只是go没有class的概念。</h2>
<ul>
<li>
<p>定义：function_name是类型var_data_type的实例的方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(var_name var_data_type)</span></span> function_name([parameter_list])[<span class="keyword">return</span> <span class="keyword">type</span>] &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例：getArea是Circle的方法，Circle的实例可以调用该方法</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> getArea() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3.14</span> * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">changeRadius和changeRadius2的区别是后者可以改变变量c的成员radius的值，前者不能改变</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> changeRadius(radius <span class="type">float64</span>) &#123;</span><br><span class="line">	c.radius = radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Circle)</span></span> changeRadius2(radius <span class="type">float64</span>) &#123;</span><br><span class="line">	c.radius = radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> addRadius(x <span class="type">float64</span>) <span class="type">float64</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> c.radius + x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Circle</span><br><span class="line">	c.radius = <span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;radius=&quot;</span>, c.radius, <span class="string">&quot;area=&quot;</span>, c.getArea())	<span class="comment">//10, 314</span></span><br><span class="line"></span><br><span class="line">	c.changeRadius(<span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;radius=&quot;</span>, c.radius, <span class="string">&quot;area=&quot;</span>, c.getArea())	<span class="comment">//10, 314	</span></span><br><span class="line"></span><br><span class="line">	c.changeRadius2(<span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;radius=&quot;</span>, c.radius, <span class="string">&quot;area=&quot;</span>, c.getArea())	<span class="comment">//20, 1256</span></span><br><span class="line"></span><br><span class="line">	result := c.addRadius(<span class="number">3.6</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;radius=&quot;</span>, c.radius, <span class="string">&quot;result=&quot;</span>, result) <span class="comment">// 20, 23.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2>
<ul>
<li><a href="https://yourbasic.org/golang/named-return-values-parameters/">https://yourbasic.org/golang/named-return-values-parameters/</a></li>
<li><a href="https://golangshowcase.com/question/mixed-named-and-unnamed-parameters-in-golang">https://golangshowcase.com/question/mixed-named-and-unnamed-parameters-in-golang</a></li>
<li><a href="https://www.geeksforgeeks.org/named-return-parameters-in-golang/">https://www.geeksforgeeks.org/named-return-parameters-in-golang/</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>08.Go循环控制</title>
    <url>/undefined/b0e5566e/</url>
    <content><![CDATA[<p>本文主要介绍Go中的循环控制，包括for循环的4种用法、break、continue、goto、break和label结合使用等内容。</p>
<span id="more"></span>  
<h1 id="循环控制"><a class="markdownIt-Anchor" href="#循环控制"></a> 循环控制</h1>
<h2 id="for的4种用法"><a class="markdownIt-Anchor" href="#for的4种用法"></a> for的4种用法</h2>
<ul>
<li>
<p>用法1: 类似C++的<code>for(int i=0; i&lt;100; i++)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> init; condition; post &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> init; condition; &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ; condition; &#123; <span class="comment">// 类似下面的用法2</span></span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用法2：类似C++的while循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用法3: 死循环，类似C++的<code>for(;;)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用法4: For-each range循环, 类似python的<code> for k,v in dict.items()</code></p>
<p>可以对slice，map，数组和字符串等数据类型进行For-each迭代循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> map1 &#123; <span class="comment">// 遍历map</span></span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> list &#123; <span class="comment">// 遍历数组</span></span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, character := <span class="keyword">range</span> str &#123; <span class="comment">// 遍历字符串</span></span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>break：跳出当前for循环或者switch控制逻辑</p>
</li>
<li>
<p>continue：结束当前循环，继续下一轮for循环</p>
</li>
</ul>
<h2 id="goto"><a class="markdownIt-Anchor" href="#goto"></a> goto：</h2>
<p>类似C++里的goto</p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">label: statement</span><br><span class="line"><span class="keyword">goto</span> label</span><br></pre></td></tr></table></figure>
<ul>
<li>代码示例1</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	LOOP: </span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;Enter your age:&quot;</span>)</span><br><span class="line">		<span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line">		_, err := fmt.Scan(&amp;age) <span class="comment">// 接受控制台输入</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">			<span class="keyword">goto</span> LOOP</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> age &lt; <span class="number">18</span> &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;You are not eligible to vote!&quot;</span>)</span><br><span class="line">			<span class="keyword">goto</span> LOOP</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;You are eligible to vote!&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;all finish&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="break和label结合"><a class="markdownIt-Anchor" href="#break和label结合"></a> break和label结合</h2>
<p>break和label结合使用，可以跳出二重或者多重for循环。</p>
<p>例1：<code>break A</code>直接跳出整个外层for循环，所以下面的例子只执行<code>i=0, j=0</code>这一次循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终输出 0 0 Hello, 世界</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">A:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; i &lt; <span class="number">2</span>; j++ &#123;</span><br><span class="line">			<span class="built_in">print</span>(i, <span class="string">&quot; &quot;</span>, j, <span class="string">&quot; &quot;</span>)</span><br><span class="line">			<span class="keyword">break</span> A</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, 世界&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2：下面的例子，break只能跳出位于里层的for循环，会执行<code>i=0, j=0</code>和<code>i=1, j=0</code>这2次循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 输出 0 0 1 0 Hello, 世界</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; i &lt; <span class="number">2</span>; j++ &#123;</span><br><span class="line">			<span class="built_in">print</span>(i, <span class="string">&quot; &quot;</span>, j, <span class="string">&quot; &quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, 世界&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>07.Go条件语句</title>
    <url>/undefined/ca0019fd/</url>
    <content><![CDATA[<p>本文主要介绍Go中的条件语句，包括if和switch语句的使用方法。</p>
<span id="more"></span>  
<h1 id="条件语句"><a class="markdownIt-Anchor" href="#条件语句"></a> 条件语句</h1>
<h2 id="if"><a class="markdownIt-Anchor" href="#if"></a> If</h2>
<p>布尔表达式可以不加括号</p>
<ul>
<li>
<p>if/else</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression &#123;</span><br><span class="line">  do sth1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  do sth2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>if/else if/else</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression1 &#123;</span><br><span class="line">  do sth1</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> expression2 &#123;</span><br><span class="line">  do sth2</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  do sth3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>if/else嵌套</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression1 &#123;</span><br><span class="line">  <span class="keyword">if</span> expression11 &#123;</span><br><span class="line">    do sth11</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    do sth12</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> expression2 &#123;</span><br><span class="line">  do sth2</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  do sth3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>if赋予初始值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> variant:=value ; expression &#123;</span><br><span class="line">  do sth1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  do sth2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是赋予初始值只能使用<code>variant:=value</code>的变量定义方式</p>
</blockquote>
</li>
</ul>
<h2 id="switch"><a class="markdownIt-Anchor" href="#switch"></a> switch</h2>
<ul>
<li>
<p>每一个case分支都是唯一的，从上往下逐一判断，直到匹配为止。如果某些case分支条件重复了，编译会报错</p>
</li>
<li>
<p>默认情况下每个case分支最后自带break效果，匹配成功就不会执行其它case。</p>
<p>如果需要执行后面的case，可以使用fallthrough。</p>
<p>使用 fallthrough 会强制执行紧接着的下一个 case 语句，不过fallthrough 不会去分析紧接着的下一条 case 的表达式结果是否满足条件，而是直接执行case里的语句块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Foo prints and returns n.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> Foo(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> Foo(<span class="number">1</span>), Foo(<span class="number">2</span>), Foo(<span class="number">3</span>):</span><br><span class="line">        fmt.Println(<span class="string">&quot;First case&quot;</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> Foo(<span class="number">4</span>):</span><br><span class="line">        fmt.Println(<span class="string">&quot;Second case&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如上面的例子，执行结果如下，并不会去执行<code>fallthrough</code>的下一个case分支里的表达式<code>Foo(4)</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">First case</span><br><span class="line">Second case</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>switch使用方法1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> variable &#123;</span><br><span class="line">  <span class="keyword">case</span> value1:</span><br><span class="line">    do sth1</span><br><span class="line">  <span class="keyword">case</span> value2:</span><br><span class="line">    do sth2</span><br><span class="line">  <span class="keyword">case</span> value3, value4: <span class="comment">// 可以匹配多个值，只要一个满足条件即可</span></span><br><span class="line">    do sth34</span><br><span class="line">  <span class="keyword">case</span> value5:</span><br><span class="line">    do sth5</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>switch使用方法2</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// freebsd, openbsd,</span></span><br><span class="line">		<span class="comment">// plan9, windows...</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的写法和这个等价</span></span><br><span class="line">os := runtime.GOOS</span><br><span class="line"><span class="keyword">switch</span> os &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// freebsd, openbsd,</span></span><br><span class="line">		<span class="comment">// plan9, windows...</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>switch使用方法3。case分支的每个condition结果必须是一个bool值，要么为true，要么为false</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> condition1:</span><br><span class="line">  	do sth1</span><br><span class="line">  <span class="keyword">case</span> condition2:</span><br><span class="line">  	do sth2</span><br><span class="line">  <span class="keyword">case</span> condition3, condition4:</span><br><span class="line">  	do sth34</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>switch使用方法4。只适用于<code>interface</code>的类型判断，而且<code>&#123;</code>要和<code>switch</code>在同一行，<code>&#123;</code>前面不能有分号<code>;</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">10</span></span><br><span class="line">	<span class="keyword">switch</span> t := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;I&#x27;m a bool&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;I&#x27;m an int&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Don&#x27;t know type %T\n&quot;</span>, t)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2>
<ul>
<li><a href="https://yourbasic.org/golang/switch-statement/">https://yourbasic.org/golang/switch-statement/</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>06.Go中的运算符</title>
    <url>/undefined/e6208f17/</url>
    <content><![CDATA[<p>本文主要介绍Go中的运算符，包括算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符等内容。</p>
<span id="more"></span>
<h1 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h1>
<h2 id="算术运算符"><a class="markdownIt-Anchor" href="#算术运算符"></a> 算术运算符</h2>
<ul>
<li>
<p>加+, 减-, 乘*,除 /, 模%, 自增++, 自减–</p>
</li>
<li>
<p>go里的除法/和C++里一样，如果是2个整数相除，结果还是整数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;6/5=&quot;</span>, <span class="number">6</span>/<span class="number">5</span>) <span class="comment">// 结果是1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="关系运算符"><a class="markdownIt-Anchor" href="#关系运算符"></a> 关系运算符</h2>
<ul>
<li>相等==</li>
<li>不等!=</li>
<li>大于&gt;，大于等于&gt;=</li>
<li>小于&lt;，小于等于&lt;=</li>
</ul>
<h2 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h2>
<ul>
<li>与&amp;&amp;</li>
<li>或||</li>
<li>非!</li>
</ul>
<h2 id="位运算符"><a class="markdownIt-Anchor" href="#位运算符"></a> 位运算符</h2>
<ul>
<li>按位与<code>&amp;</code></li>
<li>按位或<code>|</code></li>
<li>按位异或<code>^</code></li>
<li>左移<code>&lt;&lt;</code></li>
<li>右移<code>&gt;&gt;</code></li>
<li>取反<code>^</code></li>
</ul>
<h2 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符"></a> 赋值运算符</h2>
<ul>
<li>=, +=, -=, *=, /=, %=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^=, |=</li>
</ul>
<h2 id="其它运算符"><a class="markdownIt-Anchor" href="#其它运算符"></a> 其它运算符</h2>
<ul>
<li>
<p>返回变量的内存地址&amp;</p>
<ul>
<li>&amp;a给出变量a的内存地址</li>
</ul>
</li>
<li>
<p>指针操作<code>*</code>，取指针指向的变量的值</p>
<ul>
<li>*a中a是一个指针类型的变量</li>
</ul>
</li>
<li>
<p>Go没有三目运算符<code>?:</code></p>
</li>
</ul>
<h2 id="运算符优先级"><a class="markdownIt-Anchor" href="#运算符优先级"></a> 运算符优先级</h2>
<p>参考：<a href="https://go.dev/ref/spec#Operator_precedence">https://go.dev/ref/spec#Operator_precedence</a></p>
<h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2>
<ul>
<li>
<p><a href="https://github.com/jincheng9/golang-cheat-sheet-cn#%E6%93%8D%E4%BD%9C%E7%AC%A6">https://github.com/jincheng9/golang-cheat-sheet-cn#操作符</a></p>
</li>
<li>
<p><a href="https://go.dev/ref/spec#Operator_precedence">https://go.dev/ref/spec#Operator_precedence</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>02.Go的程序结构</title>
    <url>/undefined/b15049a7/</url>
    <content><![CDATA[<p>本文主要介绍Go的程序结构，包括包声明、引入包、函数、变量、语句和表达式、注释等内容。</p>
<span id="more"></span>
<h1 id="go的程序结构"><a class="markdownIt-Anchor" href="#go的程序结构"></a> Go的程序结构</h1>
<ul>
<li>
<p>包声明</p>
</li>
<li>
<p>引入包</p>
</li>
<li>
<p>函数</p>
</li>
<li>
<p>变量</p>
</li>
<li>
<p>语句和表达式</p>
</li>
<li>
<p>注释</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"><span class="comment">// package declaration</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// import package</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// global variable</span></span><br><span class="line"><span class="keyword">var</span> g <span class="type">int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">  res := add(a, b)</span><br><span class="line">  fmt.Println(<span class="string">&quot;a=&quot;</span>, a, <span class="string">&quot;b=&quot;</span>, b, <span class="string">&quot;a+b=&quot;</span>, res)</span><br><span class="line">  fmt.Println(<span class="string">&quot;g=&quot;</span>, g)</span><br><span class="line">  fmt.Println(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h1>
<ul>
<li>
<p>func main()是程序开始执行的函数(但是如果有func init()函数，则会先执行init函数，再执行main函数)</p>
</li>
<li>
<p>源程序文件所在的目录名称与包名称没有直接关系，不需要一致。不过通常保持一致，这符合Go的编码规范。</p>
</li>
<li>
<p>源程序文件名与包名没有直接关系，不需要将源程序文件名与文件开头申明的包名保持一样，通常这2者是不一样的。</p>
</li>
<li>
<p>只有在源程序文件开头声明package main，并且有func main()定义，才能生成可执行程序，否则go run file.go会报错，报错内容:</p>
<figure class="highlight plaintext"><figcaption><span>command-line-arguments is not a main packagego</span></figcaption><table><tr><td class="code"><pre><span class="line">package command-line-arguments is not a main package</span><br><span class="line">和</span><br><span class="line">runtime.main_main·f: function main is undeclared in the main package</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="编译和运行"><a class="markdownIt-Anchor" href="#编译和运行"></a> 编译和运行</h1>
<p>Go是编译型语言</p>
<ul>
<li>编译+运行分步执行
<ul>
<li>go build hello.go</li>
<li>./hello</li>
</ul>
</li>
<li>编译+运行一步到位
<ul>
<li>go run hello.go</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>03.Go的基础数据类型</title>
    <url>/undefined/b52965b/</url>
    <content><![CDATA[<p>本文主要介绍Go的基础数据类型，包括数字、字符串、bool等类型，以及类型转换的方法。</p>
<span id="more"></span>
<h1 id="基础数据类型"><a class="markdownIt-Anchor" href="#基础数据类型"></a> 基础数据类型</h1>
<h2 id="数字"><a class="markdownIt-Anchor" href="#数字"></a> 数字</h2>
<ul>
<li>
<p>整数：int, uint8, uint16, uint32, uint64, int8, int16, int32, int64</p>
</li>
<li>
<p>浮点数：float32, float64</p>
</li>
<li>
<p>复数：</p>
<ul>
<li>
<p>complex64：实部和虚部都是float32类型的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v <span class="type">complex64</span> = <span class="number">1</span> + <span class="number">0.5i</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>complex128：实部和虚部都是float64类型的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v <span class="type">complex128</span> = <span class="number">1</span> + <span class="number">0.5i</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>注意</strong>：虚部为1的情况，1不能省略，否则编译报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v <span class="type">complex64</span> = <span class="number">1</span> + i <span class="comment">// compile error: undefined i</span></span><br><span class="line"><span class="keyword">var</span> v <span class="type">complex64</span> = <span class="number">1</span> + <span class="number">1i</span> <span class="comment">// correct</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="字符串string"><a class="markdownIt-Anchor" href="#字符串string"></a> 字符串：string</h2>
<ul>
<li>
<p>len(str)函数可以获取字符串长度</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;abcdgfg&quot;</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(str)) <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>注意</strong>：string是immutable的，不能在初始化string变量后，修改string里的值，除非对string变量重新赋值</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;abc&quot;</span></span><br><span class="line">    str = <span class="string">&quot;def&quot;</span> <span class="comment">// ok</span></span><br><span class="line">    <span class="comment">/* 下面的就不行，编译报错：cannot assign to str[0] (strings are immutable)</span></span><br><span class="line"><span class="comment">    str[0] = &quot;d&quot;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>字符串里字符的访问可以通过str[index]下标索引或者range迭代的方式进行访问</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="comment">/*下标访问*/</span></span><br><span class="line">    size := <span class="built_in">len</span>(str)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, str[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*range迭代访问*/</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> str &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不能对string里的某个字符取地址：如果s[i]是字符串s里的第i个字符，那&amp;s[i]这种方式是非法的</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string3.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;abc&quot;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	the following code has compile error:</span></span><br><span class="line"><span class="comment">	cannot take the address of str[0]</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	fmt.Println(&amp;str[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>string可以使用 <code>:</code> 来做字符串截取</p>
<p><strong>注意</strong>：这里和<a href="../lesson13">切片slice</a>的截取有区别</p>
<ul>
<li>字符串截取后赋值给新变量，对新变量的修改不会影响原字符串的值</li>
<li>切片截取后复制给新变量，对新变量的修改会影响原切片的值</li>
</ul>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string4.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// 3</span></span><br><span class="line">	s1 := s[:]</span><br><span class="line">	s2 := s[:<span class="number">1</span>]</span><br><span class="line">	s3 := s[<span class="number">0</span>:]</span><br><span class="line">	s4 := s[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">	fmt.Println(s, s1, s2, s3, s4) <span class="comment">// abc abc a abc ab</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	strTest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>string可以用<code>+</code>做字符串拼接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string5.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="string">&quot;ch&quot;</span></span><br><span class="line">	b := <span class="string">&quot;ina&quot;</span></span><br><span class="line">	c := a + b</span><br><span class="line">	fmt.Println(c) <span class="comment">// china</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>string的更多用法可以参考：<a href="https://yourbasic.org/golang/string-functions-reference-cheat-sheet/">https://yourbasic.org/golang/string-functions-reference-cheat-sheet/</a></p>
</li>
</ul>
<h2 id="bool"><a class="markdownIt-Anchor" href="#bool"></a> bool</h2>
<p>值只能为<code>true</code>或<code>false</code>。</p>
<h2 id="其它数字类型"><a class="markdownIt-Anchor" href="#其它数字类型"></a> 其它数字类型</h2>
<ul>
<li>
<p>byte：等价于uint8，数据范围0-255，定义的时候超过这个范围会编译报错</p>
</li>
<li>
<p>rune：等价于int32，数据范围-2147483648-2147483647</p>
<ul>
<li>字符串里的每一个字符的类型就是rune类型，或者说int32类型</li>
</ul>
</li>
<li>
<p>uint：在32位机器上等价于uint32，在64位机器上等价于uint64</p>
</li>
<li>
<p>uintptr: 无符号整数，是内存地址的十进制整数表示形式，应用代码一般用不到（<a href="https://stackoverflow.com/questions/59042646/whats-the-difference-between-uint-and-uintptr-in-golang%EF%BC%89">https://stackoverflow.com/questions/59042646/whats-the-difference-between-uint-and-uintptr-in-golang）</a></p>
</li>
<li>
<p>reflect包的<code>TypeOf</code>函数或者<code>fmt.Printf</code>的<code>%T</code>可以用来获取变量的类型</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="type">byte</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">fmt.Println(reflect.TypeOf(b)) <span class="comment">// uint8</span></span><br><span class="line">fmt.Println(reflect.TypeOf(c)) <span class="comment">// int32</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, c) <span class="comment">// int32</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h2>
<ul>
<li>
<p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">type_name(expression)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    total_weight := <span class="number">100</span></span><br><span class="line">    num := <span class="number">12</span></span><br><span class="line">    <span class="comment">// total_weight和num都是整数，相除结果还是整数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;average=&quot;</span>, total_weight/num) <span class="comment">//  average= 8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转成float32再相除，结果就是准确值了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;average=&quot;</span>, <span class="type">float32</span>(total_weight)/<span class="type">float32</span>(num)) <span class="comment">// average= 8.333333</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 注意，float32只能和float32做运算，否则会报错，比如下例里float32和int相加，编译报错:</span></span><br><span class="line"><span class="comment">    invalid operation: float32(total_weight) + num (mismatched types float32 and int)</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">    res := float32(total_weight) + num</span></span><br><span class="line"><span class="comment">    fmt.Println(res)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：Go不支持隐式类型转换，要做数据类型转换必须按照type_name(expression)方式做显式的类型转换</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> f <span class="type">float32</span> = <span class="type">float32</span>(num)</span><br><span class="line">    fmt.Println(f) <span class="comment">// 10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    不支持隐式类型转换，比如下例想隐式讲num这个int类型转换为float32就会编译报错:</span></span><br><span class="line"><span class="comment">     cannot use num (type int) as type float32 in assignment</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">    var f float32 = num</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2>
<ul>
<li><a href="https://gfw.go101.org/article/basic-types-and-value-literals.html">https://gfw.go101.org/article/basic-types-and-value-literals.html</a></li>
<li><a href="https://www.callicoder.com/golang-basic-types-operators-type-conversion/">https://www.callicoder.com/golang-basic-types-operators-type-conversion/</a></li>
<li><a href="https://yourbasic.org/golang/string-functions-reference-cheat-sheet/">https://yourbasic.org/golang/string-functions-reference-cheat-sheet/</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>04.Go中的变量</title>
    <url>/undefined/717b940e/</url>
    <content><![CDATA[<h1 id="变量定义"><a class="markdownIt-Anchor" href="#变量定义"></a> 变量定义</h1>
<h2 id="全局变量"><a class="markdownIt-Anchor" href="#全局变量"></a> 全局变量</h2>
<p>函数外定义的变量叫全局变量，以下是全局变量的定义方法。</p>
<ul>
<li>方法1</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span> = value</span><br></pre></td></tr></table></figure>
<ul>
<li>方法2：注意，全局变量如果采用这个方式定义，那不能在全局范围内赋值，只能在函数体内给这个全局变量赋值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span> <span class="comment">// value will be defaulted to 0, false, &quot;&quot; based on the type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果定义上面的全局变量，就不能紧接着在下一行通过name=value的方式对变量name做赋值，</span></span><br><span class="line"><span class="comment">比如name = 10，会编译报错：</span></span><br><span class="line"><span class="comment"> syntax error: non-declaration statement outside function body</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>方法3</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = value </span><br></pre></td></tr></table></figure>
<ul>
<li>方法4</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	v1 <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">	v2 <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	v5 <span class="type">int</span>   <span class="comment">// the value will be defaulted to 0</span></span><br><span class="line">	v6 <span class="type">bool</span>  <span class="comment">// the value will be defaulted to false</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	v3 = <span class="number">20</span></span><br><span class="line">	v4 = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>全局变量允许声明后不使用</strong>，编译不会报错。</li>
</ul>
<h2 id="局部变量"><a class="markdownIt-Anchor" href="#局部变量"></a> 局部变量</h2>
<p>函数内定义的变量叫局部变量。</p>
<ul>
<li>
<p>和全局变量的定义相比，多了以下定义方法</p>
<ul>
<li>方法5</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name := value</span><br></pre></td></tr></table></figure>
<ul>
<li>方法6<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span></span><br><span class="line">name = value</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>局部变量定义后必须要被使用，否则编译报错</strong>，报错内容为<code>declared but not used</code>。</p>
</li>
</ul>
<h2 id="多变量定义"><a class="markdownIt-Anchor" href="#多变量定义"></a> 多变量定义：</h2>
<p>一次声明和定义多个变量</p>
<ul>
<li>
<p>全局变量</p>
<ul>
<li>
<p>方法1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方法2</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c <span class="type">bool</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方法3</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;str&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>局部变量：和全局变量相比，多了以下定义方法</p>
<ul>
<li>
<p>方法4</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line">a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, d <span class="type">int</span></span><br><span class="line">c = <span class="number">10</span></span><br><span class="line">d = <span class="number">20</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方法5</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">a1, b1 := <span class="number">1</span>, <span class="string">&quot;str&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="变量类型及其零值"><a class="markdownIt-Anchor" href="#变量类型及其零值"></a> 变量类型及其零值</h2>
<ul>
<li>
<p>零值：英文叫<a href="https://go.dev/ref/spec#The_zero_value">zero vaue</a>，没有显式初始化的变量，Go编译器会给一个默认值，也叫零值。</p>
</li>
<li>
<p>数值：所有数值类型的零值都是0</p>
<ul>
<li>整数，零值是0。byte, rune, uintptr也是整数类型，所以零值也是0。</li>
<li>浮点数，零值是0</li>
<li>复数，零值是0+0i</li>
</ul>
</li>
<li>
<p>bool，零值是false</p>
</li>
<li>
<p>字符串，零值是空串&quot;&quot;</p>
</li>
<li>
<p>指针：var a *int，零值是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">num := <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> a * <span class="type">int</span> = &amp;num</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>切片：var a []int，零值是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">list := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125; <span class="comment">//size为6的数组，前面2个元素是1和2，后面的是默认值0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>map：var a map[string] int，零值是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dict := <span class="keyword">map</span>[<span class="type">string</span>] <span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数：var a func(string) int，零值是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">function := <span class="function"><span class="keyword">func</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line">result := function(<span class="string">&quot;hello fans&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;result=&quot;</span>, result)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>channel：var a chan int，通道channel，零值是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">chan</span> <span class="type">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接口：var a interface_type，接口interface，零值是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">  speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cat Cat)</span></span> speak() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;miao...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个接口变量a</span></span><br><span class="line"><span class="keyword">var</span> a Animal = Cat&#123;<span class="string">&quot;gaffe&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">a.speak() <span class="comment">// miao...</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>结构体:  var instance StructName，结构体里每个field的零值是对应field的类型的零值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">  radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 Circle</span><br><span class="line">c1.radius = <span class="number">10.00</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="变量作用域"><a class="markdownIt-Anchor" href="#变量作用域"></a> 变量作用域</h2>
<ul>
<li>
<p>局部变量</p>
<ul>
<li>函数内声明的变量，作用域只在函数体内。函数的参数和返回值也是局部变量</li>
</ul>
</li>
<li>
<p>全局变量</p>
<ul>
<li>
<p>函数外声明的变量，全局变量作用域可以在当前的整个包甚至外部包(被导出后)使用</p>
</li>
<li>
<p>全局变量和局部变量名称可以相同，但是函数内的局部变量会被优先考虑</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> g <span class="type">int</span> = <span class="number">20</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;g=&quot;</span>,g)	 <span class="comment">// g=20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>函数形参</p>
<ul>
<li>函数定义中的参数，作为函数的局部变量来使用</li>
</ul>
</li>
<li>
<p>花括号{}可以控制变量的作用域：和C++类似</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	&#123;</span><br><span class="line">		a := <span class="number">5</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;a=&quot;</span>, a) <span class="comment">// a=5</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;a=&quot;</span>, a) <span class="comment">// a=10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="references"><a class="markdownIt-Anchor" href="#references"></a> References</h2>
<ul>
<li><a href="https://go.dev/ref/spec#The_zero_value">https://go.dev/ref/spec#The_zero_value</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>05.Go中的常量</title>
    <url>/undefined/6c20ce37/</url>
    <content><![CDATA[<p>本文主要介绍Go中常量的定义方法和使用注意事项，包括常量的定义、iota的使用、常量的枚举等内容。</p>
<span id="more"></span>  
<h1 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h1>
<ul>
<li>
<p>常量定义的时候必须赋值，定义后值不能被修改</p>
</li>
<li>
<p>常量(包括全局常量和局部常量)可以定义后不使用，局部变量定义后必须使用，否则编译报错</p>
</li>
<li>
<p>常量可以用来定义枚举</p>
</li>
<li>
<p>iota，特殊常量，可以理解为const语句块里的行索引，值从0开始</p>
</li>
<li>
<p>常量的定义方法</p>
<ul>
<li>
<p>方法1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> b <span class="type">bool</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方法2</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>多个常量同时定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a, b <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>iota，特殊常量，可以理解为每个独立的const语句块里的行索引</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a <span class="type">int</span> = <span class="literal">iota</span> <span class="comment">// the value of a is 0</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="literal">iota</span> <span class="comment">// the value of b is still 0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义枚举方法1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  unknown = <span class="number">0</span></span><br><span class="line">  male = <span class="number">1</span></span><br><span class="line">  female = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义枚举方法2</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  unknown = <span class="literal">iota</span> <span class="comment">// the value of unknown is 0</span></span><br><span class="line">  male <span class="comment">// the value of male is 1</span></span><br><span class="line">  female <span class="comment">// the value of female is 2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  c1 = <span class="literal">iota</span> <span class="comment">// the value of c1 is 0</span></span><br><span class="line">  c2 = <span class="literal">iota</span> <span class="comment">// the value of c2 is 1</span></span><br><span class="line">  c3 = <span class="literal">iota</span> <span class="comment">// the value of c3 is 2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意事项</p>
<ul>
<li>iota的值是const语句块里的行索引，行索引从0开始</li>
<li>const语句块里，如果常量没赋值，那它的值和上面的保持一样，比如下面的例子里class2=0, class6=“abc”</li>
<li>某个常量赋值为iota后，紧随其后的常量如果没赋值，那后面常量的值是自动+1，比如下面的例子里，class3的值是iota，该行的行索引是2，所以class3=2， class4常量紧随其后没有赋值，那class4=class3+1=3</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	class1 = <span class="number">0</span></span><br><span class="line">	class2 <span class="comment">// class2 = 0</span></span><br><span class="line">	class3 = <span class="literal">iota</span>  <span class="comment">//iota is 2, so class3 = 2</span></span><br><span class="line">	class4 <span class="comment">// class4 = 3</span></span><br><span class="line">	class5 = <span class="string">&quot;abc&quot;</span> </span><br><span class="line">	class6 <span class="comment">// class6 = &quot;abc&quot;</span></span><br><span class="line">	class7 = <span class="literal">iota</span> <span class="comment">// class7 is 6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>01.Go环境配置</title>
    <url>/undefined/3c040810/</url>
    <content><![CDATA[<p>本文主要介绍如何在Linux系统下安装Go开发环境，以及如何配置VS Code开发工具。</p>
<span id="more"></span>  
<h2 id="go-安装"><a class="markdownIt-Anchor" href="#go-安装"></a> Go 安装</h2>
<p>下载地址：</p>
<ul>
<li>Go 官网下载地址：<a href="https://golang.org/dl/">https://golang.org/dl/</a></li>
<li>Go 官方镜像站（推荐）：<a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></li>
</ul>
<p><img src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokeimage-20240811192036599.png" alt="image-20240811192036599" />直接安装最新版本 go1.22.6，后续文章都会在此版本下开发，测试。</p>
<h3 id="linux-下安装"><a class="markdownIt-Anchor" href="#linux-下安装"></a> Linux 下安装</h3>
<p>下载安装包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://golang.google.cn/dl/go1.22.6.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压到 /usr/local 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo tar -zxvf go1.22.6.linux-amd64.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure>
<p>然后配置环境变量，打开 $HOME/.bash_profile 文件，增加下面两行代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/usr/local/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin</span><br></pre></td></tr></table></figure>
<p>最后使环境变量生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> <span class="variable">$HOME</span>/.bash_profile</span><br></pre></td></tr></table></figure>
<p>安装完成后，在终端执行查看版本命令，如果能正确输出版本信息，那就说明安装成功了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go version</span><br><span class="line">go version go1.22.6 linux/amd64</span><br></pre></td></tr></table></figure>
<h3 id="配置环境变量"><a class="markdownIt-Anchor" href="#配置环境变量"></a> 配置环境变量</h3>
<p><code>GOROOT</code> 和 <code>GOPATH</code> 都是环境变量，其中 <code>GOROOT</code> 是我们安装 Go 开发包的路径，<code>GOPATH</code> 会有一个默认目录。</p>
<p>由于 go1.11 之后使用 go mod 来管理依赖包，不再强制我们必须把代码写在 <code>GOPATH/src</code> 目录下，所以使用默认即可，无需修改。</p>
<p>默认 <code>GOPROXY</code> 配置是 <code>GOPROXY=https://proxy.golang.org,direct</code>，由于国内访问不到，所以我们需要换一个 PROXY，这里推荐使用：</p>
<ol>
<li><a href="https://goproxy.io">https://goproxy.io</a></li>
<li><a href="https://goproxy.cn">https://goproxy.cn</a></li>
</ol>
<p>配置 <code>GOPROXY</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GO111MODULE=on</span><br><span class="line">$ go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>
<p>go mod 先这样配置就可以了，后续再来写文章详细介绍。</p>
<h2 id="开发工具-vs-code"><a class="markdownIt-Anchor" href="#开发工具-vs-code"></a> 开发工具 VS Code</h2>
<p>开发工具可以根据自己的喜好来，可以用 Goland，VS Code，当然 Vim 也可以。</p>
<p>我比较喜欢 VS Code，插件丰富，而且免费。</p>
<p>官方下载地址：<a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></p>
<p>安装 Go 插件，并重启：</p>
<p><img src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokeimage-20240811192914982.png" alt="image-20240811192914982" /></p>
<h2 id="第一个-go-程序"><a class="markdownIt-Anchor" href="#第一个-go-程序"></a> 第一个 Go 程序</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">/ <span class="number">00</span>_hello.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main  <span class="comment">// 声明 main 包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  <span class="comment">// 导入内置 fmt 包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;  <span class="comment">// main函数，程序执行入口</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World!&quot;</span>)  <span class="comment">// 在终端打印 Hello World!</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>go build</code> 命令编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build 00_hello.go</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">00_hello  00_hello.go go.mod</span><br></pre></td></tr></table></figure>
<p>可以看到在目录下生成了可执行文件 <code>00_hello</code>，然后运行一下试试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./00_hello</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<p>还可以直接使用 <code>go run</code> 命令来执行代码，在调试的时候更加方便。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run 00_hello.go</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Golang</category>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>程序开发的开闭原则</title>
    <url>/undefined/f0115136/</url>
    <content><![CDATA[<h1 id="什么是开闭原则"><a class="markdownIt-Anchor" href="#什么是开闭原则"></a> 什么是开闭原则</h1>
<p>GPT的解释如下：</p>
<blockquote>
<p>开闭原则是面向对象设计中的一个重要原则，指的是软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着一个软件实体应该通过扩展来实现新功能，而不是通过修改已有的代码来实现。这样做可以保持原有代码的稳定性，降低修改代码引入错误的风险，并且更容易维护和扩展软件系统。<br />
在程序开发中，遵循开闭原则可以通过以下方式实现：<br />
使用接口和抽象类定义可扩展的接口，通过实现接口或继承抽象类来新增功能，而不是修改原有代码。<br />
使用设计模式如策略模式、装饰器模式等来实现可插拔的功能，而不是直接修改现有代码。<br />
使用配置文件、扩展点等机制来实现功能的动态配置和扩展。<br />
避免硬编码具体实现，使用依赖注入等方式来实现松耦合，方便替换和扩展功能。</p>
</blockquote>
<p>简单而言开闭原则是软件功能的扩展尽可能通过外部模块进行而不是修改原来功能的源代码。</p>
<span id="more"></span>  
<h1 id="开闭原则的实现方法"><a class="markdownIt-Anchor" href="#开闭原则的实现方法"></a> 开闭原则的实现方法</h1>
<h2 id="策略模式工厂模式模板模式的混合模式方案"><a class="markdownIt-Anchor" href="#策略模式工厂模式模板模式的混合模式方案"></a> 策略模式+工厂模式+模板模式的混合模式方案</h2>
<p>参考下面这个视频</p>
<iframe src="//player.bilibili.com/player.html?aid=456530918&bvid=BV1b5411a7oa&cid=220746663&p=1&autoplay=false&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="720"> </iframe>
<p>其中的关键是策略模式，通过使用策略的方式对不同的业务逻辑进行模块化开发，然后使用工厂模式调用策略实现核心代码的一致性，进一步为了实现策略方法的可复用，使用模板模式进行进一步的封装。</p>
<h2 id="搭架子和串珠子"><a class="markdownIt-Anchor" href="#搭架子和串珠子"></a> 搭架子和串珠子</h2>
<iframe src="//player.bilibili.com/player.html?aid=403664982&bvid=BV1bV411K7Z2&cid=1203166154&autoplay=false&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="720"> </iframe>
<p>使用模板编程(类似于python中的装饰器功能)封装业务流，最后使用流程业务将不同的<code>&quot;珠子&quot;</code>串起来，开发框架的中间件和过滤器通常就使用这样的开发方式</p>
]]></content>
      <tags>
        <tag>后端修炼的葵花宝典</tag>
      </tags>
  </entry>
</search>
