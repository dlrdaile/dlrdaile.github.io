<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ROS2常用代码段</title>
    <url>/undefined/77c9402a/</url>
    <content><![CDATA[<p>这篇文章整理了ROS2开发过程中常用的代码段，包括ament_cmake编写、话题相关、服务相关等，主要内容翻译自官方教程。
<span id="more"></span></p>
<h1 id="ros2常用代码段">ROS2常用代码段</h1>
<h2 id="ament_cmake编写">ament_cmake编写</h2>
<h3 id="创建功能包">创建功能包</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ros2 pkg create pkg_name --build-type ament_cmake</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处可以不写<code>--build-type</code>,指令默认创建的便是<code>ament_camke</code></p>
</blockquote>
<h3 id="一般的编写方法">一般的编写方法</h3>
<h4 id="库编写">库编写</h4>
<h5 id="添加库">添加库</h5>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加源文件，生成库</span></span><br><span class="line"><span class="keyword">add_library</span>(my_math_lib SHARED</span><br><span class="line">        <span class="keyword">include</span>/my_math_lib/my_math_lib.hpp</span><br><span class="line">        src/my_math_lib.cpp</span><br><span class="line">        )</span><br><span class="line"><span class="comment"># 添加头文件地址</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(my_math_lib PUBLIC</span><br><span class="line">        $&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>&gt;</span><br><span class="line">        $&lt;INSTALL_INTERFACE:<span class="keyword">include</span>&gt;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<h5 id="链接依赖">链接依赖</h5>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用于代替传统的target_link_libraries</span></span><br><span class="line">ament_target_dependencies(my_math_lib</span><br><span class="line">        PUBLIC</span><br><span class="line">        rclcpp</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<h5 id="导出依赖">导出依赖</h5>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为了使下游文件可以访问</span></span><br><span class="line">ament_export_targets(my_math_lib HAS_LIBRARY_TARGET)</span><br><span class="line">ament_export_dependencies(</span><br><span class="line">        rclcpp</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册 导出头文件</span></span><br><span class="line"><span class="keyword">install</span>(</span><br><span class="line">        DIRECTORY <span class="keyword">include</span>/</span><br><span class="line">        DESTINATION <span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册 导出库文件</span></span><br><span class="line"><span class="keyword">install</span>(</span><br><span class="line">        TARGETS my_math_lib <span class="comment"># 告诉ros2有这么个目标（可执行文件或者库）</span></span><br><span class="line">        <span class="keyword">EXPORT</span> my_math_lib</span><br><span class="line">        ARCHIVE DESTINATION lib</span><br><span class="line">        LIBRARY DESTINATION lib</span><br><span class="line">        RUNTIME DESTINATION bin</span><br><span class="line">        INCLUDES DESTINATION <span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line">ament_package()</span><br></pre></td></tr></table></figure>
<h5 id="package.xml">package.xml</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">format</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>my_math_lib<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>my_math_lib<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;renyunfan@outlook.com&quot;</span>&gt;</span>Yunfan Ren<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">license</span>&gt;</span>BSD<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">export</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">build_type</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">build_type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="使用自定义的库">使用自定义的库</h4>
<h5 id="查找库">查找库</h5>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(my_math_lib REQUIRED)</span><br></pre></td></tr></table></figure>
<h5 id="生成可执行文件">生成可执行文件</h5>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找依赖文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(complex_test</span><br><span class="line">        src/complex_test.cpp</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<h5 id="链接库">链接库</h5>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">ament_target_dependencies(complex_test</span><br><span class="line">        my_math_lib</span><br><span class="line">        rclcpp</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<h5 id="安装可执行文件">安装可执行文件</h5>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS complex_test</span><br><span class="line">        DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br></pre></td></tr></table></figure>
<h5 id="package.xml-1">package.xml</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">format</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>my_math_lib<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>my_math_lib<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;renyunfan@outlook.com&quot;</span>&gt;</span>Yunfan Ren<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">license</span>&gt;</span>BSD<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">depend</span>&gt;</span>my_math_lib<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">export</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">build_type</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">build_type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用ament_cmake_auto简化">使用ament_cmake_auto简化</h3>
<h4 id="库编写-1">库编写</h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span> (ament_cmake_auto REQUIRED) </span><br><span class="line">ament_auto_find_build_dependencies ()</span><br><span class="line"></span><br><span class="line">ament_auto_add_library ( my_lib SHARED </span><br><span class="line">    src/example.cpp </span><br><span class="line">    <span class="keyword">include</span>/example.hpp)</span><br><span class="line"></span><br><span class="line">ament_auto_package ()</span><br></pre></td></tr></table></figure>
<h4 id="ament_cmake_auto的一些宏接口">ament_cmake_auto的一些宏接口</h4>
<h5 id="section">*</h5>
<p>*<a
href="https://link.zhihu.com/?target=https%3A//github.com/ament/ament_cmake/blob/master/ament_cmake_auto/cmake/ament_auto_add_executable.cmake">ament_auto_add_executable</a>
**</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 相当于</span></span><br><span class="line"><span class="keyword">add_executable</span>()</span><br><span class="line"><span class="keyword">target_include_directories</span>()</span><br><span class="line"><span class="keyword">target_link_libraries</span>()</span><br></pre></td></tr></table></figure>
<h5 id="section-1">*</h5>
<p>*<a
href="https://link.zhihu.com/?target=https%3A//github.com/ament/ament_cmake/blob/master/ament_cmake_auto/cmake/ament_auto_add_library.cmake">ament_auto_add_library</a>
**</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 相当于</span></span><br><span class="line"><span class="keyword">add_library</span>()</span><br><span class="line"><span class="keyword">target_include_directories</span>()</span><br><span class="line"><span class="keyword">target_link_libraries</span>()</span><br></pre></td></tr></table></figure>
<h5 id="ament_auto_find_build_dependencies"><a
href="https://link.zhihu.com/?target=https%3A//github.com/ament/ament_cmake/blob/master/ament_cmake_auto/cmake/ament_auto_find_build_dependencies.cmake">ament_auto_find_build_dependencies</a></h5>
<blockquote>
<p>他会自动将xml中填写了的依赖给连接上，相当于不用写find_package了。</p>
</blockquote>
<h5 id="ament_auto_package"><a
href="https://link.zhihu.com/?target=https%3A//github.com/ament/ament_cmake/blob/master/ament_cmake_auto/cmake/ament_auto_package.cmake">ament_auto_package</a></h5>
<blockquote>
<p>这个用来代替以前的export和两次install，以及最后的ament_package。</p>
</blockquote>
<h5 id="section-2">*</h5>
<p>*<a
href="https://link.zhihu.com/?target=https%3A//github.com/ament/ament_cmake/blob/master/ament_cmake_auto/cmake/ament_auto_generate_code.cmake">ament_auto_generate_code</a>
**</p>
<blockquote>
<p>看起来是个很诱人的宏，感觉像是生成cfg和msg、srv之类的，不过点进去看源码，<strong>应该是还没实现</strong>。</p>
</blockquote>
<h3
id="使用ament_cmake_python集成cpp和python">使用ament_cmake_python集成cpp和python</h3>
<h4 id="配置package.xml">配置package.xml</h4>
<blockquote>
<ul>
<li>增加<code>&lt;buildtool_depend&gt;ament_cmake_python&lt;/buildtool_depend&gt;</code>行和<code>rclpy</code>，支持python使用。</li>
<li>注意：在标准的 Python 包中，你应该有 ament_python，而不是
ament_cmake_python。 确保不要混合使用这 2 个。</li>
<li>使用 ament_cmake_python 意味着我们将能够使用 cmake 设置我们的 Python
内容。</li>
</ul>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-model href=<span class="string">&quot;http://download.ros.org/schema/package_format3.xsd&quot;</span> schematypens=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">format</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>my_cpp_py_pkg<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>TODO: Package description<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;your@email.com&quot;</span>&gt;</span>Name<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">license</span>&gt;</span>TODO: License declaration<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>ament_cmake_python<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">depend</span>&gt;</span>rclcpp<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">depend</span>&gt;</span>rclpy<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>ament_lint_auto<span class="tag">&lt;/<span class="name">test_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>ament_lint_common<span class="tag">&lt;/<span class="name">test_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">export</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">build_type</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">build_type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="配置cmakelists.txt">配置CMakeLists.txt</h4>
<h5 id="依赖部分">依赖部分</h5>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Find dependencies</span></span><br><span class="line"><span class="keyword">find_package</span>(ament_cmake REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(ament_cmake_python REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(rclcpp REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(rclpy REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(std_msgs REQUIRED)</span><br></pre></td></tr></table></figure>
<h5 id="cpp部分">CPP部分</h5>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Include Cpp &quot;include&quot; directory</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create Cpp executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(cpp_talker src/cpp_talker.cpp)</span><br><span class="line">ament_target_dependencies(cpp_talker rclcpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install Cpp executables</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS</span><br><span class="line">  cpp_talker </span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="python部分">python部分</h5>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Install Python modules</span></span><br><span class="line">ament_python_install_package(<span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install Python executables</span></span><br><span class="line"><span class="keyword">install</span>(PROGRAMS</span><br><span class="line">  scripts/py_listener.py</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="相关api">相关API</h4>
<h5 id="ament_get_python_install_dir">ament_get_python_install_dir</h5>
<blockquote>
<p>The CMake</p>
<p>function <a
href="https://github.com/ament/ament_cmake/blob/master/ament_cmake_python/cmake/ament_get_python_install_dir.cmake"><code>ament_get_python_install_dir</code></a>
gets the path Python packages will be installed to. The path is always
relative to <code>CMAKE_INSTALL_PREFIX</code>.</p>
<p>The path can be customized by setting <code>PYTHON_INSTALL_DIR</code>
on the command line. It must be a relative path. For example, the cmake
command bellow would cause Python code to be installed to
<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/foobar/site-packages</code>.</p>
</blockquote>
<h5 id="ament_python_install_module">ament_python_install_module</h5>
<blockquote>
<p>The CMake</p>
<p>macro <a
href="https://github.com/ament/ament_cmake/blob/master/ament_cmake_python/cmake/ament_python_install_module.cmake"><code>ament_python_install_module</code></a>
will install a single Python module to the Python install directory.</p>
</blockquote>
<h5 id="ament_python_install_package">ament_python_install_package</h5>
<blockquote>
<p>The CMake</p>
<p>macro <a
href="https://github.com/ament/ament_cmake/blob/master/ament_cmake_python/cmake/ament_python_install_package.cmake"><code>ament_python_install_package</code></a>
will install a Python package and all subpackages to the Python install
directory.</p>
</blockquote>
<h3 id="简单示例的完整体">简单示例的完整体</h3>
<h4 id="目录结构">目录结构</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">└── test_cpp_python</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── include</span><br><span class="line">    │   └── test_cpp_python</span><br><span class="line">    ├── package.xml</span><br><span class="line">    ├── scripts</span><br><span class="line">    │   └── li4.py</span><br><span class="line">    └── src</span><br><span class="line">        └── wang2.cpp</span><br></pre></td></tr></table></figure>
<h4 id="cmakelists.txt">CMakeLists.txt</h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.8</span>)</span><br><span class="line"><span class="keyword">project</span>(test_cpp_python)</span><br><span class="line"></span><br><span class="line"><span class="comment"># find dependencies</span></span><br><span class="line"><span class="keyword">find_package</span>(ament_cmake_auto REQUIRED)</span><br><span class="line">ament_auto_find_build_dependencies()</span><br><span class="line"></span><br><span class="line">ament_auto_add_executable(wang src/wang2.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install Python executables</span></span><br><span class="line"><span class="keyword">install</span>(PROGRAMS</span><br><span class="line">  scripts/li4.py</span><br><span class="line">  DESTINATION lib/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br><span class="line">ament_auto_package()</span><br></pre></td></tr></table></figure>
<h4 id="package.xml-2">package.xml</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-model href=<span class="string">&quot;http://download.ros.org/schema/package_format3.xsd&quot;</span> schematypens=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">format</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>test_cpp_python<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>TODO: Package description<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;dllr@todo.todo&quot;</span>&gt;</span>dllr<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">license</span>&gt;</span>TODO: License declaration<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>ament_cmake_auto<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>ament_cmake_python<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">depend</span>&gt;</span>rclcpp<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">depend</span>&gt;</span>rclpy<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>ament_lint_auto<span class="tag">&lt;/<span class="name">test_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>ament_lint_common<span class="tag">&lt;/<span class="name">test_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">export</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">build_type</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">build_type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="scriptsli4.py">scripts/li4.py</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">123123</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，py文件中一定要记得添加第一行，否则会报错</p>
</blockquote>
<h2 id="ament_python的编写方法">ament_python的编写方法</h2>
<h3 id="创建功能包-1">创建功能包</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ros2 pkg create pkg_name --build-type ament_python</span><br></pre></td></tr></table></figure>
<h3 id="编写节点文件">编写节点文件</h3>
<p>在<code>pkg_name/pkg_name</code>下创建<code>xxx.py</code>文件，该目录下会自动生成一个<code>__init__.py</code>文件，说明这个目录下是一个python包</p>
<h3
id="在package.xml中补充运行时依赖">在<code>package.xml</code>中补充运行时依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rclpy<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常写在<code>exec_depend</code>标签下即可，因为无需python<code>build</code></p>
</blockquote>
<h3 id="添加节点入口">添加节点入口</h3>
<p>打开 <code>setup.py</code> ，Add the following line within the
<code>console_scripts</code> brackets of the <code>entry_points</code>
field:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry_points=&#123;</span><br><span class="line">        &#x27;console_scripts&#x27;: [</span><br><span class="line">                &#x27;talker = py_pubsub.publisher_member_function:main&#x27;,</span><br><span class="line">        ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<blockquote>
<p>记得保存文件</p>
</blockquote>
<h3 id="检查setup.cfg">检查<code>setup.cfg</code></h3>
<p><code>setup.cfg</code>的文件内容应该会自动生成，如下文所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[develop]</span><br><span class="line">script_dir=$base/lib/py_pubsub</span><br><span class="line">[install]</span><br><span class="line">install_scripts=$base/lib/py_pubsub</span><br></pre></td></tr></table></figure>
<p>这个仅仅是告诉构建工具<code>setuptools</code>把你的可执行文件放到install/lib目录下(该目录为ros2
run找寻可执行库的路径)。</p>
<p>接下来可以调用<code>colcon build</code>进行下载了，如果加上<code>--symlink-install</code>
参数，则修改python文件后无需重复编译，其原理是仅仅将python的软链接映射到<code>install/lib</code>目录下。</p>
<h2 id="话题相关">话题相关</h2>
<blockquote>
<p>全部采用面向对象的思想</p>
</blockquote>
<h3 id="开发流程">开发流程</h3>
<ol type="1">
<li>导入包</li>
<li>初始化工作空间</li>
<li>创建节点对象</li>
<li>调用spin方法</li>
<li>关闭节点进程</li>
</ol>
<h3 id="cpp">CPP</h3>
<h4 id="发布者">发布者</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This example creates a subclass of Node and uses std::bind() to register a</span></span><br><span class="line"><span class="comment">* member function as a callback from the timer. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinimalPublisher</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinimalPublisher</span>()</span><br><span class="line">    : <span class="built_in">Node</span>(<span class="string">&quot;minimal_publisher&quot;</span>), <span class="built_in">count_</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      publisher_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;std_msgs::msg::String&gt;(<span class="string">&quot;topic&quot;</span>, <span class="number">10</span>);</span><br><span class="line">      timer_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(</span><br><span class="line">      <span class="number">500</span>ms, std::<span class="built_in">bind</span>(&amp;MinimalPublisher::timer_callback, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">timer_callback</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">auto</span> message = std_msgs::msg::<span class="built_in">String</span>();</span><br><span class="line">      message.data = <span class="string">&quot;Hello, world! &quot;</span> + std::<span class="built_in">to_string</span>(count_++);</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Publishing: &#x27;%s&#x27;&quot;</span>, message.data.<span class="built_in">c_str</span>());</span><br><span class="line">      publisher_-&gt;<span class="built_in">publish</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line">    rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr publisher_;</span><br><span class="line">    <span class="type">size_t</span> count_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;MinimalPublisher&gt;());</span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关键函数是</p>
<ul>
<li><code>rclcpp::Publisher&lt;std_msgs::msg::String&gt;::SharedPtr publisher_;</code></li>
<li><code>publisher_ = this-&gt;create_publisher&lt;std_msgs::msg::String&gt;("topic", 10);</code></li>
</ul>
</blockquote>
<h4 id="订阅者">订阅者</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/msg/string.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/time.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinimalSubscriber</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MinimalSubscriber</span>()</span><br><span class="line">  : <span class="built_in">Node</span>(<span class="string">&quot;minimal_subscriber&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    subscription_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_subscription</span>&lt;std_msgs::msg::String&gt;(</span><br><span class="line">      <span class="string">&quot;topic&quot;</span>, <span class="number">10</span>, std::<span class="built_in">bind</span>(&amp;MinimalSubscriber::topic_callback, <span class="keyword">this</span>, _1));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">topic_callback</span><span class="params">(<span class="type">const</span> std_msgs::msg::String &amp; msg)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;I heard: &#x27;%s&#x27;&quot;</span>, msg.data.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr subscription_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;MinimalSubscriber&gt;());</span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关键代码：</p>
<ul>
<li><code>rclcpp::Subscription&lt;std_msgs::msg::String&gt;::SharedPtr subscription_;</code></li>
<li>`subscription_ =
this-&gt;create_subscription<std_msgs::msg::String>(</li>
</ul>
</blockquote>
<pre><code>&gt; &quot;topic&quot;, 10, std::bind(&amp;MinimalSubscriber::topic_callback, this, _1));`</code></pre>
<h3 id="python">Python</h3>
<h4 id="发布者-1">发布者</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinimalPublisher</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&#x27;minimal_publisher&#x27;</span>)</span><br><span class="line">        self.publisher_ = self.create_publisher(String, <span class="string">&#x27;topic&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">        timer_period = <span class="number">0.5</span>  <span class="comment"># seconds</span></span><br><span class="line">        self.timer = self.create_timer(timer_period, self.timer_callback)</span><br><span class="line">        self.i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">timer_callback</span>(<span class="params">self</span>):</span><br><span class="line">        msg = String()</span><br><span class="line">        msg.data = <span class="string">&#x27;Hello World: %d&#x27;</span> % self.i</span><br><span class="line">        self.publisher_.publish(msg)</span><br><span class="line">        self.get_logger().info(<span class="string">&#x27;Publishing: &quot;%s&quot;&#x27;</span> % msg.data)</span><br><span class="line">        self.i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):</span><br><span class="line">    rclpy.init(args=args)</span><br><span class="line"></span><br><span class="line">    minimal_publisher = MinimalPublisher()</span><br><span class="line"></span><br><span class="line">    rclpy.spin(minimal_publisher)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Destroy the node explicitly</span></span><br><span class="line">    <span class="comment"># (optional - otherwise it will be done automatically</span></span><br><span class="line">    <span class="comment"># when the garbage collector destroys the node object)</span></span><br><span class="line">    minimal_publisher.destroy_node()</span><br><span class="line">    rclpy.shutdown()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h4 id="订阅者-1">订阅者</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinimalSubscriber</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&#x27;minimal_subscriber&#x27;</span>)</span><br><span class="line">        self.subscription = self.create_subscription(</span><br><span class="line">            String,</span><br><span class="line">            <span class="string">&#x27;topic&#x27;</span>,</span><br><span class="line">            self.listener_callback,</span><br><span class="line">            <span class="number">10</span>)</span><br><span class="line">        self.subscription  <span class="comment"># prevent unused variable warning</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">listener_callback</span>(<span class="params">self, msg</span>):</span><br><span class="line">        self.get_logger().info(<span class="string">&#x27;I heard: &quot;%s&quot;&#x27;</span> % msg.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):</span><br><span class="line">    rclpy.init(args=args)</span><br><span class="line"></span><br><span class="line">    minimal_subscriber = MinimalSubscriber()</span><br><span class="line"></span><br><span class="line">    rclpy.spin(minimal_subscriber)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Destroy the node explicitly</span></span><br><span class="line">    <span class="comment"># (optional - otherwise it will be done automatically</span></span><br><span class="line">    <span class="comment"># when the garbage collector destroys the node object)</span></span><br><span class="line">    minimal_subscriber.destroy_node()</span><br><span class="line">    rclpy.shutdown()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="服务相关">服务相关</h2>
<h3 id="代码编写流程">代码编写流程</h3>
<h4 id="服务端流程">服务端流程</h4>
<ol type="1">
<li>导入服务接口</li>
<li>创建服务端回调函数</li>
<li>声明并创建服务端</li>
<li>编写回调函数逻辑处理请求</li>
</ol>
<h4 id="客户端流程">客户端流程</h4>
<ol type="1">
<li>导入服务接口</li>
<li>创建请求结果接收回调函数</li>
<li>声明并创建客户端</li>
<li>编写结果接收逻辑</li>
<li>调用客户端发送请求</li>
</ol>
<h3
id="cpp这里使用了面向过程的编写方式">CPP(这里使用了面向过程的编写方式)</h3>
<h4 id="服务端">服务端</h4>
<p><strong>面向过程的写法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example_interfaces/srv/add_two_ints.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;example_interfaces::srv::AddTwoInts::Request&gt; request,</span></span></span><br><span class="line"><span class="params"><span class="function">         std::shared_ptr&lt;example_interfaces::srv::AddTwoInts::Response&gt; response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    response-&gt;sum = request-&gt;a + request-&gt;b;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;Incoming request\na: %ld&quot;</span></span><br><span class="line">                                              <span class="string">&quot; b: %ld&quot;</span>,</span><br><span class="line">                request-&gt;a, request-&gt;b);</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;sending back response: [%ld]&quot;</span>, (<span class="type">long</span> <span class="type">int</span>)response-&gt;sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化库环境</span></span><br><span class="line">    rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">    <span class="comment">// 创建节点头(这里使用的了智能指针的方式创建)</span></span><br><span class="line">    std::shared_ptr&lt;rclcpp::Node&gt; node = rclcpp::Node::<span class="built_in">make_shared</span>(<span class="string">&quot;add_two_ints_server&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建服务器对象的指针</span></span><br><span class="line">    rclcpp::Service&lt;example_interfaces::srv::AddTwoInts&gt;::SharedPtr service =</span><br><span class="line">        node-&gt;<span class="built_in">create_service</span>&lt;example_interfaces::srv::AddTwoInts&gt;(<span class="string">&quot;add_two_ints&quot;</span>, &amp;add);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;Ready to add two ints.&quot;</span>);</span><br><span class="line">    <span class="comment">// 调度对象</span></span><br><span class="line">    rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line">    <span class="comment">// 关闭节点</span></span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>面向对象的写法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example_interfaces/srv/add_two_ints.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> std::placeholders::_2;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServiceDemoNode</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ServiceDemoNode</span>() : <span class="built_in">Node</span>(<span class="string">&quot;service_node&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_service = <span class="keyword">this</span>-&gt;<span class="built_in">create_service</span>&lt;example_interfaces::srv::AddTwoInts&gt;(<span class="string">&quot;add_two_ints&quot;</span>,</span><br><span class="line">                                                                                   std::<span class="built_in">bind</span>(&amp;ServiceDemoNode::add_two_ints,</span><br><span class="line">                                                                                             <span class="keyword">this</span>, _1, _2));</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Ready to add two ints.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_two_ints</span><span class="params">(std::shared_ptr&lt;example_interfaces::srv::AddTwoInts::Request&gt; request,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::shared_ptr&lt;example_interfaces::srv::AddTwoInts::Response&gt; response)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        response-&gt;sum = request-&gt;a + request-&gt;b;</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Incoming request\na: %ld&quot;</span></span><br><span class="line">                                        <span class="string">&quot; b: %ld&quot;</span>,</span><br><span class="line">                    request-&gt;a, request-&gt;b);</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;sending back response: [%ld]&quot;</span>, (<span class="type">long</span> <span class="type">int</span>)response-&gt;sum);</span><br><span class="line">    &#125;</span><br><span class="line">    rclcpp::Service&lt;example_interfaces::srv::AddTwoInts&gt;::SharedPtr _service;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;ServiceDemoNode&gt;());</span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>核心代码：</p>
<ul>
<li><strong>创建服务器对象</strong></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rclcpp::Service&lt;example_interfaces::srv::AddTwoInts&gt;::SharedPtr service =</span><br><span class="line">node-&gt;<span class="built_in">create_service</span>&lt;example_interfaces::srv::AddTwoInts&gt;(<span class="string">&quot;add_two_ints&quot;</span>, &amp;add);</span><br></pre></td></tr></table></figure></code></pre>
<blockquote>
<ul>
<li><strong>定义服务响应函数</strong></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;example_interfaces::srv::AddTwoInts::Request&gt; request,</span></span></span><br><span class="line"><span class="params"><span class="function">std::shared_ptr&lt;example_interfaces::srv::AddTwoInts::Response&gt; response)</span></span>;</span><br></pre></td></tr></table></figure></code></pre>
<blockquote>

</blockquote>
<h4 id="客户端">客户端</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example_interfaces/srv/add_two_ints.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;usage: add_two_ints_client X Y&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;rclcpp::Node&gt; node = rclcpp::Node::<span class="built_in">make_shared</span>(<span class="string">&quot;add_two_ints_client&quot;</span>);</span><br><span class="line">  rclcpp::Client&lt;example_interfaces::srv::AddTwoInts&gt;::SharedPtr client =</span><br><span class="line">    node-&gt;<span class="built_in">create_client</span>&lt;example_interfaces::srv::AddTwoInts&gt;(<span class="string">&quot;add_two_ints&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> request = std::<span class="built_in">make_shared</span>&lt;example_interfaces::srv::AddTwoInts::Request&gt;();</span><br><span class="line">  request-&gt;a = <span class="built_in">atoll</span>(argv[<span class="number">1</span>]);</span><br><span class="line">  request-&gt;b = <span class="built_in">atoll</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!client-&gt;<span class="built_in">wait_for_service</span>(<span class="number">1</span>s)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!rclcpp::<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">RCLCPP_ERROR</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;Interrupted while waiting for the service. Exiting.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;service not available, waiting again...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> result = client-&gt;<span class="built_in">async_send_request</span>(request);</span><br><span class="line">  <span class="comment">// Wait for the result.</span></span><br><span class="line">  <span class="keyword">if</span> (rclcpp::<span class="built_in">spin_until_future_complete</span>(node, result) ==</span><br><span class="line">    rclcpp::FutureReturnCode::SUCCESS)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;Sum: %ld&quot;</span>, result.<span class="built_in">get</span>()-&gt;sum);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">RCLCPP_ERROR</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;Failed to call service add_two_ints&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>核心代码：</p>
<ul>
<li><strong>创建客户端对象</strong></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rclcpp::Client&lt;example_interfaces::srv::AddTwoInts&gt;::SharedPtr client =</span><br><span class="line">node-&gt;<span class="built_in">create_client</span>&lt;example_interfaces::srv::AddTwoInts&gt;(<span class="string">&quot;add_two_ints&quot;</span>);</span><br></pre></td></tr></table></figure></code></pre>
<blockquote>
<ul>
<li><strong>定义请求数据结构</strong></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> request = std::<span class="built_in">make_shared</span>&lt;example_interfaces::srv::AddTwoInts::Request&gt;();</span><br></pre></td></tr></table></figure></code></pre>
<blockquote>
<ul>
<li><p><strong>等待服务器响应</strong>：<code>client-&gt;wait_for_service(1s)</code></p></li>
<li><p><strong>发送请求并进行处理</strong></p></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = client-&gt;<span class="built_in">async_send_request</span>(request);</span><br><span class="line"><span class="comment">// Wait for the result.</span></span><br><span class="line"><span class="keyword">if</span> (rclcpp::<span class="built_in">spin_until_future_complete</span>(node, result) ==</span><br><span class="line">rclcpp::FutureReturnCode::SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">RCLCPP_INFO</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;Sum: %ld&quot;</span>, result.<span class="built_in">get</span>()-&gt;sum);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">RCLCPP_ERROR</span>(rclcpp::<span class="built_in">get_logger</span>(<span class="string">&quot;rclcpp&quot;</span>), <span class="string">&quot;Failed to call service add_two_ints&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<h3 id="python-1">Python</h3>
<h4 id="服务端-1">服务端</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> example_interfaces.srv <span class="keyword">import</span> AddTwoInts</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinimalService</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&#x27;minimal_service&#x27;</span>)</span><br><span class="line">        self.srv = self.create_service(</span><br><span class="line">            AddTwoInts, <span class="string">&#x27;add_two_ints&#x27;</span>, self.add_two_ints_callback)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_two_ints_callback</span>(<span class="params">self, request, response</span>):</span><br><span class="line">        response.<span class="built_in">sum</span> = request.a + request.b</span><br><span class="line">        self.get_logger().info(<span class="string">&#x27;Incoming request\na: %d b: %d&#x27;</span> % (request.a, request.b))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    rclpy.init()</span><br><span class="line"></span><br><span class="line">    minimal_service = MinimalService()</span><br><span class="line"></span><br><span class="line">    rclpy.spin(minimal_service)</span><br><span class="line"></span><br><span class="line">    rclpy.shutdown()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>核心代码：</p>
<ul>
<li>```python self.srv = self.create_service( AddTwoInts,
'add_two_ints', self.add_two_ints_callback) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 客户端</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">from example_interfaces.srv import AddTwoInts</span><br><span class="line">import rclpy</span><br><span class="line">from rclpy.node import Node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MinimalClientAsync(Node):</span><br><span class="line"></span><br><span class="line">   def __init__(self):</span><br><span class="line">       super().__init__(&#x27;minimal_client_async&#x27;)</span><br><span class="line">       self.cli = self.create_client(AddTwoInts, &#x27;add_two_ints&#x27;)</span><br><span class="line">       while not self.cli.wait_for_service(timeout_sec=1.0):</span><br><span class="line">           self.get_logger().info(&#x27;service not available, waiting again...&#x27;)</span><br><span class="line">       self.req = AddTwoInts.Request()</span><br><span class="line"></span><br><span class="line">   def send_request(self, a, b):</span><br><span class="line">       self.req.a = a</span><br><span class="line">       self.req.b = b</span><br><span class="line">       self.future = self.cli.call_async(self.req)</span><br><span class="line">       rclpy.spin_until_future_complete(self, self.future)</span><br><span class="line">       return self.future.result()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">   rclpy.init()</span><br><span class="line"></span><br><span class="line">   minimal_client = MinimalClientAsync()</span><br><span class="line">   response = minimal_client.send_request(int(sys.argv[1]), int(sys.argv[2]))</span><br><span class="line">   minimal_client.get_logger().info(</span><br><span class="line">       &#x27;Result of add_two_ints: for %d + %d = %d&#x27; %</span><br><span class="line">       (int(sys.argv[1]), int(sys.argv[2]), response.sum))</span><br><span class="line"></span><br><span class="line">   minimal_client.destroy_node()</span><br><span class="line">   rclpy.shutdown()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">   main()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<blockquote>
<p>核心代码：</p>
<ul>
<li><strong>创建客户端对象</strong></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;</code></pre>
<ul>
<li><code>self.cli = self.create_client(AddTwoInts, 'add_two_ints')</code></li>
</ul>
<blockquote>
<ul>
<li><strong>等待服务器响应</strong></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;</code></pre>
<ul>
<li><code>self.cli.wait_for_service(timeout_sec=1.0)</code></li>
</ul>
<blockquote>
<ul>
<li><strong>创建响应数据结构</strong></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;</code></pre>
<ul>
<li><code>self.req = AddTwoInts.Request()</code></li>
</ul>
<blockquote>
<ul>
<li><strong>发出服务请求</strong></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;</code></pre>
<ul>
<li>```python</li>
</ul>
<blockquote>
<pre><code>      self.future = self.cli.call_async(self.req)`
      rclpy.spin_until_future_complete(self, self.future)`    
      self.future.result()`
      <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 自定义接口格式</span><br><span class="line"></span><br><span class="line">### 使用流程</span><br><span class="line"></span><br><span class="line">#### 在工作空间下创建interface相关的文件夹(srv,msg,action)</span><br><span class="line"></span><br><span class="line">#### [接口相关的编写方法](https://docs.ros.org/en/humble/Concepts/About-ROS-Interfaces.html)</span><br><span class="line"></span><br><span class="line">##### 不同通讯方式的接口文件形式</span><br><span class="line"></span><br><span class="line">* 话题编写*.msg</span><br><span class="line"></span><br><span class="line"> ```yaml</span><br><span class="line"> # 话题数据格式</span><br><span class="line"> string str</span><br></pre></td></tr></table></figure></code></pre>
</blockquote>
<ul>
<li><p>服务编写*.srv</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#request constants</span></span><br><span class="line"><span class="string">int8</span> <span class="string">FOO=1</span></span><br><span class="line"><span class="string">int8</span> <span class="string">BAR=2</span></span><br><span class="line"><span class="comment">#request fields</span></span><br><span class="line"><span class="string">int8</span> <span class="string">foobar</span></span><br><span class="line"><span class="string">another_pkg/AnotherMessage</span> <span class="string">msg</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment">#response constants</span></span><br><span class="line"><span class="string">uint32</span> <span class="string">SECRET=123456</span></span><br><span class="line"><span class="comment">#response fields</span></span><br><span class="line"><span class="string">another_pkg/YetAnotherMessage</span> <span class="string">val</span></span><br><span class="line"><span class="string">CustomMessageDefinedInThisPackage</span> <span class="string">value</span></span><br><span class="line"><span class="string">uint32</span> <span class="string">an_integer</span></span><br></pre></td></tr></table></figure></li>
<li><p><span id="action_msg">动作编写*.action</span></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#goal constants</span></span><br><span class="line"><span class="string">int8</span> <span class="string">FOO=1</span></span><br><span class="line"><span class="string">int8</span> <span class="string">BAR=2</span></span><br><span class="line"><span class="comment">#goal fields</span></span><br><span class="line"><span class="string">int8</span> <span class="string">foobar</span></span><br><span class="line"><span class="string">another_pkg/AnotherMessage</span> <span class="string">msg</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment">#result constants</span></span><br><span class="line"><span class="string">uint32</span> <span class="string">SECRET=123456</span></span><br><span class="line"><span class="comment">#result fields</span></span><br><span class="line"><span class="string">another_pkg/YetAnotherMessage</span> <span class="string">val</span></span><br><span class="line"><span class="string">CustomMessageDefinedInThisPackage</span> <span class="string">value</span></span><br><span class="line"><span class="string">uint32</span> <span class="string">an_integer</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment">#feedback constants</span></span><br><span class="line"><span class="string">uint32</span> <span class="string">SOMETHING=123456</span></span><br><span class="line"><span class="comment">#feedback fields</span></span><br><span class="line"><span class="string">uint32</span> <span class="string">process</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="类型定义">类型定义</h5>
<h6 id="内置数据类型">内置数据类型</h6>
<p><img src=".\ROS2常用代码段.assets\image-20220814091211622.png" alt="image-20220814091211622" style="zoom:50%;" /></p>
<h6 id="内置表格类型">内置表格类型</h6>
<p><img src=".\ROS2常用代码段.assets\image-20220814091328378.png" alt="image-20220814091328378" style="zoom:50%;" /></p>
<h6 id="示例">示例</h6>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">int32[]</span> <span class="string">unbounded_integer_array</span></span><br><span class="line"><span class="string">int32[5]</span> <span class="string">five_integers_array</span></span><br><span class="line"><span class="string">int32[&lt;=5]</span> <span class="string">up_to_five_integers_array</span></span><br><span class="line"></span><br><span class="line"><span class="string">string</span> <span class="string">string_of_unbounded_size</span></span><br><span class="line"><span class="string">string&lt;=10</span> <span class="string">up_to_ten_characters_string</span></span><br><span class="line"></span><br><span class="line"><span class="string">string[&lt;=5]</span> <span class="string">up_to_five_unbounded_strings</span></span><br><span class="line"><span class="string">string&lt;=10[]</span> <span class="string">unbounded_array_of_string_up_to_ten_characters_each</span></span><br><span class="line"><span class="string">string&lt;=10[&lt;=5]</span> <span class="string">up_to_five_strings_up_to_ten_characters_each</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里可以对数组进行约束和设置，比如固定长度，不定长度，有边界数组等，同时对于字符串也可以进行约束，参考4.1.2.2中不同数组定义下的rcl转换类型</p>
</blockquote>
<h5 id="默认值">默认值</h5>
<p><strong>格式：</strong><code>fieldtype fieldname fielddefaultvalue</code></p>
<p><strong>示例</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">uint8</span> <span class="string">x</span> <span class="number">42</span></span><br><span class="line"><span class="string">int16</span> <span class="string">y</span> <span class="number">-2000</span></span><br><span class="line"><span class="string">string</span> <span class="string">full_name</span> <span class="string">&quot;John Doe&quot;</span></span><br><span class="line"><span class="string">int32[]</span> <span class="string">samples</span> [<span class="number">-200</span>, <span class="number">-100</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>]</span><br></pre></td></tr></table></figure>
<h5 id="常数定义">常数定义</h5>
<p><strong>格式：</strong><code>constanttype CONSTANTNAME=constantvalue</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">int32</span> <span class="string">X=123</span></span><br><span class="line"><span class="string">int32</span> <span class="string">Y=-123</span></span><br><span class="line"><span class="string">string</span> <span class="string">FOO=&quot;foo&quot;</span></span><br><span class="line"><span class="string">string</span> <span class="string">EXAMPLE=&#x27;bar&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="编写编译文件">编写编译文件</h4>
<h5 id="核心内容">核心内容</h5>
<ol type="1">
<li><p>在package.xml中写入接口的以来包，比如<code>geometry_msgs</code>，然后写上：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosidl_default_generators<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rosidl_default_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>来声明要生成接口</p></li>
<li><p>在CMakeLists.txt中写上生成的接口文件：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">rosidl_generate_interfaces(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  <span class="string">&quot;msg/Num.msg&quot;</span></span><br><span class="line">  <span class="string">&quot;msg/Sphere.msg&quot;</span></span><br><span class="line">  <span class="string">&quot;srv/AddThreeInts.srv&quot;</span></span><br><span class="line">  DEPENDENCIES geometry_msgs <span class="comment"># Add packages that above messages depend on, in this case geometry_msgs for Sphere.msg</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里要写上相关的依赖项，特别是当使用自定义的接口来进一步封装时，更要协商当前的接口路径</p>
</blockquote></li>
</ol>
<h5 id="package.xml-3">package.xml</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml-model href=<span class="string">&quot;http://download.ros.org/schema/package_format3.xsd&quot;</span> schematypens=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">format</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>tutorial_interfaces<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>TODO: Package description<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;dllr@todo.todo&quot;</span>&gt;</span>dllr<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">license</span>&gt;</span>TODO: License declaration<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>ament_cmake_auto<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">depend</span>&gt;</span>geometry_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosidl_default_generators<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rosidl_default_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>ament_lint_auto<span class="tag">&lt;/<span class="name">test_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>ament_lint_common<span class="tag">&lt;/<span class="name">test_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">export</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">build_type</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">build_type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="cmakelists.txt-1">CMakeLists.txt</h5>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.8</span>)</span><br><span class="line"><span class="keyword">project</span>(tutorial_interfaces)</span><br><span class="line"></span><br><span class="line"><span class="comment"># find dependencies</span></span><br><span class="line"><span class="keyword">find_package</span>(ament_cmake_auto REQUIRED)</span><br><span class="line">ament_auto_find_build_dependencies()</span><br><span class="line"></span><br><span class="line">rosidl_generate_interfaces(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  <span class="string">&quot;msg/Num.msg&quot;</span></span><br><span class="line">  <span class="string">&quot;msg/Sphere.msg&quot;</span></span><br><span class="line">  <span class="string">&quot;srv/AddThreeInts.srv&quot;</span></span><br><span class="line">  DEPENDENCIES geometry_msgs <span class="comment"># Add packages that above messages depend on, in this case geometry_msgs for Sphere.msg</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ament_auto_package()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里还导出了ament_export_dependencies(rosidl_default_runtime)，如果不使用ament_cmake_auto,记得手动加上。</p>
</blockquote>
<h4 id="使用colcon生成接口文件">使用colcon生成接口文件</h4>
<p><code>colcon build --package--selete interface_package</code></p>
<h3
id="自定义接口文件使用方法以vscode中为例">自定义接口文件使用方法(以vscode中为例)</h3>
<h4
id="在与接口定义不同功能包下的调用方法">在与接口定义不同功能包下的调用方法</h4>
<blockquote>
<p>像使用<code>geometry_msgs</code>等一样在package.xml中写入depend即可</p>
</blockquote>
<h4
id="在与接口定义相同功能包下的调用方法">在与接口定义相同功能包下的调用方法</h4>
<ol type="1">
<li><p>依据4.1中接口文件生成的流程定义接口类型</p></li>
<li><p>在CmakeLists.txt补充一下内容：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">rosidl_get_typesupport_target(cpp_typesupport_target</span><br><span class="line">  <span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="string">&quot;rosidl_typesupport_cpp&quot;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(执行文件名 <span class="string">&quot;$&#123;cpp_typesupport_target&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处只需修改<strong>执行文件名</strong>即可</p>
</blockquote></li>
<li><p>像4.2.1中调用接口即可</p></li>
</ol>
<blockquote>
<p>此处建议先编译生成接口的相关文件，再进行实际功能包的编写，以方便获得代码提示和补全的功能</p>
</blockquote>
<h5 id="示例-1">示例</h5>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmakelist.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.8</span>)</span><br><span class="line"><span class="keyword">project</span>(interface_demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CMAKE_COMPILER_IS_GNUCXX <span class="keyword">OR</span> CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;Clang&quot;</span>)</span><br><span class="line">  <span class="keyword">add_compile_options</span>(-Wall -Wextra -Wpedantic)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># find dependencies</span></span><br><span class="line"><span class="keyword">find_package</span>(ament_cmake_auto REQUIRED)</span><br><span class="line">ament_auto_find_build_dependencies()</span><br><span class="line"></span><br><span class="line">rosidl_generate_interfaces(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  <span class="string">&quot;msg/DialagDemo.msg&quot;</span></span><br><span class="line">  <span class="string">&quot;msg/TalkDemo.msg&quot;</span></span><br><span class="line">  <span class="comment"># &quot;srv/AddThreeInts.srv&quot;</span></span><br><span class="line">  DEPENDENCIES std_msgs<span class="comment"># Add packages that above messages depend on, in this case geometry_msgs for Sphere.msg</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ament_auto_add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_node src/test_node.cpp)</span><br><span class="line">rosidl_get_typesupport_target(cpp_typesupport_target</span><br><span class="line">  <span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="string">&quot;rosidl_typesupport_cpp&quot;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_node <span class="string">&quot;$&#123;cpp_typesupport_target&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">ament_auto_package()</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt; !--&gt;package.xml&lt;/!--&gt;</span><br><span class="line">        <span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line">        <span class="meta">&lt;?xml-model href=<span class="string">&quot;http://download.ros.org/schema/package_format3.xsd&quot;</span> schematypens=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">format</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>interface_demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>TODO: Package description<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;965794928@qq.com&quot;</span>&gt;</span>dllr<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">license</span>&gt;</span>TODO: License declaration<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>ament_cmake_auto<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>rclcpp<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosidl_default_generators<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>rosidl_default_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="tag">&lt;/<span class="name">member_of_group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>ament_lint_auto<span class="tag">&lt;/<span class="name">test_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>ament_lint_common<span class="tag">&lt;/<span class="name">test_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">export</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build_type</span>&gt;</span>ament_cmake<span class="tag">&lt;/<span class="name">build_type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4
id="在同一功能包下使用该功能包的msg封装另一个msg">在同一功能包下使用该功能包的msg封装另一个msg</h4>
<blockquote>
<p>本质上和编写无封装的接口文件是一样的</p>
</blockquote>
<ol type="1">
<li><p>创建msg文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir msg</span><br></pre></td></tr></table></figure></li>
<li><p>使用其他功能包下的接口定义一个基础自定义接口</p>
<ul>
<li><code>msg/Demo.msg</code></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">uint8</span> <span class="string">hello</span></span><br><span class="line"><span class="string">bool</span> <span class="string">isopen</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用自定义接口定义以其为基础封装的接口</p>
<ul>
<li>假设当前功能包名字为<code>Demo_interface</code>,创建<code>msg/Demos.msg</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Demo_interface/Demo[3] demos_interface</span><br></pre></td></tr></table></figure></li>
<li><p>像正常编写自定义接口的方式编写<code>CmakeList.txt</code>和<code>package.xml</code>即可</p></li>
</ol>
<h4 id="vscode中代码补全的配置">vscode中代码补全的配置</h4>
<h5 id="cpp相关配置">cpp相关配置</h5>
<p>在<code>c_cpp_properties.json</code>中的<code>includePath</code>补充功能包接口库的头文件路径，如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;browse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;databaseFilename&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;default&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;limitSymbolsToIncludedHeaders&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;/opt/ros/humble/include/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;/home/dllr/my_code/ros/ws/topic_ws/src/cpp_pubsub/include/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;/usr/include/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;$&#123;workspaceFolder&#125;/install/tutorial_interfaces/include/**&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ROS&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gcc-x64&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gnu11&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处补充了<code>"$&#123;workspaceFolder&#125;/install/tutorial_interfaces/include/**"</code>，用以指明自定义接口头文件路径</p>
</blockquote>
<h5 id="python相关配置">python相关配置</h5>
<p>在<code>settings.json</code>中添加新生成python库路径，如下所示</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;python.autoComplete.extraPaths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;/opt/ros/humble/lib/python3.10/site-packages&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;/opt/ros/humble/local/lib/python3.10/dist-packages&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;workspaceFolder&#125;/install/tutorial_interfaces/local/lib/python3.10/dist-packages&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;python.analysis.extraPaths&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;/opt/ros/humble/lib/python3.10/site-packages&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;/opt/ros/humble/local/lib/python3.10/dist-packages&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;workspaceFolder&#125;/install/tutorial_interfaces/local/lib/python3.10/dist-packages&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;files.associations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;chrono&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;random&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处补充了<code>"$&#123;workspaceFolder&#125;/install/tutorial_interfaces/local/lib/python3.10/dist-packages"</code>，用以声明自定义接口库路径</p>
</blockquote>
<h2 id="参数相关">参数相关</h2>
<h3 id="api接口">API接口：</h3>
<p><img src=".\ROS2常用代码段.assets\image-20220814095727267.png" alt="image-20220814095727267" style="zoom:50%;" /></p>
<h3 id="cpp-1">CPP</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rclcpp/rclcpp.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParametersClass</span>: <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ParametersClass</span>()</span><br><span class="line">      : <span class="built_in">Node</span>(<span class="string">&quot;parameter_node&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;<span class="built_in">declare_parameter</span>&lt;std::string&gt;(<span class="string">&quot;my_parameter&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">      timer_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(</span><br><span class="line">      <span class="number">1000</span>ms, std::<span class="built_in">bind</span>(&amp;ParametersClass::respond, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">respond</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;<span class="built_in">get_parameter</span>(<span class="string">&quot;my_parameter&quot;</span>, parameter_string_);</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Hello %s&quot;</span>, parameter_string_.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::string parameter_string_;</span><br><span class="line">    rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;ParametersClass&gt;());</span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>核心代码</p>
<ul>
<li><strong>声明参数：</strong><code>this-&gt;declare_parameter&lt;std::string&gt;("my_parameter", "world");</code></li>
<li><strong>获取参数：</strong><code>this-&gt;get_parameter("my_parameter", parameter_string_);</code></li>
</ul>
</blockquote>
<h3 id="python-2">Python</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">import</span> rclpy.node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinimalParam</span>(rclpy.node.Node):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&#x27;minimal_param_node&#x27;</span>)</span><br><span class="line">        timer_period = <span class="number">2</span>  <span class="comment"># seconds</span></span><br><span class="line">        self.timer = self.create_timer(timer_period, self.timer_callback)</span><br><span class="line">        <span class="keyword">from</span> rcl_interfaces.msg <span class="keyword">import</span> ParameterDescriptor</span><br><span class="line">        my_parameter_descriptor = ParameterDescriptor(</span><br><span class="line">            description=<span class="string">&#x27;This parameter is mine!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.declare_parameter(<span class="string">&#x27;my_parameter&#x27;</span>,</span><br><span class="line">                               <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">                               my_parameter_descriptor)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">timer_callback</span>(<span class="params">self</span>):</span><br><span class="line">        my_param = self.get_parameter(</span><br><span class="line">            <span class="string">&#x27;my_parameter&#x27;</span>).get_parameter_value().string_value</span><br><span class="line"></span><br><span class="line">        self.get_logger().info(<span class="string">&#x27;Hello %s!&#x27;</span> % my_param)</span><br><span class="line"></span><br><span class="line">        my_new_param = rclpy.parameter.Parameter(</span><br><span class="line">            <span class="string">&#x27;my_parameter&#x27;</span>,</span><br><span class="line">            rclpy.Parameter.<span class="type">Type</span>.STRING,</span><br><span class="line">            <span class="string">&#x27;world&#x27;</span></span><br><span class="line">        )</span><br><span class="line">        all_new_parameters = [my_new_param]</span><br><span class="line">        self.set_parameters(all_new_parameters)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    rclpy.init()</span><br><span class="line">    node = MinimalParam()</span><br><span class="line">    rclpy.spin(node)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>核心代码：</p>
<ul>
<li>声明参数(<strong>并进行描述</strong>)</li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> rcl_interfaces.msg <span class="keyword">import</span> ParameterDescriptor</span><br><span class="line">my_parameter_descriptor = ParameterDescriptor(</span><br><span class="line">description=<span class="string">&#x27;This parameter is mine!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  self.declare_parameter(<span class="string">&#x27;my_parameter&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">my_parameter_descriptor)</span><br></pre></td></tr></table></figure></code></pre>
<blockquote>
<ul>
<li><strong>获取参数</strong></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_param = self.get_parameter(</span><br><span class="line"><span class="string">&#x27;my_parameter&#x27;</span>).get_parameter_value().string_value</span><br></pre></td></tr></table></figure></code></pre>
<blockquote>
<ul>
<li><strong>设置参数</strong></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_new_param = rclpy.parameter.Parameter(</span><br><span class="line"><span class="string">&#x27;my_parameter&#x27;</span>,</span><br><span class="line">rclpy.Parameter.<span class="type">Type</span>.STRING,</span><br><span class="line"><span class="string">&#x27;world&#x27;</span></span><br><span class="line">)</span><br><span class="line">all_new_parameters = [my_new_param]</span><br><span class="line">self.set_parameters(all_new_parameters)</span><br></pre></td></tr></table></figure></code></pre>
<h3 id="监测参数的变化">监测参数的变化</h3>
<blockquote>
<p>注意，在监听前，参数一定要先声明，否则是无效的！！</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SampleNodeWithParameters</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">SampleNodeWithParameters</span>()</span><br><span class="line">      : <span class="built_in">Node</span>(<span class="string">&quot;node_with_parameters&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">declare_parameter</span>(<span class="string">&quot;an_int_param&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a parameter subscriber that can be used to monitor parameter changes</span></span><br><span class="line">    <span class="comment">// (for this node&#x27;s parameters as well as other nodes&#x27; parameters)</span></span><br><span class="line">    param_subscriber_ = std::<span class="built_in">make_shared</span>&lt;rclcpp::ParameterEventHandler&gt;(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set a callback for this node&#x27;s integer parameter, &quot;an_int_param&quot;</span></span><br><span class="line">    <span class="keyword">auto</span> cb = [<span class="keyword">this</span>](<span class="type">const</span> rclcpp::Parameter &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(</span><br><span class="line">          <span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;cb: Received an update to parameter \&quot;%s\&quot; of type %s: \&quot;%ld\&quot;&quot;</span>,</span><br><span class="line">          p.<span class="built_in">get_name</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">          p.<span class="built_in">get_type_name</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">          p.<span class="built_in">as_int</span>());</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> remote_node_name = std::<span class="built_in">string</span>(<span class="string">&quot;parameter_blackboard&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> remote_param_name = std::<span class="built_in">string</span>(<span class="string">&quot;a_double_param&quot;</span>);</span><br><span class="line">    cb_handle_ = param_subscriber_-&gt;<span class="built_in">add_parameter_callback</span>(<span class="string">&quot;an_int_param&quot;</span>, cb);</span><br><span class="line">    cb_handle2_ = param_subscriber_-&gt;<span class="built_in">add_parameter_callback</span>(remote_param_name, cb, remote_node_name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::shared_ptr&lt;rclcpp::ParameterEventHandler&gt; param_subscriber_;</span><br><span class="line">  std::shared_ptr&lt;rclcpp::ParameterCallbackHandle&gt; cb_handle_;</span><br><span class="line">  std::shared_ptr&lt;rclcpp::ParameterCallbackHandle&gt; cb_handle2_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">  rclcpp::<span class="built_in">spin</span>(std::<span class="built_in">make_shared</span>&lt;SampleNodeWithParameters&gt;());</span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>核心代码：</p>
<ul>
<li><strong>声明监听和回调对象：</strong></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;rclcpp::ParameterEventHandler&gt; param_subscriber_;</span><br><span class="line">std::shared_ptr&lt;rclcpp::ParameterCallbackHandle&gt; cb_handle_;</span><br><span class="line">std::shared_ptr&lt;rclcpp::ParameterCallbackHandle&gt; cb_handle2_;</span><br></pre></td></tr></table></figure></code></pre>
<blockquote>
<ul>
<li><strong>创建监听对象：</strong></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a parameter subscriber that can be used to monitor parameter changes</span></span><br><span class="line"><span class="comment">// (for this node&#x27;s parameters as well as other nodes&#x27; parameters)</span></span><br><span class="line">param_subscriber_ = std::<span class="built_in">make_shared</span>&lt;rclcpp::ParameterEventHandler&gt;(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></code></pre>
<blockquote>
<ul>
<li><strong>创建回调函数及其对象：</strong></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set a callback for this node&#x27;s integer parameter, &quot;an_int_param&quot;</span></span><br><span class="line"><span class="keyword">auto</span> cb = [<span class="keyword">this</span>](<span class="type">const</span> rclcpp::Parameter &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">RCLCPP_INFO</span>(</span><br><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;cb: Received an update to parameter \&quot;%s\&quot; of type %s: \&quot;%ld\&quot;&quot;</span>,</span><br><span class="line">p.<span class="built_in">get_name</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">p.<span class="built_in">get_type_name</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">p.<span class="built_in">as_int</span>());</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> remote_node_name = std::<span class="built_in">string</span>(<span class="string">&quot;parameter_blackboard&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> remote_param_name = std::<span class="built_in">string</span>(<span class="string">&quot;a_double_param&quot;</span>);</span><br><span class="line"><span class="comment">// 监听自己的参数变化</span></span><br><span class="line">cb_handle_ = param_subscriber_-&gt;<span class="built_in">add_parameter_callback</span>(<span class="string">&quot;an_int_param&quot;</span>, cb);</span><br><span class="line"><span class="comment">// 监听其他节点的参数变化</span></span><br><span class="line">cb_handle2_ = param_subscriber_-&gt;<span class="built_in">add_parameter_callback</span>(remote_param_name, cb, remote_node_name);</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="动作相关">动作相关</h2>
<blockquote>
<ul>
<li>在写动作相关的功能包前，需要先定义好动作的<code>interface</code>
接口文件，action/xxxx.action，其格式可以参考<a
href="#action_msg">自定义接口格式处的描述</a></li>
<li>对于动作相关的完整描述，可以查看官方的<a
href="http://design.ros2.org/articles/actions.html">设计文章</a>，有着具体的设计思路和使用方法解释</li>
</ul>
</blockquote>
<h3 id="动作的作用描述">动作的作用描述</h3>
<h4 id="服务端的作用">服务端的作用</h4>
<ul>
<li>发布的动作到ros实体</li>
<li>接受或拒绝来自于一个或多个客户端的目标请求</li>
<li>执行被接受的目标</li>
<li>选择性的提供动作执行过程的<code>feedback</code></li>
<li>选择性的处理取消等多个来自客户端的状态变化请求</li>
<li>sending the result of a completed action, including whether it
succeeded, failed, or was canceled, to a client that makes a result
request.</li>
</ul>
<h4 id="客户端的作用">客户端的作用</h4>
<ul>
<li>sending goals to the action server</li>
<li>optionally monitoring the user-defined feedback for goals from the
action server</li>
<li>optionally monitoring the current state of accepted goals from the
action server ( see <a
href="http://design.ros2.org/articles/actions.html#goal-states">Goal
States</a>)</li>
<li>optionally requesting that the action server cancel an active
goal</li>
<li>optionally checking the result for a goal received from the action
server</li>
</ul>
<h4 id="状态过程描述">状态过程描述</h4>
<figure>
<img
src="/home/dllr/Desktop/notebook/ros2/ROS2常用代码段.assets/goal_state_machine.png"
alt="Action Goal State Machine" />
<figcaption aria-hidden="true">Action Goal State Machine</figcaption>
</figure>
<p>有三个活动状态:</p>
<ul>
<li><strong>ACCEPTED</strong> - 目标已经被接受并等待执行</li>
<li><strong>EXECUTING</strong> - 目标正在被动作服务器执行</li>
<li><strong>CANCELING</strong> -
客户端请求取消动作，并且服务端接受了取消的请求. This state is useful for
any user-defined “clean up” that the action server may have to do.</li>
</ul>
<p>此外，还有三个最终状态(客户端在result回调函数中可接受的状态):</p>
<ul>
<li><strong>SUCCEEDED</strong> - 服务端成功的完成了目标.</li>
<li><strong>ABORTED</strong> -
目标在没有外部取消请求的情况下被服务端终止了.</li>
<li><strong>CANCELED</strong> -
目标在一个客户端的取消请求后成功的终止了.</li>
</ul>
<p>状态转移发生在服务端中，其转移的触发时机由具体的代码实现决定:</p>
<ul>
<li><strong>execute</strong> - 开始执行一个目标.</li>
<li><strong>succeed</strong> - 通知说明一个动作被成功的完成了.</li>
<li><strong>abort</strong> -
通知说明在执行目标的过程中出现了某种错误，不得不终止动作的执行.</li>
<li><strong>canceled</strong> -
通知说明动作被客户端申请取消，且服务端同意申请，动作已经被取消了.</li>
</ul>
<p>在客户端可以调用下列两个函数触发动作过程的状态变化:</p>
<ul>
<li><strong>send_goal</strong> -
一个目标被送到服务端，只有当服务端接受该目标请求时，状态机才会开始工作.</li>
<li><strong>cancel_goal</strong> - 请求服务端取消目标的执行.
，只有当服务端接受了终止请求，状态才会发生转移.</li>
</ul>
<h3 id="cpp实现">CPP实现</h3>
<h4 id="动作服务器">动作服务器</h4>
<h5 id="创建功能包-2">创建功能包</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ros2 pkg create --dependencies action_tutorials_interfaces rclcpp rclcpp_action rclcpp_components -- action_tutorials_cpp</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>此处需注意创建时的依赖，包括<code>rclcpp</code>、<code>rclcpp_action</code>,还有创建的动作<code>interface</code>功能包</li>
<li>此处的<code>rclcpp_components</code>是为了将该动作服务器注册为一个<code>component</code>组件</li>
</ul>
</blockquote>
<h5 id="编写服务端代码">编写服务端代码</h5>
<h6 id="一个动作服务器需要六个部分">一个动作服务器需要六个部分</h6>
<ol type="1">
<li>The templated action type name: <code>Fibonacci</code>.</li>
<li>A ROS 2 node to add the action to: <code>this</code>.</li>
<li>The action name: <code>'fibonacci'</code>.</li>
<li>A callback function for handling goals:
<code>handle_goal</code></li>
<li>A callback function for handling cancellation:
<code>handle_cancel</code>.</li>
<li>A callback function for handling goal accept:
<code>handle_accept</code>.</li>
</ol>
<h6 id="代码">代码</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;action_tutorials_interfaces/action/fibonacci.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp_action/rclcpp_action.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp_components/register_node_macro.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;action_tutorials_cpp/visibility_control.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> action_tutorials_cpp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FibonacciActionServer</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Fibonacci = action_tutorials_interfaces::action::Fibonacci;</span><br><span class="line">  <span class="keyword">using</span> GoalHandleFibonacci = rclcpp_action::ServerGoalHandle&lt;Fibonacci&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function">ACTION_TUTORIALS_CPP_PUBLIC</span></span><br><span class="line"><span class="function">  <span class="keyword">explicit</span> <span class="title">FibonacciActionServer</span><span class="params">(<span class="type">const</span> rclcpp::NodeOptions &amp; options = rclcpp::NodeOptions())</span></span></span><br><span class="line"><span class="function">  : Node(<span class="string">&quot;fibonacci_action_server&quot;</span>, options)</span></span><br><span class="line"><span class="function">  &#123;</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;action_server_ = rclcpp_action::<span class="built_in">create_server</span>&lt;Fibonacci&gt;(</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      <span class="string">&quot;fibonacci&quot;</span>,</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;FibonacciActionServer::handle_goal, <span class="keyword">this</span>, _1, _2),</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;FibonacciActionServer::handle_cancel, <span class="keyword">this</span>, _1),</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;FibonacciActionServer::handle_accepted, <span class="keyword">this</span>, _1));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  rclcpp_action::Server&lt;Fibonacci&gt;::SharedPtr action_server_;</span><br><span class="line"></span><br><span class="line">  <span class="function">rclcpp_action::GoalResponse <span class="title">handle_goal</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> rclcpp_action::GoalUUID &amp; uuid,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::shared_ptr&lt;<span class="type">const</span> Fibonacci::Goal&gt; goal)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Received goal request with order %d&quot;</span>, goal-&gt;order);</span><br><span class="line">    (<span class="type">void</span>)uuid;</span><br><span class="line">    <span class="keyword">return</span> rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">rclcpp_action::CancelResponse <span class="title">handle_cancel</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::shared_ptr&lt;GoalHandleFibonacci&gt; goal_handle)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Received request to cancel goal&quot;</span>);</span><br><span class="line">    (<span class="type">void</span>)goal_handle;</span><br><span class="line">    <span class="keyword">return</span> rclcpp_action::CancelResponse::ACCEPT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handle_accepted</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;GoalHandleFibonacci&gt; goal_handle)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line">    <span class="comment">// this needs to return quickly to avoid blocking the executor, so spin up a new thread</span></span><br><span class="line">    std::thread&#123;std::<span class="built_in">bind</span>(&amp;FibonacciActionServer::execute, <span class="keyword">this</span>, _1), goal_handle&#125;.<span class="built_in">detach</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;GoalHandleFibonacci&gt; goal_handle)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Executing goal&quot;</span>);</span><br><span class="line">    <span class="function">rclcpp::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> goal = goal_handle-&gt;<span class="built_in">get_goal</span>();</span><br><span class="line">    <span class="keyword">auto</span> feedback = std::<span class="built_in">make_shared</span>&lt;Fibonacci::Feedback&gt;();</span><br><span class="line">    <span class="keyword">auto</span> &amp; sequence = feedback-&gt;partial_sequence;</span><br><span class="line">    sequence.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    sequence.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> result = std::<span class="built_in">make_shared</span>&lt;Fibonacci::Result&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; (i &lt; goal-&gt;order) &amp;&amp; rclcpp::<span class="built_in">ok</span>(); ++i) &#123;</span><br><span class="line">      <span class="comment">// Check if there is a cancel request</span></span><br><span class="line">      <span class="keyword">if</span> (goal_handle-&gt;<span class="built_in">is_canceling</span>()) &#123;</span><br><span class="line">        result-&gt;sequence = sequence;</span><br><span class="line">        goal_handle-&gt;<span class="built_in">canceled</span>(result);</span><br><span class="line">        <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Goal canceled&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Update sequence</span></span><br><span class="line">      sequence.<span class="built_in">push_back</span>(sequence[i] + sequence[i - <span class="number">1</span>]);</span><br><span class="line">      <span class="comment">// Publish feedback</span></span><br><span class="line">      goal_handle-&gt;<span class="built_in">publish_feedback</span>(feedback);</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Publish feedback&quot;</span>);</span><br><span class="line"></span><br><span class="line">      loop_rate.<span class="built_in">sleep</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if goal is done</span></span><br><span class="line">    <span class="keyword">if</span> (rclcpp::<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      result-&gt;sequence = sequence;</span><br><span class="line">      goal_handle-&gt;<span class="built_in">succeed</span>(result);</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Goal succeeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;  <span class="comment">// class FibonacciActionServer</span></span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace action_tutorials_cpp</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RCLCPP_COMPONENTS_REGISTER_NODE</span>(action_tutorials_cpp::FibonacciActionServer)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>关键代码：</strong></p>
<ul>
<li>创建服务器对象，此处的关键点在于需要绑定三个处理函数，分别是<code>动作启动句柄</code>，<code>动作取消句柄</code>，<code>动作完成句柄</code>
，而动作的反馈是在动作启动句柄中进行的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;action_server_ = rclcpp_action::<span class="built_in">create_server</span>&lt;Fibonacci&gt;(</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      <span class="string">&quot;fibonacci&quot;</span>,</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;FibonacciActionServer::handle_goal, <span class="keyword">this</span>, _1, _2),</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;FibonacciActionServer::handle_cancel, <span class="keyword">this</span>, _1),</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;FibonacciActionServer::handle_accepted, <span class="keyword">this</span>, _1));</span><br></pre></td></tr></table></figure>
<ul>
<li>注意代码中在动作接受句柄<code>handle_accepted</code>中调用了额外的线程执行任务的执行过程。此处是为了避免执行时间过长的阻塞，方便多个动作客户端同时工作</li>
</ul>
</blockquote>
<h4 id="动作客户端">动作客户端</h4>
<blockquote>
<p>动作客户端的功能包依赖和服务端是一样的，所以可以在同一个工作包下进行编写</p>
</blockquote>
<h5 id="编写客户端代码">编写客户端代码</h5>
<h6
id="一个动作客户端有三个重要的事情">一个动作客户端有三个重要的事情:</h6>
<ol type="1">
<li>The templated action type name: <code>Fibonacci</code>.</li>
<li>A ROS 2 node to add the action client to: <code>this</code>.</li>
<li>The action name: <code>'fibonacci'</code>.</li>
</ol>
<h6 id="代码-1">代码</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;action_tutorials_interfaces/action/fibonacci.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp_action/rclcpp_action.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp_components/register_node_macro.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> action_tutorials_cpp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FibonacciActionClient</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Fibonacci = action_tutorials_interfaces::action::Fibonacci;</span><br><span class="line">  <span class="keyword">using</span> GoalHandleFibonacci = rclcpp_action::ClientGoalHandle&lt;Fibonacci&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FibonacciActionClient</span><span class="params">(<span class="type">const</span> rclcpp::NodeOptions &amp; options)</span></span></span><br><span class="line"><span class="function">  : Node(<span class="string">&quot;fibonacci_action_client&quot;</span>, options)</span></span><br><span class="line"><span class="function">  &#123;</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;client_ptr_ = rclcpp_action::<span class="built_in">create_client</span>&lt;Fibonacci&gt;(</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      <span class="string">&quot;fibonacci&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;timer_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(</span><br><span class="line">      std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>),</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;FibonacciActionClient::send_goal, <span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">send_goal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;timer_-&gt;<span class="built_in">cancel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;client_ptr_-&gt;<span class="built_in">wait_for_action_server</span>()) &#123;</span><br><span class="line">      <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Action server not available after waiting&quot;</span>);</span><br><span class="line">      rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> goal_msg = Fibonacci::<span class="built_in">Goal</span>();</span><br><span class="line">    goal_msg.order = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Sending goal&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> send_goal_options = rclcpp_action::Client&lt;Fibonacci&gt;::<span class="built_in">SendGoalOptions</span>();</span><br><span class="line">    send_goal_options.goal_response_callback =</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;FibonacciActionClient::goal_response_callback, <span class="keyword">this</span>, _1);</span><br><span class="line">    send_goal_options.feedback_callback =</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;FibonacciActionClient::feedback_callback, <span class="keyword">this</span>, _1, _2);</span><br><span class="line">    send_goal_options.result_callback =</span><br><span class="line">      std::<span class="built_in">bind</span>(&amp;FibonacciActionClient::result_callback, <span class="keyword">this</span>, _1);</span><br><span class="line">    <span class="keyword">this</span>-&gt;client_ptr_-&gt;<span class="built_in">async_send_goal</span>(goal_msg, send_goal_options);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  rclcpp_action::Client&lt;Fibonacci&gt;::SharedPtr client_ptr_;</span><br><span class="line">  rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">goal_response_callback</span><span class="params">(<span class="type">const</span> GoalHandleFibonacci::SharedPtr &amp; goal_handle)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!goal_handle) &#123;</span><br><span class="line">      <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Goal was rejected by server&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Goal accepted by server, waiting for result&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">feedback_callback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    GoalHandleFibonacci::SharedPtr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> Fibonacci::Feedback&gt; feedback)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;Next number in sequence received: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> number : feedback-&gt;partial_sequence) &#123;</span><br><span class="line">      ss &lt;&lt; number &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), ss.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">result_callback</span><span class="params">(<span class="type">const</span> GoalHandleFibonacci::WrappedResult &amp; result)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (result.code) &#123;</span><br><span class="line">      <span class="keyword">case</span> rclcpp_action::ResultCode::SUCCEEDED:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> rclcpp_action::ResultCode::ABORTED:</span><br><span class="line">        <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Goal was aborted&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">case</span> rclcpp_action::ResultCode::CANCELED:</span><br><span class="line">        <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Goal was canceled&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Unknown result code&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;Result received: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> number : result.result-&gt;sequence) &#123;</span><br><span class="line">      ss &lt;&lt; number &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), ss.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;  <span class="comment">// class FibonacciActionClient</span></span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace action_tutorials_cpp</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RCLCPP_COMPONENTS_REGISTER_NODE</span>(action_tutorials_cpp::FibonacciActionClient)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>关键代码：</strong></p>
<ul>
<li>创建客户端对象，传入其<code>动作接口类型</code>、<code>所属节点</code>、<code>动作名称</code>:</li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;client_ptr_ = rclcpp_action::<span class="built_in">create_client</span>&lt;Fibonacci&gt;(</span><br><span class="line"><span class="keyword">this</span>,</span><br><span class="line"><span class="string">&quot;fibonacci&quot;</span>);</span><br></pre></td></tr></table></figure></code></pre>
<blockquote>
<ul>
<li>发送目标<code>send_goal()</code>:</li>
</ul>
</blockquote>
<pre><code>&gt;</code></pre>
<ul>
<li>创建目标消息：<code>auto goal_msg = Fibonacci::Goal()</code></li>
</ul>
<blockquote>
<ul>
<li>如果要监测动作过程的<code>feedback</code>、<code>result</code>
等，需要配置<code>auto send_goal_options = rclcpp_action::Client&lt;Fibonacci&gt;::SendGoalOptions();</code>
<ul>
<li>发送目标，建议使用异步发送<code>this-&gt;client_ptr_-&gt;async_send_goal(goal_msg, send_goal_options);</code></li>
</ul></li>
</ul>
<blockquote>
<p>注意自定义的监测函数的参数定义和类型</p>
<ul>
<li><code>goal_response_callback</code>：监测目标发送是否被接受</li>
</ul>
</blockquote>
</blockquote>
<pre><code>  &gt; &gt;
  &gt; &gt;   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">goal_response_callback</span><span class="params">(<span class="type">const</span> GoalHandleFibonacci::SharedPtr &amp; goal_handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!goal_handle) &#123;</span><br><span class="line"><span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Goal was rejected by server&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Goal accepted by server, waiting for result&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<blockquote>
<blockquote>
<ul>
<li><code>feedback_callback</code>:监测动作的反馈过程，在导航和连续作业中很重要</li>
</ul>
</blockquote>
</blockquote>
<pre><code>  &gt; &gt;
  &gt; &gt;   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">feedback_callback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">GoalHandleFibonacci::SharedPtr,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> std::shared_ptr&lt;<span class="type">const</span> Fibonacci::Feedback&gt; feedback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot;Next number in sequence received: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> number : feedback-&gt;partial_sequence) &#123;</span><br><span class="line">ss &lt;&lt; number &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), ss.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<blockquote>
<blockquote>
<ul>
<li><code>result_callback</code>:查看当前动作的完成情况，其中</li>
</ul>
</blockquote>
</blockquote>
<pre><code>  &gt; &gt;
  &gt; &gt;</code></pre>
<ul>
<li><code>rclcpp_action::ResultCode::ABORTED</code>：表示目标被中止了，通常是非用户取消而服务端异常等情况下反馈的最终执行状态</li>
</ul>
<blockquote>
<blockquote>
<ul>
<li><code>rclcpp_action::ResultCode::CANCELED</code>：表示目标被客户端取消了，通常是用户手动取消目标是反馈的最终执行状态
<ul>
<li><code>rclcpp_action::ResultCode::SUCCEEDED</code>：表示目标成功执行，并返回最终结果</li>
</ul></li>
</ul>
</blockquote>
</blockquote>
<pre><code>    &gt; &gt;
    &gt; &gt;   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">result_callback</span><span class="params">(<span class="type">const</span> GoalHandleFibonacci::WrappedResult &amp; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (result.code) &#123;</span><br><span class="line"><span class="keyword">case</span> rclcpp_action::ResultCode::SUCCEEDED:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> rclcpp_action::ResultCode::ABORTED:</span><br><span class="line"><span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Goal was aborted&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> rclcpp_action::ResultCode::CANCELED:</span><br><span class="line"><span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Goal was canceled&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">RCLCPP_ERROR</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), <span class="string">&quot;Unknown result code&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot;Result received: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> number : result.result-&gt;sequence) &#123;</span><br><span class="line">ss &lt;&lt; number &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">RCLCPP_INFO</span>(<span class="keyword">this</span>-&gt;<span class="built_in">get_logger</span>(), ss.<span class="built_in">str</span>().<span class="built_in">c_str</span>());</span><br><span class="line">rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;; <span class="comment">// class FibonacciActionClient</span></span><br></pre></td></tr></table></figure></code></pre>
<h3 id="python实现">Python实现</h3>
<h4 id="动作服务器-1">动作服务器</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.action <span class="keyword">import</span> ActionServer</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> action_tutorials_interfaces.action <span class="keyword">import</span> Fibonacci</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FibonacciActionServer</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&#x27;fibonacci_action_server&#x27;</span>)</span><br><span class="line">        self._action_server = ActionServer(</span><br><span class="line">            self,</span><br><span class="line">            Fibonacci,</span><br><span class="line">            <span class="string">&#x27;fibonacci&#x27;</span>,</span><br><span class="line">            self.execute_callback)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">execute_callback</span>(<span class="params">self, goal_handle</span>):</span><br><span class="line">        self.get_logger().info(<span class="string">&#x27;Executing goal...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        feedback_msg = Fibonacci.Feedback()</span><br><span class="line"></span><br><span class="line">        feedback_msg.partial_sequence = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, goal_handle.request.order):</span><br><span class="line">            feedback_msg.partial_sequence.append(</span><br><span class="line"></span><br><span class="line">                feedback_msg.partial_sequence[i] + feedback_msg.partial_sequence[i - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            self.get_logger().info(<span class="string">&#x27;Feedback: &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(feedback_msg.partial_sequence))</span><br><span class="line"></span><br><span class="line">            goal_handle.publish_feedback(feedback_msg)</span><br><span class="line"></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        goal_handle.succeed()</span><br><span class="line"></span><br><span class="line">        result = Fibonacci.Result()</span><br><span class="line"></span><br><span class="line">        result.sequence = feedback_msg.partial_sequence</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):</span><br><span class="line">    rclpy.init(args=args)</span><br><span class="line"></span><br><span class="line">    fibonacci_action_server = FibonacciActionServer()</span><br><span class="line"></span><br><span class="line">    rclpy.spin(fibonacci_action_server)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>关键代码：</strong></p>
<ul>
<li>创建服务服务器对象，此处仅仅给出了执行过程的回调函数，但和cpp一样，在python中也可以给出接受目标的回调函数以及拒绝目标的回调函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self._action_server = ActionServer(</span><br><span class="line">    self,</span><br><span class="line">    Fibonacci,</span><br><span class="line">    <span class="string">&#x27;fibonacci&#x27;</span>,</span><br><span class="line">    self.execute_callback)</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="动作客户端-1">动作客户端</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rclpy</span><br><span class="line"><span class="keyword">from</span> rclpy.action <span class="keyword">import</span> ActionClient</span><br><span class="line"><span class="keyword">from</span> rclpy.node <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> action_tutorials_interfaces.action <span class="keyword">import</span> Fibonacci</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FibonacciActionClient</span>(<span class="title class_ inherited__">Node</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="string">&#x27;fibonacci_action_client&#x27;</span>)</span><br><span class="line">        self._action_client = ActionClient(self, Fibonacci, <span class="string">&#x27;fibonacci&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send_goal</span>(<span class="params">self, order</span>):</span><br><span class="line">        goal_msg = Fibonacci.Goal()</span><br><span class="line">        goal_msg.order = order</span><br><span class="line"></span><br><span class="line">        self._action_client.wait_for_server()</span><br><span class="line"></span><br><span class="line">        self._send_goal_future = self._action_client.send_goal_async(goal_msg)</span><br><span class="line"></span><br><span class="line">        self._send_goal_future.add_done_callback(self.goal_response_callback)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">goal_response_callback</span>(<span class="params">self, future</span>):</span><br><span class="line">        goal_handle = future.result()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> goal_handle.accepted:</span><br><span class="line">            self.get_logger().info(<span class="string">&#x27;Goal rejected :(&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        self.get_logger().info(<span class="string">&#x27;Goal accepted :)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self._get_result_future = goal_handle.get_result_async()</span><br><span class="line">        self._get_result_future.add_done_callback(self.get_result_callback)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_result_callback</span>(<span class="params">self, future</span>):</span><br><span class="line">        result = future.result().result</span><br><span class="line">        self.get_logger().info(<span class="string">&#x27;Result: &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(result.sequence))</span><br><span class="line">        rclpy.shutdown()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">args=<span class="literal">None</span></span>):</span><br><span class="line">    rclpy.init(args=args)</span><br><span class="line"></span><br><span class="line">    action_client = FibonacciActionClient()</span><br><span class="line"></span><br><span class="line">    action_client.send_goal(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    rclpy.spin(action_client)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>关键代码：</strong></p>
<ul>
<li><p>创建客户端对象：<code>self._action_client = ActionClient(self, Fibonacci, 'fibonacci')</code></p></li>
<li><p>发送目标时等待<code>response</code>，此处注意，在调用<code>send_goal_async</code>时可以传入<code>feedback_callback</code>函数</p></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self._send_goal_future = self._action_client.send_goal_async(goal_msg)</span><br><span class="line"></span><br><span class="line">  self._send_goal_future.add_done_callback(self.goal_response_callback)</span><br></pre></td></tr></table></figure></code></pre>
<blockquote>
<ul>
<li>当获得响应时调用</li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self._get_result_future = goal_handle.get_result_async()</span><br><span class="line">self._get_result_future.add_done_callback(self.get_result_callback)</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="pluginlib的编写方法">pluginlib的编写方法</h2>
<blockquote>
<p>ros中的pluginlib实现的本质是cpp中的对象<strong>多态</strong>，通过调用基类对象指针，控制不同的继承类的函数接口</p>
</blockquote>
<h3 id="安装pluginlib">安装<code>pluginlib</code></h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ros-&#123;$ROS_DISTRO&#125;-pluginlib</span><br></pre></td></tr></table></figure>
<h3 id="使用流程">使用流程</h3>
<h4 id="编写基类库文件">编写基类库文件</h4>
<h5 id="创建工作包">创建工作包</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_cmake polygon_base --dependencies pluginlib --node-name area_node</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处的关键是添加pluginlib依赖</p>
</blockquote>
<h5 id="创建基类库头文件并编写">创建基类库头文件并编写</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> POLYGON_BASE_REGULAR_POLYGON_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLYGON_BASE_REGULAR_POLYGON_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> polygon_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">RegularPolygon</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">initialize</span><span class="params">(<span class="type">double</span> side_length)</span> </span>= <span class="number">0</span>;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">virtual</span> ~<span class="built_in">RegularPolygon</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">      <span class="built_in">RegularPolygon</span>()&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace polygon_base</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// POLYGON_BASE_REGULAR_POLYGON_HPP</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关键代码：</p>
<p>构建虚构函数和纯虚函数，和<code>CPP</code>的多态一样</p>
</blockquote>
<h5 id="编写cmakelist.txt">编写CmakeList.txt</h5>
<blockquote>
<p>安装和导出头文件</p>
</blockquote>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">// 安装头文件</span><br><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  DIRECTORY <span class="keyword">include</span>/</span><br><span class="line">  DESTINATION <span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 导出头文件，方便后续依赖包找寻</span><br><span class="line">ament_export_include_directories(</span><br><span class="line">  <span class="keyword">include</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="colcon-build进行基类库文件安装">colcon
build进行基类库文件安装</h5>
<h4 id="编写插件库文件继承类">编写插件库文件(继承类)</h4>
<h5 id="创建工作包-1">创建工作包</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_cmake polygon_plugins --dependencies polygon_base pluginlib --library-name polygon_plugins</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处不仅要加入<code>pluginlib</code>的依赖，还要加入刚刚创建的基类库工作包作为依赖</p>
</blockquote>
<h5 id="编写插件库文件的代码">编写插件库文件的代码</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;polygon_base/regular_polygon.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> polygon_plugins</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> polygon_base::RegularPolygon</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">(<span class="type">double</span> side_length)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        side_length_ = side_length;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> side_length_ * side_length_;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">double</span> side_length_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> polygon_base::RegularPolygon</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">(<span class="type">double</span> side_length)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        side_length_ = side_length;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * side_length_ * <span class="built_in">getHeight</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">getHeight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>((side_length_ * side_length_) - ((side_length_ / <span class="number">2</span>) * (side_length_ / <span class="number">2</span>)));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">double</span> side_length_;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pluginlib/class_list_macros.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">PLUGINLIB_EXPORT_CLASS</span>(polygon_plugins::Square, polygon_base::RegularPolygon)</span><br><span class="line"><span class="built_in">PLUGINLIB_EXPORT_CLASS</span>(polygon_plugins::Triangle, polygon_base::RegularPolygon)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关键代码：</p>
<ul>
<li>继承基类<code>class Square : public polygon_base::RegularPolygon</code></li>
<li>编写继承的函数代码<code>initialize</code>、<code>area</code>，注意此处每个类内部可以有自己的函数接口</li>
<li>加载到pluginlib当中：</li>
</ul>
</blockquote>
<pre><code>&gt;</code></pre>
<ul>
<li>包含头文件<code>#include&lt;pluginlib/class_list_macros.hpp&gt;</code></li>
</ul>
<blockquote>
<ul>
<li>导出继承类<code>PLUGINLIB_EXPORT_CLASS(polygon_plugins::Square, polygon_base::RegularPolygon)</code></li>
</ul>
</blockquote>
<h5 id="编写插件声明xml">编写插件声明XML</h5>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">library</span> <span class="attr">path</span>=<span class="string">&quot;polygon_plugins&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">type</span>=<span class="string">&quot;polygon_plugins::Square&quot;</span> <span class="attr">base_class_type</span>=<span class="string">&quot;polygon_base::RegularPolygon&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>This is a square plugin.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">type</span>=<span class="string">&quot;polygon_plugins::Triangle&quot;</span> <span class="attr">base_class_type</span>=<span class="string">&quot;polygon_base::RegularPolygon&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>This is a triangle plugin.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">library</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol type="1">
<li><code>library</code>标签给出了包含我们希望导出的插件的相关路径。在ROS2中，这就是插件库的名字，而在ROS1中他需要包含<code>lib</code>前缀。</li>
<li><code>class</code>标签声明了我们插件库中希望导出的插件，下面说明了<code>class</code>中的一些配置参数</li>
</ol>
<blockquote>
<ul>
<li><code>type</code>: The fully qualified type of the plugin. For us,
that’s <code>polygon_plugins::Square</code>.</li>
<li><code>base_class</code>: The fully qualified base class type for the
plugin. For us, that’s <code>polygon_base::RegularPolygon</code>.</li>
<li><code>description</code>: A description of the plugin and what it
does.</li>
</ul>
</blockquote>
</blockquote>
<h5 id="配置cmakelist.txt">配置CmakeList.txt</h5>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.8</span>)</span><br><span class="line"><span class="keyword">project</span>(polygon_plugins)</span><br><span class="line"></span><br><span class="line"><span class="comment"># find dependencies</span></span><br><span class="line"><span class="keyword">find_package</span>(ament_cmake REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(ament_cmake_ros REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(polygon_base REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(pluginlib REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(polygon_plugins src/polygon_plugins.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(polygon_plugins PUBLIC c_std_99 cxx_std_17)  <span class="comment"># Require C99 and C++17</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(polygon_plugins PUBLIC</span><br><span class="line">  $&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>&gt;</span><br><span class="line">  $&lt;INSTALL_INTERFACE:<span class="keyword">include</span>&gt;)</span><br><span class="line">ament_target_dependencies(</span><br><span class="line">  polygon_plugins</span><br><span class="line">  <span class="string">&quot;polygon_base&quot;</span></span><br><span class="line">  <span class="string">&quot;pluginlib&quot;</span></span><br><span class="line">)</span><br><span class="line">pluginlib_export_plugin_description_file(polygon_base plugins.xml)</span><br><span class="line"><span class="comment"># Causes the visibility macros to use dllexport rather than dllimport,</span></span><br><span class="line"><span class="comment"># which is appropriate when building the dll but not consuming it.</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(polygon_plugins PRIVATE <span class="string">&quot;POLYGON_PLUGINS_BUILDING_LIBRARY&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  DIRECTORY <span class="keyword">include</span>/</span><br><span class="line">  DESTINATION <span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  TARGETS polygon_plugins</span><br><span class="line">  <span class="keyword">EXPORT</span> export_<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  ARCHIVE DESTINATION lib</span><br><span class="line">  LIBRARY DESTINATION lib</span><br><span class="line">  RUNTIME DESTINATION bin</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(BUILD_TESTING)</span><br><span class="line">  <span class="keyword">find_package</span>(ament_lint_auto REQUIRED)</span><br><span class="line">  <span class="comment"># the following line skips the linter which checks for copyrights</span></span><br><span class="line">  <span class="comment"># comment the line when a copyright and license is added to all source files</span></span><br><span class="line">  <span class="keyword">set</span>(ament_cmake_copyright_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line">  <span class="comment"># the following line skips cpplint (only works in a git repo)</span></span><br><span class="line">  <span class="comment"># comment the line when this package is in a git repo and when</span></span><br><span class="line">  <span class="comment"># a copyright and license is added to all source files</span></span><br><span class="line">  <span class="keyword">set</span>(ament_cmake_cpplint_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line">  ament_lint_auto_find_test_dependencies()</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">ament_export_include_directories(</span><br><span class="line">  <span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line">ament_export_libraries(</span><br><span class="line">  polygon_plugins</span><br><span class="line">)</span><br><span class="line">ament_export_targets(</span><br><span class="line">  export_<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ament_package()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>关键代码</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加库及其依赖</span></span><br><span class="line"><span class="keyword">add_library</span>(polygon_plugins src/polygon_plugins.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(polygon_plugins PUBLIC</span><br><span class="line">  $&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>&gt;</span><br><span class="line">  $&lt;INSTALL_INTERFACE:<span class="keyword">include</span>&gt;)</span><br><span class="line">ament_target_dependencies(</span><br><span class="line">  polygon_plugins</span><br><span class="line">  polygon_base</span><br><span class="line">  pluginlib</span><br><span class="line">)</span><br><span class="line"><span class="comment"># **此处是插件安装最为重要的指令，导出配置文件</span></span><br><span class="line">pluginlib_export_plugin_description_file(polygon_base plugins.xml)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将插件生成的库进行下载</span></span><br><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  TARGETS polygon_plugins</span><br><span class="line">  <span class="keyword">EXPORT</span> export_<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  ARCHIVE DESTINATION lib</span><br><span class="line">  LIBRARY DESTINATION lib</span><br><span class="line">  RUNTIME DESTINATION bin</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在 <code>ament_package</code> 指令前, 添加</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">ament_export_libraries(</span><br><span class="line">  polygon_plugins</span><br><span class="line">)</span><br><span class="line">ament_export_targets(</span><br><span class="line">  export_<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="colcon-build进行插件类库文件安装">colcon
build进行插件类库文件安装</h5>
<h4 id="使用插件">使用插件</h4>
<blockquote>
<p>在使用插件时，该库无需导入插件库的依赖，只需导入基类的依赖和<code>pluginlib</code>的依赖即可</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pluginlib/class_loader.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;polygon_base/regular_polygon.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// To avoid unused parameter warnings</span></span><br><span class="line">  (<span class="type">void</span>) argc;</span><br><span class="line">  (<span class="type">void</span>) argv;</span><br><span class="line"></span><br><span class="line">  <span class="function">pluginlib::ClassLoader&lt;polygon_base::RegularPolygon&gt; <span class="title">poly_loader</span><span class="params">(<span class="string">&quot;polygon_base&quot;</span>, <span class="string">&quot;polygon_base::RegularPolygon&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    std::shared_ptr&lt;polygon_base::RegularPolygon&gt; triangle = poly_loader.<span class="built_in">createSharedInstance</span>(<span class="string">&quot;polygon_plugins::Triangle&quot;</span>);</span><br><span class="line">    triangle-&gt;<span class="built_in">initialize</span>(<span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;polygon_base::RegularPolygon&gt; square = poly_loader.<span class="built_in">createSharedInstance</span>(<span class="string">&quot;polygon_plugins::Square&quot;</span>);</span><br><span class="line">    square-&gt;<span class="built_in">initialize</span>(<span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Triangle area: %.2f\n&quot;</span>, triangle-&gt;<span class="built_in">area</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Square area: %.2f\n&quot;</span>, square-&gt;<span class="built_in">area</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span>(pluginlib::PluginlibException&amp; ex)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The plugin failed to load for some reason. Error: %s\n&quot;</span>, ex.<span class="built_in">what</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>关键代码：</strong></p>
<ul>
<li><code>ClassLoader</code>是关键类，该类定义在<code>class_loader.hpp</code>中，该类实现了一下功能：</li>
</ul>
</blockquote>
<pre><code>&gt;</code></pre>
<ul>
<li>他将基类作为模板, 比如<code>polygon_base::RegularPolygon</code></li>
</ul>
<blockquote>
<ul>
<li>第一个参数是基类的<strong>库</strong>名字,
比如<code>polygon_base</code>
<ul>
<li>第二个参数是完整的基类类型(包含cpp命名空间) ，比如
<code>polygon_base::RegularPolygon</code></li>
</ul></li>
<li>使用<code>createSharedInstance</code>创建共享实例</li>
</ul>
</blockquote>
<h5 id="colcon-build进行可执行节点的编译安装">colcon
build进行可执行节点的编译安装</h5>
<h5 id="运行节点">运行节点</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ros2 run polygon_base area_node</span><br></pre></td></tr></table></figure>
<h2 id="launch文件的编写方法">launch文件的编写方法</h2>
<h3 id="目录结构及功能包内下载方法">目录结构及功能包内下载方法</h3>
<h4 id="ament_python结构">ament_python结构</h4>
<h5 id="项目结构">项目结构</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src/</span><br><span class="line">    my_package/</span><br><span class="line">        launch/</span><br><span class="line">        setup.py</span><br><span class="line">        setup.cfg</span><br><span class="line">        package.xml</span><br></pre></td></tr></table></figure>
<h5 id="下载方法">下载方法</h5>
<blockquote>
<p>在setup.py中进行声明</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup</span><br><span class="line"></span><br><span class="line">package_name = <span class="string">&#x27;my_package&#x27;</span></span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    <span class="comment"># Other parameters ...</span></span><br><span class="line">    data_files=[</span><br><span class="line">        <span class="comment"># ... Other data files</span></span><br><span class="line">        <span class="comment"># Include all launch files. This is the most important line here!</span></span><br><span class="line">        (os.path.join(<span class="string">&#x27;share&#x27;</span>, package_name), glob(<span class="string">&#x27;launch/*launch.[pxy][yma]*&#x27;</span>))</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="ament_cmake结构">ament_cmake结构</h4>
<h5 id="项目结构-1">项目结构</h5>
<h5 id="下载方法-1">下载方法</h5>
<blockquote>
<p>在CMakeLists.txt中进行下载</p>
</blockquote>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Install launch files.</span></span><br><span class="line"><span class="keyword">install</span>(DIRECTORY</span><br><span class="line">  launch</span><br><span class="line">  DESTINATION share/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="使用python进行编写">使用python进行编写</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_launch_description</span>():</span><br><span class="line">    <span class="keyword">return</span> LaunchDescription([</span><br><span class="line">        Node(</span><br><span class="line">            package=<span class="string">&#x27;turtlesim&#x27;</span>,</span><br><span class="line">            namespace=<span class="string">&#x27;turtlesim1&#x27;</span>,</span><br><span class="line">            executable=<span class="string">&#x27;turtlesim_node&#x27;</span>,</span><br><span class="line">            name=<span class="string">&#x27;sim&#x27;</span></span><br><span class="line">        ),</span><br><span class="line">        Node(</span><br><span class="line">            package=<span class="string">&#x27;turtlesim&#x27;</span>,</span><br><span class="line">            namespace=<span class="string">&#x27;turtlesim2&#x27;</span>,</span><br><span class="line">            executable=<span class="string">&#x27;turtlesim_node&#x27;</span>,</span><br><span class="line">            name=<span class="string">&#x27;sim&#x27;</span></span><br><span class="line">        ),</span><br><span class="line">        Node(</span><br><span class="line">            package=<span class="string">&#x27;turtlesim&#x27;</span>,</span><br><span class="line">            executable=<span class="string">&#x27;mimic&#x27;</span>,</span><br><span class="line">            name=<span class="string">&#x27;mimic&#x27;</span>,</span><br><span class="line">            remappings=[</span><br><span class="line">                (<span class="string">&#x27;/input/pose&#x27;</span>, <span class="string">&#x27;/turtlesim1/turtle1/pose&#x27;</span>),</span><br><span class="line">                (<span class="string">&#x27;/output/cmd_vel&#x27;</span>, <span class="string">&#x27;/turtlesim2/turtle1/cmd_vel&#x27;</span>),</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>核心代码：</p>
<ul>
<li><strong>导入包：</strong></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> launch <span class="keyword">import</span> LaunchDescription</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> Node</span><br></pre></td></tr></table></figure></code></pre>
<blockquote>
<ul>
<li><p><strong>创建<code>generate_launch_description()</code>函数</strong></p></li>
<li><p><strong>编写<code>LaunchDescription</code></strong></p></li>
</ul>
</blockquote>
<pre><code>&gt;
&gt;</code></pre>
<ul>
<li>写入<code>Node</code><strong>节点对象</strong> &gt; &gt;
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Node(</span><br><span class="line">    package=<span class="string">&#x27;turtlesim&#x27;</span>,</span><br><span class="line">    executable=<span class="string">&#x27;mimic&#x27;</span>,</span><br><span class="line">            name=<span class="string">&#x27;mimic&#x27;</span>,</span><br><span class="line">            remappings=[</span><br><span class="line">              		(<span class="string">&#x27;/input/pose&#x27;</span>, <span class="string">&#x27;/turtlesim1/turtle1/pose&#x27;</span>),</span><br><span class="line">                	(<span class="string">&#x27;/output/cmd_vel&#x27;</span>, <span class="string">&#x27;/turtlesim2/turtle1/cmd_vel&#x27;</span>),</span><br><span class="line">            	]</span><br><span class="line">     )</span><br></pre></td></tr></table></figure></li>
</ul>
<h4
id="导入substitutions实现launch文件的参数配置">导入<code>substitutions</code>实现<code>launch</code>文件的参数配置</h4>
<h5 id="使用场景">使用场景</h5>
<blockquote>
<p>启动文件用于启动节点、服务和执行进程。这组操作可能有参数，这些参数会影响它们的行为。在描述可重用启动文件时，可以在参数中使用<code>substitutions</code>
，以提供更大的灵活性。<code>substitutions</code>是仅在启动描述执行期间计算的变量，可用于获取特定信息，如启动配置、环境变量或计算任意Python表达式</p>
</blockquote>
<h3
id="使用过程中的一些tip和注意事项">使用过程中的一些tip和注意事项</h3>
<h4 id="调用方法">调用方法</h4>
<ol type="1">
<li><p>可以在launch目录下直接调用xxx.py文件(注意要激活环境变量)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd launch</span><br><span class="line">ros2 launch turtlesim_mimic_launch.py</span><br></pre></td></tr></table></figure></li>
<li><p>也可以将其在功能包下下载到install文件夹下，如何使用如下形式调用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ros2 launch &lt;package_name&gt; &lt;launch_file_name&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="建议在package.xml中写入依赖">建议在package.xml中写入依赖</h4>
<p><img src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokeimage-20220815100951291.png" alt="image-20220815100951291" style="zoom:50%;" /></p>
<h2 id="executor相关">Executor相关</h2>
<h3 id="定义">定义</h3>
<p><code>excecute</code>是ros2中显式管理通许回调等事务的对象，一个<code>execute</code>通常会使用对应操作系统的一个或多个线程去处理<strong>话题</strong>、<strong>定时器
</strong>、<strong>服务</strong>、<strong>动作</strong>服务器等通讯过程的回调函数。</p>
<figure>
<img
src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokeexecutors_basic_principle.png"
alt="./ROS2常用代码段.assets/executors_basic_principle.png" />
<figcaption
aria-hidden="true">./ROS2常用代码段.assets/executors_basic_principle.png</figcaption>
</figure>
<h3 id="types-of-executors">Types of Executors</h3>
<figure>
<img
src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokegraphviz-c1160194dae16051e00be2abef23d0fce5e7c347.png"
alt="digraph Flatland" />
<figcaption aria-hidden="true">digraph Flatland</figcaption>
</figure>
<p>目前ros2提供了三种<code>executor</code>，分别为：</p>
<ol type="1">
<li><p><code>Single-Threaded Executor</code>：这是ros2<code>spin</code>方法默认的<code>exceutor</code>。</p>
<ul>
<li>可以动态的创建回调对象</li>
<li>互斥(串行)的执行各个回调函数</li>
</ul>
<blockquote>
<p>ros2中的<a
href="https://docs.ros.org/en/foxy/Concepts/About-Composition.html">components</a>使用的也是这种<code>executor</code></p>
</blockquote></li>
<li><p><code>Multi-Threaded Executor</code>：创建一系列可配置的线程从而允许同时处理多个消息和事件</p>
<ul>
<li>可以动态的创建回调对象</li>
<li>当调用配置为<code>Reentrant</code>的<code>Callback groups</code>时可以并行的处理的处理消息和事件</li>
</ul></li>
<li><p><code>Static Single-Threaded Executor</code></p>
<ul>
<li>其与<code>Single-Threaded Executor</code>最大的不同是仅可以在初始化的时候添加<strong>话题</strong>、<strong>定时器</strong>、<strong>服务</strong>、<strong>动作</strong>
服务器等通讯过程的回调函数。</li>
</ul>
<blockquote>
<p>其他两个方法会不断扫描现有的所有回调对象，而该<code>excutor</code>仅会在初始化时扫描一次，所以实际上可以添加新对象，只是没啥用而已</p>
</blockquote></li>
</ol>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rclcpp::Node::SharedPtr node1 = ...</span><br><span class="line">rclcpp::Node::SharedPtr node2 = ...</span><br><span class="line">rclcpp::Node::SharedPtr node3 = ...</span><br><span class="line"></span><br><span class="line">rclcpp::executors::StaticSingleThreadedExecutor executor;</span><br><span class="line">executor.<span class="built_in">add_node</span>(node1);</span><br><span class="line">executor.<span class="built_in">add_node</span>(node2);</span><br><span class="line">executor.<span class="built_in">add_node</span>(node2);</span><br><span class="line">executor.<span class="built_in">spin</span>();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处说明一个<code>executor</code>
可以同时服务多个节点，但这些节点是串行处理的，若想实现真正的并行化处理，需要使用创建<code>Multi-Threaded Executor</code>
，并调用<code>callback groups</code></p>
</blockquote>
<h3 id="callback-groups">Callback groups</h3>
<h4 id="种类">种类</h4>
<ul>
<li><code>Mutually exclusive</code>:Callbacks of this group must not be
executed in parallel.</li>
<li><code>Reentrant</code>: Callbacks of this group may be executed in
parallel.</li>
</ul>
<blockquote>
<p>ros2默认使用使用<code>Mutually exclusive</code>，我们可以可以通过cpp调用<code>NodeBaseInterface::get_default_callback_group()</code>
或python调用<code>Node.default_callback_group</code>查看默认的<code>Callback groups</code></p>
</blockquote>
<h4 id="使用方法">使用方法</h4>
<h5 id="c">c++</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">my_callback_group = <span class="built_in">create_callback_group</span>(rclcpp::CallbackGroupType::MutuallyExclusive);</span><br><span class="line"></span><br><span class="line">rclcpp::SubscriptionOptions options;</span><br><span class="line">options.callback_group = my_callback_group;</span><br><span class="line"></span><br><span class="line">my_subscription = <span class="built_in">create_subscription</span>&lt;Int32&gt;(<span class="string">&quot;/topic&quot;</span>, rclcpp::<span class="built_in">SensorDataQoS</span>(),</span><br><span class="line">                                             callback, options);</span><br></pre></td></tr></table></figure>
<h5 id="python-3">python</h5>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_callback_group = MutuallyExclusiveCallbackGroup()</span><br><span class="line">my_subscription = self.create_subscription(Int32, <span class="string">&quot;/topic&quot;</span>, self.callback, qos_profile=<span class="number">1</span>,</span><br><span class="line">                                           callback_group=my_callback_group)</span><br></pre></td></tr></table></figure>
<h4 id="额外说明">额外说明</h4>
<blockquote>
<p>简而言之就是可以调用<code>executor</code>的<code>add_callback_group</code>方法，实现一个节点的回调多次并行调用，且可以通过操作系统的线程配置优先级</p>
</blockquote>
<p>Since Galactic, the interface of the Executor base class in rclcpp
has been refined by a new function <code>add_callback_group(..)</code>.
This allows distributing callback groups to different Executors. By
configuring the underlying threads using the operating system scheduler,
specific callbacks can be prioritized over other callbacks. For example,
the subscriptions and timers of a control loop can be prioritized over
all other subscriptions and standard services of a node. The <a
href="https://github.com/ros2/examples/tree/foxy/rclcpp/executors/cbg_executor">examples_rclcpp_cbg_executor
package</a> provides a demo of this mechanism.</p>
<h3 id="默认处理顺序">默认处理顺序</h3>
<figure>
<img
src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokeexecutors_scheduling_semantics.png"
alt="../_images/executors_scheduling_semantics.png" />
<figcaption
aria-hidden="true">../_images/executors_scheduling_semantics.png</figcaption>
</figure>
<ul>
<li>如果回调的处理时间小于设定的周期，则使用队列进行事件调度</li>
<li>如果回调的时间大于设定的周期，则使用压栈的方式进行调度</li>
</ul>
<h3 id="与ros1的区别与联系">与ROS1的区别与联系</h3>
<ol type="1">
<li>在ros1中我们使用<code>spin</code>函数进行调度管理，而ros2中的<code>executor</code>提供了更多可控的执行机制，但其基本API与ros1十分相似</li>
<li>在ros2中，<code>executor</code>负责创建线程与<code>rcl</code>以及<code>middleware layers</code>进行轮询处理。为了保证不与通讯中间件的<code>Qos</code>
设置发生冲突，<code>executor</code>不会将到来的消息存储在<code>Client Library layer</code>的队列当中，而是存放在<code>middleware</code>
中直到该消息被回调函数处理(<strong>这是ros2与ros1最显著的不同之一</strong>)。ros2会创建一个使用二进制标识符(flag)标识的<code>wait set</code>
来说明某个消息是否需要使用回调函数处理。</li>
</ol>
<h3 id="使用方法-1">使用方法</h3>
<h4 id="最简单的使用程序">最简单的使用程序</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Some initialization.</span></span><br><span class="line">   rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate a node.</span></span><br><span class="line">   rclcpp::Node::SharedPtr node = ...</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Run the executor.</span></span><br><span class="line">   rclcpp::<span class="built_in">spin</span>(node);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Shutdown and exit.</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在这里我们像ros1中调用了<code>spin</code>函数，但其执行过程与ros1不同，在ros2中，spin函数会默认生成一个<code>SingleThreadedExecutor</code>
的<code>executor</code>，并调用该<code>executor</code>中的<code>spin</code>方法进行消息检测和回调处理</p></li>
<li><p>等效于下列代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rclcpp::executors::SingleThreadedExecutor executor;</span><br><span class="line">executor.<span class="built_in">add_node</span>(node);</span><br><span class="line">executor.<span class="built_in">spin</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="components">Components</h2>
<h3 id="介绍">介绍</h3>
<blockquote>
<p>ros2中关于ros1<code>nodelet</code>的替代品，保证了接口的统一，使得若干节点运行在<strong>同一进程内</strong>！</p>
<p>ros中实现多个节点的通讯有两种方案：</p>
<ol type="1">
<li>第一种是每个node定义在单独的进程中，这样有助于异常追踪，资源分配，错误隔离</li>
<li>另一种是将若干节点定义在一个进程中，这样有助于获得更低的通讯开销，提高通讯效率</li>
</ol>
</blockquote>
<blockquote>
<ul>
<li>本质是创建了一个<code>Single-Threaded Executor</code>在<code>component-manager</code>
当中，该容器管理器可以动态的加载以动态库形式生成的<code>node</code>，如果node的开启了<code>use_intra_process_comms</code>
（默认传递的nodeoption并未开启），则可以实现线程内通讯(零拷贝！)</li>
<li>即使不是零拷贝，因为使用该方法实现的是线程间通讯，其开销比正常的进程间通讯要小</li>
</ul>
</blockquote>
<h3 id="使用方法-2">使用方法</h3>
<h4 id="命令行调用">命令行调用</h4>
<ol type="1">
<li><p>创建<code>容器管理节点</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ros2 run rclcpp_components component_container</span><br></pre></td></tr></table></figure>
<ul>
<li>这会创建一个名为<code>/ComponentManager</code>的节点，如果要创建多个节点，记得使用<code>ros-arg __name=new_name</code>来对节点进行重命名(
ros2中节点重名好像并不会报错～)</li>
<li>可以使用<code>ros2 component list</code>来查看所以的管理容器</li>
</ul></li>
<li><p>加载节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// ros2 componet load 管理容器名字 动态库所在功能包名字 待加载的节点类(需要加上命名空间)</span><br><span class="line">ros2 component load /ComponentManager composition composition::Talker</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用<code>ros2 component types</code>来查看当前可以调用的动态节点类</li>
<li>一旦<code>load</code>之后，节点相关的代码会在<code>容器管理节点中开始运行</code></li>
</ul></li>
</ol>
<h4 id="使用代码的方式调">使用代码的方式调</h4>
<blockquote>
<p>本质上就是加载动态链接库，然后自己编写<code>SingleThreadedExecutor</code>调用这些节点</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 2016 Open Source Robotics Foundation, Inc.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">// you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">// You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">// See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">// limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;composition/client_component.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;composition/listener_component.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;composition/talker_component.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;composition/server_component.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Force flush of the stdout buffer.</span></span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout, <span class="literal">NULL</span>, _IONBF, BUFSIZ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize any global resources needed by the middleware and the client library.</span></span><br><span class="line">  <span class="comment">// This will also parse command line arguments one day (as of Beta 1 they are not used).</span></span><br><span class="line">  <span class="comment">// You must call this before using any other part of the ROS system.</span></span><br><span class="line">  <span class="comment">// This should be called once per process.</span></span><br><span class="line">  rclcpp::<span class="built_in">init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an executor that will be responsible for execution of callbacks for a set of nodes.</span></span><br><span class="line">  <span class="comment">// With this version, all callbacks will be called from within this thread (the main one).</span></span><br><span class="line">  rclcpp::executors::SingleThreadedExecutor exec;</span><br><span class="line">  rclcpp::NodeOptions options;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add some nodes to the executor which provide work for the executor during its &quot;spin&quot; function.</span></span><br><span class="line">  <span class="comment">// An example of available work is executing a subscription callback, or a timer callback.</span></span><br><span class="line">  <span class="keyword">auto</span> talker = std::<span class="built_in">make_shared</span>&lt;composition::Talker&gt;(options);</span><br><span class="line">  exec.<span class="built_in">add_node</span>(talker);</span><br><span class="line">  <span class="keyword">auto</span> listener = std::<span class="built_in">make_shared</span>&lt;composition::Listener&gt;(options);</span><br><span class="line">  exec.<span class="built_in">add_node</span>(listener);</span><br><span class="line">  <span class="keyword">auto</span> server = std::<span class="built_in">make_shared</span>&lt;composition::Server&gt;(options);</span><br><span class="line">  exec.<span class="built_in">add_node</span>(server);</span><br><span class="line">  <span class="keyword">auto</span> client = std::<span class="built_in">make_shared</span>&lt;composition::Client&gt;(options);</span><br><span class="line">  exec.<span class="built_in">add_node</span>(client);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// spin will block until work comes in, execute work as it becomes available, and keep blocking.</span></span><br><span class="line">  <span class="comment">// It will only be interrupted by Ctrl-C.</span></span><br><span class="line">  exec.<span class="built_in">spin</span>();</span><br><span class="line"></span><br><span class="line">  rclcpp::<span class="built_in">shutdown</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用路径加载的方式调用">使用路径加载的方式调用</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ros2 run composition dlopen_composition `ros2 pkg prefix composition`/lib/libtalker_component.so `ros2 pkg prefix composition`/lib/liblistener_component.so</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处<code>ros2 pkg prefix composition</code>是调用ros2的cli查看<code>composition</code>的路径并和后续的库相对路径进行拼接形成绝对地址</p>
</blockquote>
<h4 id="使用launch加载">使用launch加载</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Launch a talker and a listener in a component container.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> launch</span><br><span class="line"><span class="keyword">from</span> launch_ros.actions <span class="keyword">import</span> ComposableNodeContainer</span><br><span class="line"><span class="keyword">from</span> launch_ros.descriptions <span class="keyword">import</span> ComposableNode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_launch_description</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Generate launch description with multiple components.&quot;&quot;&quot;</span></span><br><span class="line">    container = ComposableNodeContainer(</span><br><span class="line">            name=<span class="string">&#x27;my_container&#x27;</span>,</span><br><span class="line">            namespace=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            package=<span class="string">&#x27;rclcpp_components&#x27;</span>,</span><br><span class="line">            executable=<span class="string">&#x27;component_container&#x27;</span>,</span><br><span class="line">            composable_node_descriptions=[</span><br><span class="line">                ComposableNode(</span><br><span class="line">                    package=<span class="string">&#x27;composition&#x27;</span>,</span><br><span class="line">                    plugin=<span class="string">&#x27;composition::Talker&#x27;</span>,</span><br><span class="line">                    name=<span class="string">&#x27;talker&#x27;</span>),</span><br><span class="line">                ComposableNode(</span><br><span class="line">                    package=<span class="string">&#x27;composition&#x27;</span>,</span><br><span class="line">                    plugin=<span class="string">&#x27;composition::Listener&#x27;</span>,</span><br><span class="line">                    name=<span class="string">&#x27;listener&#x27;</span>)</span><br><span class="line">            ],</span><br><span class="line">            output=<span class="string">&#x27;screen&#x27;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> launch.LaunchDescription([container])</span><br></pre></td></tr></table></figure>
<h3 id="编写component动态库">编写Component动态库</h3>
<blockquote>
<p>以component实现线程内零拷贝例子进行说明(<a
href="https://github.com/ros2/demos/tree/humble/composition">参考代码</a>)</p>
</blockquote>
<h4
id="创建功能包加上rclcpp_components的依赖">创建功能包，加上<code>rclcpp_components</code>的依赖</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_cmake --dependencies rclcpp std_msgs rclcpp_components --destination-directory src/ --library-name produce_node intra_process_container</span><br></pre></td></tr></table></figure>
<ul>
<li>此处建议使用<code>—library-name</code>参数自动生成模板库文件，其中包括相应的cmakelist写法</li>
</ul>
<h4
id="编写component-node库文件线程间零拷贝通讯">编写<code>component node</code>库文件(线程间零拷贝通讯)</h4>
<blockquote>
<p>此处需注意以下内容：</p>
<ol type="1">
<li><p>若想实现线程间通讯，需要在创建节点时开启<code>use_intra_process_comms</code></p></li>
<li><p>若想实现线程间零拷贝，需要使用<code>uintptr_t</code>发布<code>msg</code>，并接受<code>uintptr_t</code>的<code>msg</code></p></li>
<li><p>线程间通讯若想实现零拷贝，必须是同一个<code>execute</code>执行零拷贝相关的所有节点</p></li>
<li><p>生成动态节点类的库文件不需要写<code>main</code>函数，最后要包含<code>#include "rclcpp_components/register_node_macro.hpp"</code>
头文件，并且导出相应的类</p></li>
</ol>
</blockquote>
<pre><code> &gt;
 &gt;    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RCLCPP_COMPONENTS_REGISTER_NODE(命名空间::类名)</span></span><br><span class="line"><span class="built_in">RCLCPP_COMPONENTS_REGISTER_NODE</span>(intra_process_demo::Consumer)</span><br></pre></td></tr></table></figure></code></pre>
<blockquote>

</blockquote>
<h5 id="消费者">消费者</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cinttypes&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/msg/int32.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="keyword">namespace</span> intra_process_demo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Consumer</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Consumer</span>(<span class="type">const</span> rclcpp::NodeOptions &amp;options)</span><br><span class="line">            : <span class="built_in">Node</span>(<span class="string">&quot;consumer&quot;</span>, rclcpp::<span class="built_in">NodeOptions</span>().<span class="built_in">use_intra_process_comms</span>(<span class="literal">true</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Create a subscription on the input topic which prints on receipt of new messages.</span></span><br><span class="line">            sub_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_subscription</span>&lt;std_msgs::msg::Int32&gt;(</span><br><span class="line">                <span class="string">&quot;number&quot;</span>,</span><br><span class="line">                <span class="number">10</span>,</span><br><span class="line">                [<span class="keyword">this</span>](std_msgs::msg::Int32::UniquePtr msg)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(</span><br><span class="line">                        <span class="string">&quot;%s Receive message with value: %d, and address: 0x%&quot;</span> PRIXPTR <span class="string">&quot;\n&quot;</span>, <span class="keyword">this</span>-&gt;<span class="built_in">get_name</span>(), msg-&gt;data,</span><br><span class="line">                        <span class="built_in">reinterpret_cast</span>&lt;std::<span class="type">uintptr_t</span>&gt;(msg.<span class="built_in">get</span>()));</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        rclcpp::Subscription&lt;std_msgs::msg::Int32&gt;::SharedPtr sub_;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// namespace intra_process_container</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp_components/register_node_macro.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the component with class_loader.</span></span><br><span class="line"><span class="comment">// This acts as a sort of entry point, allowing the component to be discoverable when its library</span></span><br><span class="line"><span class="comment">// is being loaded into a running process.</span></span><br><span class="line"><span class="built_in">RCLCPP_COMPONENTS_REGISTER_NODE</span>(intra_process_demo::Consumer)</span><br></pre></td></tr></table></figure>
<h5 id="生产者">生产者</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cinttypes&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp/rclcpp.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_msgs/msg/int32.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line"><span class="keyword">namespace</span> intra_process_demo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Producer</span> : <span class="keyword">public</span> rclcpp::Node</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Producer</span>(<span class="type">const</span> rclcpp::NodeOptions &amp;options)</span><br><span class="line">            : <span class="built_in">Node</span>(<span class="string">&quot;process&quot;</span>, rclcpp::<span class="built_in">NodeOptions</span>().<span class="built_in">use_intra_process_comms</span>(<span class="literal">true</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Create a publisher on the output topic.</span></span><br><span class="line">            pub_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_publisher</span>&lt;std_msgs::msg::Int32&gt;(<span class="string">&quot;number&quot;</span>, <span class="number">10</span>);</span><br><span class="line">            std::weak_ptr&lt;std::remove_pointer&lt;<span class="keyword">decltype</span>(pub_.<span class="built_in">get</span>())&gt;::type&gt; captured_pub = pub_;</span><br><span class="line">            <span class="comment">// Create a timer which publishes on the output topic at ~1Hz.</span></span><br><span class="line">            <span class="keyword">auto</span> callback = [captured_pub, <span class="keyword">this</span>]() -&gt; <span class="type">void</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> pub_ptr = captured_pub.<span class="built_in">lock</span>();</span><br><span class="line">                <span class="keyword">if</span> (!pub_ptr)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">static</span> <span class="type">int32_t</span> count = <span class="number">0</span>;</span><br><span class="line">                std_msgs::msg::<span class="function">Int32::UniquePtr <span class="title">msg</span><span class="params">(<span class="keyword">new</span> std_msgs::msg::Int32())</span></span>;</span><br><span class="line">                msg-&gt;data = count++;</span><br><span class="line">                <span class="built_in">printf</span>(</span><br><span class="line">                    <span class="string">&quot;%s Published message with value: %d, and address: 0x%&quot;</span> PRIXPTR <span class="string">&quot;\n&quot;</span>, <span class="keyword">this</span>-&gt;<span class="built_in">get_name</span>(), msg-&gt;data,</span><br><span class="line">                    <span class="built_in">reinterpret_cast</span>&lt;std::<span class="type">uintptr_t</span>&gt;(msg.<span class="built_in">get</span>()));</span><br><span class="line">                pub_ptr-&gt;<span class="built_in">publish</span>(std::<span class="built_in">move</span>(msg));</span><br><span class="line">            &#125;;</span><br><span class="line">            timer_ = <span class="keyword">this</span>-&gt;<span class="built_in">create_wall_timer</span>(<span class="number">1</span>s, callback);</span><br><span class="line">        &#125;</span><br><span class="line">        rclcpp::Publisher&lt;std_msgs::msg::Int32&gt;::SharedPtr pub_;</span><br><span class="line">        rclcpp::TimerBase::SharedPtr timer_;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rclcpp_components/register_node_macro.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the component with class_loader.</span></span><br><span class="line"><span class="comment">// This acts as a sort of entry point, allowing the component to be discoverable when its library</span></span><br><span class="line"><span class="comment">// is being loaded into a running process.</span></span><br><span class="line"><span class="built_in">RCLCPP_COMPONENTS_REGISTER_NODE</span>(intra_process_demo::Producer)</span><br></pre></td></tr></table></figure>
<h4 id="cmakelist">CmakeList</h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.8</span>)</span><br><span class="line"><span class="keyword">project</span>(intra_process_container)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CMAKE_COMPILER_IS_GNUCXX <span class="keyword">OR</span> CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;Clang&quot;</span>)</span><br><span class="line">  <span class="keyword">add_compile_options</span>(-Wall -Wextra -Wpedantic)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># find dependencies</span></span><br><span class="line"><span class="keyword">find_package</span>(ament_cmake REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(ament_cmake_ros REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(rclcpp REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(std_msgs REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(rclcpp_components REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(produce_node SHARED src/produce_node.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(produce_node PUBLIC c_std_99 cxx_std_17)  <span class="comment"># Require C99 and C++17</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(produce_node PUBLIC</span><br><span class="line">  $&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>&gt;</span><br><span class="line">  $&lt;INSTALL_INTERFACE:<span class="keyword">include</span>&gt;)</span><br><span class="line">ament_target_dependencies(</span><br><span class="line">  produce_node</span><br><span class="line">  <span class="string">&quot;rclcpp&quot;</span></span><br><span class="line">  <span class="string">&quot;std_msgs&quot;</span></span><br><span class="line">  <span class="string">&quot;rclcpp_components&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># Causes the visibility macros to use dllexport rather than dllimport,</span></span><br><span class="line"><span class="comment"># which is appropriate when building the dll but not consuming it.</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(produce_node PRIVATE <span class="string">&quot;INTRA_PROCESS_CONTAINER_BUILDING_LIBRARY&quot;</span>)</span><br><span class="line">rclcpp_components_register_nodes(produce_node <span class="string">&quot;intra_process_demo::Producer&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(consumer_node SHARED src/consumer_node.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(consumer_node PUBLIC c_std_99 cxx_std_17)  <span class="comment"># Require C99 and C++17</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(consumer_node PUBLIC</span><br><span class="line">  $&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>&gt;</span><br><span class="line">  $&lt;INSTALL_INTERFACE:<span class="keyword">include</span>&gt;)</span><br><span class="line">ament_target_dependencies(</span><br><span class="line">  consumer_node</span><br><span class="line">  <span class="string">&quot;rclcpp&quot;</span></span><br><span class="line">  <span class="string">&quot;std_msgs&quot;</span></span><br><span class="line">  <span class="string">&quot;rclcpp_components&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># Causes the visibility macros to use dllexport rather than dllimport,</span></span><br><span class="line"><span class="comment"># which is appropriate when building the dll but not consuming it.</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(consumer_node PRIVATE <span class="string">&quot;INTRA_PROCESS_CONTAINER_BUILDING_LIBRARY&quot;</span>)</span><br><span class="line">rclcpp_components_register_nodes(consumer_node <span class="string">&quot;intra_process_demo::Consumer&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  DIRECTORY <span class="keyword">include</span>/</span><br><span class="line">  DESTINATION <span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  TARGETS produce_node</span><br><span class="line">  <span class="keyword">EXPORT</span> export_<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  ARCHIVE DESTINATION lib</span><br><span class="line">  LIBRARY DESTINATION lib</span><br><span class="line">  RUNTIME DESTINATION bin</span><br><span class="line">)</span><br><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  TARGETS consumer_node</span><br><span class="line">  <span class="keyword">EXPORT</span> export_<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  ARCHIVE DESTINATION lib</span><br><span class="line">  LIBRARY DESTINATION lib</span><br><span class="line">  RUNTIME DESTINATION bin</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span>(BUILD_TESTING)</span><br><span class="line">  <span class="keyword">find_package</span>(ament_lint_auto REQUIRED)</span><br><span class="line">  <span class="comment"># the following line skips the linter which checks for copyrights</span></span><br><span class="line">  <span class="comment"># comment the line when a copyright and license is added to all source files</span></span><br><span class="line">  <span class="keyword">set</span>(ament_cmake_copyright_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line">  <span class="comment"># the following line skips cpplint (only works in a git repo)</span></span><br><span class="line">  <span class="comment"># comment the line when this package is in a git repo and when</span></span><br><span class="line">  <span class="comment"># a copyright and license is added to all source files</span></span><br><span class="line">  <span class="keyword">set</span>(ament_cmake_cpplint_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line">  ament_lint_auto_find_test_dependencies()</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">ament_export_include_directories(</span><br><span class="line">  <span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line">ament_export_libraries(</span><br><span class="line">  produce_node</span><br><span class="line">)</span><br><span class="line">ament_export_libraries(</span><br><span class="line">  consumer_node</span><br><span class="line">)</span><br><span class="line">ament_export_targets(</span><br><span class="line">  export_<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ament_package()</span><br></pre></td></tr></table></figure>
<h5 id="关键内容">关键内容</h5>
<ol type="1">
<li><p>找到依赖包</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find dependencies</span></span><br><span class="line"><span class="keyword">find_package</span>(ament_cmake REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(ament_cmake_ros REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(rclcpp REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(std_msgs REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(rclcpp_components REQUIRED)</span><br></pre></td></tr></table></figure></li>
<li><p>生成动态库，并关联依赖</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(produce_node SHARED src/produce_node.cpp)</span><br><span class="line"><span class="keyword">target_compile_features</span>(produce_node PUBLIC c_std_99 cxx_std_17)  <span class="comment"># Require C99 and C++17</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(produce_node PUBLIC</span><br><span class="line">  $&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>&gt;</span><br><span class="line">  $&lt;INSTALL_INTERFACE:<span class="keyword">include</span>&gt;)</span><br><span class="line">ament_target_dependencies(</span><br><span class="line">  produce_node</span><br><span class="line">  <span class="string">&quot;rclcpp&quot;</span></span><br><span class="line">  <span class="string">&quot;std_msgs&quot;</span></span><br><span class="line">  <span class="string">&quot;rclcpp_components&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># Causes the visibility macros to use dllexport rather than dllimport,</span></span><br><span class="line"><span class="comment"># which is appropriate when building the dll but not consuming it.</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(produce_node PRIVATE <span class="string">&quot;INTRA_PROCESS_CONTAINER_BUILDING_LIBRARY&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>导出<code>component node</code></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">rclcpp_components_register_nodes(produce_node <span class="string">&quot;intra_process_demo::Producer&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>下载库和依赖文件</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  DIRECTORY <span class="keyword">include</span>/</span><br><span class="line">  DESTINATION <span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  TARGETS produce_node</span><br><span class="line">  <span class="keyword">EXPORT</span> export_<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  ARCHIVE DESTINATION lib</span><br><span class="line">  LIBRARY DESTINATION lib</span><br><span class="line">  RUNTIME DESTINATION bin</span><br><span class="line">)</span><br><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  TARGETS consumer_node</span><br><span class="line">  <span class="keyword">EXPORT</span> export_<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">  ARCHIVE DESTINATION lib</span><br><span class="line">  LIBRARY DESTINATION lib</span><br><span class="line">  RUNTIME DESTINATION bin</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>导出ament依赖(方便其他包依赖当前功能包的时候可以找到当前功能包所依赖的文件或库)</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">ament_export_include_directories(</span><br><span class="line">  <span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line">ament_export_libraries(</span><br><span class="line">  produce_node</span><br><span class="line">)</span><br><span class="line">ament_export_libraries(</span><br><span class="line">  consumer_node</span><br><span class="line">)</span><br><span class="line">ament_export_targets(</span><br><span class="line">  export_<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ament_package()</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>ROS2</category>
      </categories>
      <tags>
        <tag>ROS2</tag>
      </tags>
  </entry>
  <entry>
    <title>Clion调试Ros2</title>
    <url>/undefined/e5334e9d/</url>
    <content><![CDATA[<h1 id="clion调试ros2">Clion调试Ros2</h1>
<h2 id="创建一个ros2工程">1. 创建一个Ros2工程</h2>
<p>创建文件夹<code>dev_ws/src</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ros2_ws/src</span><br><span class="line"><span class="built_in">cd</span> dev_ws/src</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>创建一个发布者和订阅者包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ros2 pkg create --build-type ament_cmake cpp_pubsub</span><br></pre></td></tr></table></figure>
<p>完成节点的代码编写，在工作空间中我们可以看到如下的目录结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">|_dev_ws</span><br><span class="line">   |_src</span><br><span class="line">      |_cpp_pubsub</span><br><span class="line">         |_include</span><br><span class="line">         |_src</span><br><span class="line">               subscriber_member_function.cpp</span><br><span class="line">               publisher_member_function.cpp</span><br><span class="line">           CMakeLists.txt</span><br><span class="line">           package.xml</span><br></pre></td></tr></table></figure>
<h2 id="在clion中打开工程">2. 在Clion中打开工程</h2>
<ol type="1">
<li>在<code>dev_ws</code>目录下执行构建命令</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">colcon build \</span><br><span class="line">        --symlink-install \</span><br><span class="line">        --cmake-args <span class="string">&quot;-DCMAKE_EXPORT_COMPILE_COMMANDS=On&quot;</span> \</span><br><span class="line">        -G Ninja \</span><br><span class="line">        -Wall -Wextra -Wpedantic</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>在Clion中打开工程，选择<code>dev_ws</code>目录，然后选择<code>File</code>-&gt;<code>Open</code>-&gt;<code>ros2_ws</code>，然后选择<code>File</code>-&gt;<code>Open</code>-&gt;<code>dev_ws</code>-&gt;<code>build</code>-&gt;<code>compile_commands.json</code>。
<img src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokeimg.png"
alt="img.png" /></p></li>
<li><p>然后点击<code>Open as Project</code>，Clion会自动加载工程。</p></li>
</ol>
<figure>
<img
src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokecl_ros2_compdb_open_as_prj.png"
alt="Open compDB as project" />
<figcaption aria-hidden="true">Open compDB as project</figcaption>
</figure>
<ol start="4" type="1">
<li><p>检查项目是否加载成功，如图 <img
src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokecl_ros2_load_initial.png"
alt="Initial loading of a ROS2 workspace" /></p></li>
<li><p>默认情况下，CLions将包含compile_commons.json文件的目录视为项目根目录。在我们的例子中，它是<code>Build</code>目录，为了获得正确的项目结构，我们需要将项目根设置为实际的工作区目录。</p>
<ol type="1">
<li>点击 Tools | Compilation Database | Change Project Root from the
main menu and select the workspace directory (dev_ws in our case).</li>
<li>弹出目录选择对话框，选择<code>dev_ws</code>目录，然后点击<code>OK</code>。</li>
</ol></li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a
href="https://www.jetbrains.com/help/clion/ros2-tutorial.html#run-debug-pkg">Clion调试Ros2</a></li>
</ul>
]]></content>
      <categories>
        <category>Robot</category>
        <category>ROS2</category>
        <category>Clion</category>
      </categories>
      <tags>
        <tag>Robot</tag>
        <tag>ROS2</tag>
        <tag>Clion</tag>
      </tags>
  </entry>
  <entry>
    <title>基于dapr和yarp网关实现分布式多语言后端系统</title>
    <url>/undefined/df159cc/</url>
    <content><![CDATA[<h1 id="项目背景">项目背景</h1>
<p>传统的后端项目开发会与开发平台以及开发语言强绑定，这使得项目合作过程要求新加入的合作者必须掌握相同的技术栈，具有一定的团队磨合成本和学习成本。</p>
<p>在微服务架构盛行的当下，复杂的后端服务可以使用领域驱动设计的方式可以拆解为若干相互独立的微服务模块，如电商系统中的订单服务、支付服务、库存服务等。这种方式可以使得团队成员可以专注于自己擅长的领域，提高开发效率。</p>
<p>但是，微服务架构也带来了新的问题，如服务间的通信、服务发现、负载均衡、服务治理等。这些问题在传统的单体应用中都有现成的解决方案，但是在微服务架构中，这些问题变得更加复杂。</p>
<p>进一步，当面临权限校验，日志记录，监控等通用功能时，传统的解决方案往往需要在每个服务中重复实现，这不仅增加了开发成本，也增加了维护成本。</p>
<p>为了解决这些问题，使得不同服务的开发者可以使用自己熟悉的技术栈专注于自己的业务逻辑，同时又能够享受到微服务架构的优势，需要一个通用的解决方案。而这个解决方案就是dapr。</p>
<span id="more"></span>
<h2 id="dapr">Dapr</h2>
<p><a
href="https://docs.dapr.io/"><strong>Dapr</strong></a>是一个开源的分布式应用运行时，它提供了一系列的微服务开发的基础设施，如服务发现、负载均衡、服务间通信等。
使用Dapr，可以逐步将现有的应用程序迁移到微服务架构，从而采用云原生模式，如横向扩展、复原能力和独立部署。
Dapr 是平台无关的，这意味着您可以运行您的应用程序：</p>
<ul>
<li>本地</li>
<li>在任何 Kubernetes 集群上</li>
<li>在虚拟机或物理机上</li>
<li>在其他 Dapr 集成的托管环境中。</li>
</ul>
<p>这使您能够构建可在云和边缘上运行的微服务应用程序。</p>
<p><img
src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokeoverview.png"
alt="img" /> Dapr 以 sidecar 架构的方式公开其 HTTP 和 gRPC
API，无论是作为容器还是作为进程，不需要应用代码包含任何 Dapr
运行时代码。 这使得 Dapr
与其他运行时的集成变得容易，同时也提供了应用逻辑的分离，改善可支持性。
&gt; ### 什么是sidecar模式？ &gt; sidecar &gt;
模式是一种软件设计模式，它将应用程序的核心功能与附加功能分离开来。在这种模式下，附加功能作为一个独立的进程运行，与主进程共享同一个主机。这种模式的优点是可以在不修改主进程的情况下，为应用程序添加新的功能，同时也可以提高应用程序的可维护性和可扩展性。
&gt; &gt;
通俗理解就是，sidecar模式就是在应用程序的旁边（sidecar）运行一个辅助进程，这个辅助进程负责提供一些额外的功能，如日志记录、监控、负载均衡等。这样，应用程序就可以专注于自己的业务逻辑，而不用关心这些额外的功能。可以类比为一辆自行车，sidecar就是那个附加的车厢，负责提供额外的功能。</p>
<figure>
<img
src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokeoverview-sidecar-model.png"
alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="dapr提供的微服构建块">Dapr提供的微服构建块</h3>
<p><img
src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokebuilding_blocks.png"
alt="img" />
如图所示，Dapr提供了一系列的微服务构建块，各模块的功能如下：</p>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 94%" />
</colgroup>
<thead>
<tr class="header">
<th>构建块</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>服务之间的调用</td>
<td>服务间调用允许进行远程方法调用(包括重试)，无论远程服务处于任何位置，只需该服务托管于受支持的环境即可。</td>
</tr>
<tr class="even">
<td>状态管理</td>
<td>通过采用存储和查询键/值对机制的状态管理，可以轻松的使长时运行、高可用的有状态服务和无状态服务共同运行在您的应用程序中。
状态存储是可插拔的，示例包括AWS DynamoDB、Azure CosmosDB、Azure SQL
Server、GCP Firebase、PostgreSQL或Redis，等等。</td>
</tr>
<tr class="odd">
<td>发布和订阅</td>
<td>在服务之间发布事件和订阅主题，使事件驱动的架构能够简化水平可伸缩性，并使其能够灵活应对故障。
Dapr 提供至少一次的消息传递保证，消息TTL，消费者组等高级功能。</td>
</tr>
<tr class="even">
<td>资源绑定</td>
<td>通过接收和发送事件到任何外部来源，如数据库、队列、文件系统等，带触发器的资源绑定进一步加强了事件驱动架构的规模和弹性。</td>
</tr>
<tr class="odd">
<td>Actors</td>
<td>一种用于有状态和无状态对象的模式，它通过对方法和状态的封装使并发变得简单。
Dapr 在 Actor 模式中提供了很多功能，包括并发，状态管理，用于 actor
激活/停用的生命周期管理，以及唤醒 actor 的计时器和提醒器。</td>
</tr>
<tr class="even">
<td>secrets</td>
<td>Dapr 提供了密钥管理，支持与公有云和本地的 Secret
存储集成，以供应用检索使用。</td>
</tr>
<tr class="odd">
<td>配置</td>
<td>配置 API 使您能够从配置存储中检索和订阅应用程序配置项。</td>
</tr>
<tr class="even">
<td>分布式锁</td>
<td>分布式锁 API
使应用程序能够获取任何资源的锁，该资源会授予其独占访问权限，直到应用程序释放锁或发生租约超时。</td>
</tr>
<tr class="odd">
<td>工作流程</td>
<td>工作流 API 可以与其他 Dapr 构建块结合使用，做到使用 Dapr
工作流或工作流组件定义跨多个微服务的长时间运行的持久进程或数据流。</td>
</tr>
<tr class="even">
<td>密码学</td>
<td>加密 API 在密钥保管库等安全基础结构之上提供抽象层。
它包含允许您执行加密操作（例如加密和解密消息）的
API，而无需向应用程序公开密钥。</td>
</tr>
</tbody>
</table>
<h3 id="dapr的部署和托管方式">Dapr的部署和托管方式</h3>
<p>Dapr 可以托管在多个环境中，包括：</p>
<ul>
<li>自托管在 Windows/Linux/macOS 计算机上，用于本地开发</li>
<li>在 Kubernetes 或生产中的物理或虚拟机集群上</li>
</ul>
<p>在自托管模式，Dapr作为一个独立的sidecar进程运行，你的服务代码可以通过HTTP或gRPC调用。
每个运行的服务都有一个 Dapr 运行时进程 (或 sidecar)
，配置为使用状态存储， pub/sub，绑定组件和其他构建块。</p>
<figure>
<img
src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokeoverview-standalone.png"
alt="Architecture diagram of Dapr in self-hosted mode" />
<figcaption aria-hidden="true">Architecture diagram of Dapr in
self-hosted mode</figcaption>
</figure>
<p>在 Kubernetes 中，Dapr 以 sidecar 模式运行，这意味着 Dapr
运行时作为一个 sidecar 容器与应用程序容器一起运行。 这种模式使 Dapr
与应用程序的集成变得非常简单，同时也提供了应用程序逻辑的分离，从而提高了可支持性。</p>
<figure>
<img
src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokeoverview-kubernetes.png"
alt="Architecture diagram of Dapr in Kubernetes mode" />
<figcaption aria-hidden="true">Architecture diagram of Dapr in
Kubernetes mode</figcaption>
</figure>
<h3 id="dapr支持的语言">Dapr支持的语言</h3>
<p>Dapr可以使用HTTP或gRPC与任何语言的应用程序集成。 Dapr
运行时提供了用于与 Dapr API 通信的客户端 SDK，这些 SDK
可以在任何语言中使用。 Dapr 还提供了用于与 Dapr API 通信的 CLI
工具，这些工具可以在任何语言中使用。 当前，Dapr提供了以下语言的SDK：</p>
<ul>
<li>Go</li>
<li>Java</li>
<li>JavaScript</li>
<li>.NET</li>
<li>PHP</li>
<li>Python</li>
</ul>
<p>这些 SDK 通过特定语言 API 来暴露 Dapr 构建块的功能，而不是调用
http/gRPC API。 这使您能够用您选择的语言编写无状态和有状态函数以及 Actor
的组合。 由于这些 SDK 共享 Dapr 运行时，因此可以获得跨语言的 actor
和功能支持。</p>
<h2 id="yarp">yarp</h2>
<figure>
<img
src="https://dl-poke.oss-cn-beijing.aliyuncs.com/poke1*-vJjmtQPPNNk8F9Ln2sETw.png"
alt="API Gateways with YARP Reverse Proxy in .NET 8 Microservices | by Mehmet Ozkaya | Medium" />
<figcaption aria-hidden="true">API Gateways with YARP Reverse Proxy in
.NET 8 Microservices | by Mehmet Ozkaya | Medium</figcaption>
</figure>
<h3 id="为什么需要yarp">为什么需要yarp？</h3>
<p><a
href="https://microsoft.github.io/reverse-proxy/index.html"><strong>yarp</strong></a>是一个开源的反向代理工具，它可以用来实现服务的路由、负载均衡等功能。
在微服务架构中，服务之间的通信是非常频繁的，而且服务的数量也可能非常多。为了简化服务之间的通信，通常会使用一个网关来统一管理服务的路由、负载均衡等功能。
传统的网关有很多种，如Nginx、Envoy等，但是这些网关都是通用的网关，它们并不了解微服务的概念，也不了解微服务之间的依赖关系。这就导致了在使用这些网关时，需要手动配置服务的路由、负载均衡等功能，这样就增加了配置的复杂性，也增加了维护的成本。
而在使用dapr时，dapr已经提供了服务发现、负载均衡等功能，那么为什么还需要yarp呢？
这是因为dapr是一个应用级的解决方案，它只负责应用程序之间的通信，而不负责服务之间的通信。而yarp是一个网络级的解决方案，它负责服务之间的通信，所以yarp和dapr是可以很好的结合在一起的。
在本项目中，需要一个统一的入口对外部访问的接口资源进行管理，如哪些接口需要鉴权、哪些接口需要限流等。这时，就可以使用yarp来实现这些功能。</p>
<h3 id="yarp的特点">yarp的特点</h3>
<p>yarp是一个开源的反向代理工具，是在 .NET Core 基础结构之上实现的，可在
Windows、Linux 或 MacOS 上使用，支持 HTTP 和 gRPC 协议。</p>
<h2 id="项目介绍">项目介绍</h2>
<p>在本项目中，将使用dapr和yarp来实现一个分布式多语言后端系统。该系统需要一个统一的入口对外部访问的接口资源进行管理，包括有哪些接口可以访问、哪些接口需要鉴权、哪些接口需要限流等。为了可以集中处理这些功能，需要实现一个路由注册服务，用来注册所有的服务和接口信息，并将路由服务与鉴权、限流等功能集成在一起。
实现以下几方面的统一：</p>
<ol type="1">
<li>统一的入口：所有的请求都通过统一的入口进行访问，这样可以方便的管理所有的请求。</li>
<li>统一的鉴权：所有的请求都需要经过鉴权，只有通过鉴权的请求才能访问后端服务。</li>
<li>统一的限流：所有的请求都需要经过限流，只有通过限流的请求才能访问后端服务。</li>
<li>统一的监控：所有的请求都需要经过监控，可以方便的查看请求的状态和性能。</li>
</ol>
<p>初次之外，作为微服务分布式系统的基础设施支持，还需要实现健康检查、日志中心，配置服务，自动路由注册，自动权限注册等功能。</p>
<p>接下来，我将分别介绍如何使用dapr和yarp来实现这些功能。</p>
<h1 id="项目实战">项目实战</h1>
<h2 id="创建网关服务">创建网关服务</h2>
<p>首先，我们需要创建一个网关服务，用来统一管理所有的请求。</p>
<ol type="1">
<li>创建一个新的ASP.NET Core
Web应用程序，命名为<code>GatewayService</code>。</li>
<li>在<code>GatewayService</code>项目中，添加对<code>Microsoft.ReverseProxy</code>的引用。</li>
<li>在<code>appsettings.json</code>文件中，添加yarp的配置信息。</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// appsettings.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;ReverseProxy&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Routes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;CustomerRoute&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ClusterId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;customers&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;AuthorizationPolicy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AdminPolicy&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// 匹配规则</span></span><br><span class="line">        <span class="attr">&quot;Match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;Path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/api/&#123;version&#125;/customer/&#123;platform&#125;/&#123;**path&#125;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// 转换规则</span></span><br><span class="line">        <span class="attr">&quot;Transforms&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="comment">// 转换后的路径模板</span></span><br><span class="line">            <span class="attr">&quot;PathPattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/&#123;version&#125;/&#123;platform&#125;/&#123;**path&#125;&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="comment">// 添加请求头</span></span><br><span class="line">            <span class="attr">&quot;RequestHeader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dapr-app-id&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 请求头的值，此处为daprd的appId</span></span><br><span class="line">            <span class="attr">&quot;Append&quot;</span><span class="punctuation">:</span> <span class="string">&quot;customer-webapi&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Clusters&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;customers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Destinations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;customers/destination1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="comment">// 后端服务的地址，此处为daprd服务的地址</span></span><br><span class="line">            <span class="attr">&quot;Address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://localhost:3500/&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在上面的配置中，我们定义了一个路由<code>CustomerRoute</code>，它的匹配规则是<code>/api/&#123;version&#125;/customer/&#123;platform&#125;/&#123;**path&#125;</code>，
当请求匹配到这个规则时，会将请求转发到<code>customers</code>集群中的<code>customers/destination1</code>
目标地址。同时，我们还定义了一个转换规则，将请求的路径中的<code>/</code>替换为<code>&#123;version&#125;/&#123;platform&#125;/&#123;**path&#125;</code>
，并且在请求头中添加<code>dapr-app-id</code>的请求头，值为<code>customer-webapi</code>。
<code>customers/destination1</code>
是一个目标地址，它的地址是<code>http://localhost:3500/</code>，这个地址是后端服务的地址。3500端口是dart服务的默认端口，定义该端口可在后续通过dapr直接进行服务发现。
在yarp中路由通配符的定义如下：</p>
<ul>
<li><code>&#123;version&#125;</code>：匹配一个路径段，如<code>v1</code>。</li>
<li><code>&#123;platform&#125;</code>：匹配一个路径段，如<code>web</code>。</li>
<li><code>&#123;**path&#125;</code>：匹配一个或多个路径段，如<code>/api/v1/customer/web/get</code>。</li>
<li>api：匹配一个路径段，如<code>api</code>，这里是固定的。</li>
</ul>
<blockquote>
<p>单个*匹配一个路径段，如模板<code>/api/&#123;version&#125;/customer/&#123;platform&#125;/*</code>可以匹配<code>/api/v1/customer/web/get</code>
，但是不能匹配<code>/api/v1/customer/web/get/1</code>。</p>
</blockquote>
<p>此处提取的路由参数可以在代码中提取出来，配置的变量名字即后续获得动态路由参数的键名。</p>
<ol start="4" type="1">
<li>在<code>Program.cs</code>文件中，需要注册yarp服务配置，配置可以从配置文件中读取，也可以通过代码配置，这里我们使用配置文件的方式。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Program.cs</span></span><br><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);</span><br><span class="line"><span class="keyword">var</span> services = builder.Services;</span><br><span class="line">services.AddReverseProxy()</span><br><span class="line">    .LoadFromConfig(builder.Configuration.GetSection(<span class="string">&quot;ReverseProxy&quot;</span>));</span><br><span class="line"><span class="keyword">var</span> app = builder.Build();</span><br><span class="line">app.MapReverseProxy(a =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    a.UseSessionAffinity();</span><br><span class="line">    a.UseLoadBalancing();</span><br><span class="line">    a.UsePassiveHealthChecks();</span><br><span class="line">&#125;);</span><br><span class="line">app.MapControllers();</span><br><span class="line">app.Run();</span><br></pre></td></tr></table></figure>
<h1 id="参考资料">参考资料</h1>
<p>官方文档：</p>
<ul>
<li><a href="https://docs.dapr.io/">Dapr官方文档</a></li>
<li><a
href="https://microsoft.github.io/reverse-proxy/index.html">yarp官方文档</a>
项目参考：</li>
<li><a
href="https://github.com/william-liebenberg/practical-dapr">Practical
Microservice Development with Dapr</a></li>
<li><a
href="https://github.com/yangzhongke/NETBookMaterials/tree/main/%E6%9C%80%E5%90%8E%E5%A4%A7%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81/YouZack-VNext">YouZack
Project</a></li>
<li><a
href="https://gitee.com/zhangyin-gitee/rec-all-dapr-2">张引老师的Dapr微服务实战课程</a></li>
</ul>
]]></content>
      <categories>
        <category>Dapr</category>
        <category>Yarp</category>
        <category>分布式系统</category>
      </categories>
      <tags>
        <tag>Dapr</tag>
        <tag>Yarp</tag>
        <tag>分布式</tag>
        <tag>多语言系统</tag>
      </tags>
  </entry>
  <entry>
    <title>go-mysql</title>
    <url>/undefined/2ac2b308/</url>
    <content><![CDATA[<p>本文主要介绍Go的mysql第三方package
go-sql-driver/mysql的使用方法，包括安装、连接数据库、查询、插入、更新、删除等。
<span id="more"></span></p>
<h1 id="go-sql-drivermysql">go-sql-driver/mysql</h1>
<h2 id="安装">安装</h2>
<p>首先，使用以下命令安装<code>go-sql-driver/mysql</code>包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/go-sql-driver/mysql</span><br></pre></td></tr></table></figure>
<h2 id="连接数据库">连接数据库</h2>
<p>使用以下代码连接到MySQL数据库：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dsn := <span class="string">&quot;user:password@tcp(127.0.0.1:3306)/dbname&quot;</span></span><br><span class="line">    db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, dsn)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error connecting to the database:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">    err = db.Ping()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error pinging the database:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Successfully connected to the database&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询">查询</h2>
<p>使用以下代码从数据库中查询数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">rows, err := db.Query(<span class="string">&quot;SELECT id, name FROM users&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Error querying the database:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    <span class="keyword">var</span> id <span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">    err := rows.Scan(&amp;id, &amp;name)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error scanning row:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;ID: %d, Name: %s\n&quot;</span>, id, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入">插入</h2>
<p>使用以下代码向数据库中插入数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result, err := db.Exec(<span class="string">&quot;INSERT INTO users (name) VALUES (?)&quot;</span>, <span class="string">&quot;John Doe&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Error inserting data:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id, err := result.LastInsertId()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Error getting last insert ID:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Inserted new user with ID: %d\n&quot;</span>, id)</span><br></pre></td></tr></table></figure>
<h2 id="更新">更新</h2>
<p>使用以下代码更新数据库中的数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result, err := db.Exec(<span class="string">&quot;UPDATE users SET name = ? WHERE id = ?&quot;</span>, <span class="string">&quot;Jane Doe&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Error updating data:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rowsAffected, err := result.RowsAffected()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Error getting rows affected:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Updated %d rows\n&quot;</span>, rowsAffected)</span><br></pre></td></tr></table></figure>
<h2 id="删除">删除</h2>
<p>使用以下代码从数据库中删除数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result, err := db.Exec(<span class="string">&quot;DELETE FROM users WHERE id = ?&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Error deleting data:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rowsAffected, err := result.RowsAffected()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Error getting rows affected:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Deleted %d rows\n&quot;</span>, rowsAffected)</span><br></pre></td></tr></table></figure>
<h2 id="references">References</h2>
<ul>
<li><a href="https://github.com/go-sql-driver/mysql">go-sql-driver/mysql
GitHub</a></li>
<li><a
href="https://tutorialedge.net/golang/golang-mysql-tutorial/">Golang
MySQL Tutorial</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>gin-swagger常见问题</title>
    <url>/undefined/a75ca75a/</url>
    <content><![CDATA[<p>本文主要介绍gin-swagger常见问题，包括Fetch error Internal Server
Error
doc<em>.</em>json、gin-swagger支持multipart/form-data里带文件参数等。
<span id="more"></span></p>
<h1 id="gin-swagger常见问题">gin-swagger常见问题</h1>
<h2 id="fetch-error-internal-server-error-doc.json">Fetch error Internal
Server Error doc<em>.</em>json</h2>
<p>需要导入<code>swag init</code>命令生成的docs包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _  module_name/docs</span><br></pre></td></tr></table></figure>
<h2
id="gin-swagger支持multipartform-data里带文件参数">gin-swagger支持multipart/form-data里带文件参数</h2>
<p>Param Type: <code>formData</code></p>
<p>Data Type: <code>file</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">// UpdateProfile godoc</span><br><span class="line">// @Summary UpdateProfile updates user info</span><br><span class="line">// @Description check username and token, then update user profile</span><br><span class="line">// @Accept multipart/form-data</span><br><span class="line">// @Produce json</span><br><span class="line">// @param username path string true &quot;username&quot;</span><br><span class="line">// @param token formData string true &quot;token&quot;</span><br><span class="line">// @param nickname formData string false &quot;nickname&quot;</span><br><span class="line">// @param image formData file false &quot;image&quot;</span><br><span class="line">// @Success 200 &#123;object&#125; map[string]interface&#123;&#125;</span><br><span class="line">// @Router /update/&#123;username&#125; [POST]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>https://github.com/swaggo/swag/blob/master/README.md</p></li>
<li><p>https://swagger.io/docs/specification/2-0/file-upload/</p></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
        <category>Gin</category>
        <category>Swagger</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Gin</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC-Go</title>
    <url>/undefined/71294c49/</url>
    <content><![CDATA[<p>本文主要介绍gRPC-Go的入门教程，包括protobuf简介、gRPC-Go简介、环境安装、官方示例、工程开发等。
<span id="more"></span> # gRPC-Go入门教程</p>
<h2 id="protobuf简介">protobuf简介</h2>
<p><code>Protocol Buffers(protobuf)</code>：与编程语言无关，与程序运行平台无关的<strong>数据序列化协议</strong>以及<strong>接口定义语言</strong>(IDL:
interface definition language)。</p>
<p>要使用<code>protobuf</code>需要先理解几个概念：</p>
<ul>
<li><p><code>protobuf</code>编译器<code>protoc</code>，用于编译<code>.proto</code>文件</p>
<ul>
<li>开源地址：https://github.com/protocolbuffers/protobuf</li>
</ul></li>
<li><p>编程语言的<code>protobuf</code>插件，搭配<code>protoc</code>编译器，根据<code>.proto</code>文件生成对应编程语言的代码。</p></li>
<li><p><code>protobuf runtime library</code>：每个编程语言有各自的<code>protobuf runtime</code>，用于实现各自语言的<code>protobuf</code>协议。</p></li>
<li><p>Go语言的<code>protobuf</code>插件和<code>runtime library</code>有过2个版本：</p>
<ul>
<li><p>第1个版本开源地址：<a
href="https://github.com/golang/protobuf">https://github.com/golang/protobuf</a>，包含有插件<code>proto-gen-go</code>，可以生成<code>xx.pb.go</code>和<code>xx_grpc.pb.go</code>。Go工程里导入该版本的<code>protobuf runtime</code>的方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/golang/protobuf&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>第2个版本开源地址：<a
href="https://github.com/protocolbuffers/protobuf-go">https://github.com/protocolbuffers/protobuf-go</a>，同样包含有插件<code>proto-gen-go</code>。不过该项目的<code>proto-gen-go</code>从<code>v1.20</code>版本开始，不再支持生成gRPC服务定义，也就是<code>xx_grpc.pb.go</code>文件。要生成gRPC服务定义需要使用<code>grpc-go</code>里的<code>progo-gen-go-grpc</code>插件。Go工程里导入该版本的<code>protobuf runtime</code>的方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google.golang.org/protobuf&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>推荐使用第2个版本，对protobuf的API做了优化和精简，并且把工程界限分清楚了：</p>
<ul>
<li>第一，把<code>protobuf</code>的Go实现都放在protobuf的项目里，而不是放在golang语言项目下面。</li>
<li>第二，把<code>gRPC</code>的生成，放在<code>grpc-go</code>项目里，而不是和<code>protobuf runtime</code>混在一起。</li>
</ul>
<p>有的老项目可能使用了第1个版本的<code>protobuf runtime</code>，在老项目里开发新功能的时候也可以使用第2个版本<code>protobuf runtime</code>，支持2个版本在一个Go项目里共存。但是要<strong>注意</strong>：一个项目里同时使用2个版本必须保证第一个版本的版本号不低于<code>v1.4</code>。</p></li>
</ul>
<h2 id="grpc-go简介">gRPC-Go简介</h2>
<p>gRPC-Go: gRPC的Go语言实现，基于HTTP/2的RPC框架。</p>
<p>开源地址：https://github.com/grpc/grpc-go</p>
<p>Go项目里导入该模块的方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;google.golang.org/grpc&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>grpc-go</code>项目里还包含有<code>protoc-gen-go-grpc</code>插件，用于根据<code>.proto</code>文件生成<code>xx_grpc.pb.go</code>文件。</p>
<h2 id="环境安装">环境安装</h2>
<p>分为3步：</p>
<ul>
<li><p>安装Go</p>
<ul>
<li>步骤参考：https://go.dev/doc/install</li>
</ul></li>
<li><p>安装Protobuf编译器<code>protoc</code>:
用于编译<code>.proto</code> 文件</p>
<ul>
<li><p>步骤参考：https://grpc.io/docs/protoc-installation/</p></li>
<li><p>执行如下命令查看<code>protoc</code>的版本号，确认版本号是3+，用于支持protoc3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc --version</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>安装<code>protoc</code>编译器的Go语言插件</p>
<ul>
<li><p><code>protoc-gen-go</code>插件：用于生成<code>xx.pb.go</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br></pre></td></tr></table></figure></li>
<li><p><code>protoc-gen-go-grpc</code>插件：用于生成<code>xx_grpc.pb.go</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p><strong>注意</strong>：有的教程可能只让你安装<code>protoc-gen-go</code>，没有安装<code>protoc-gen-go-grpc</code>，那有2种情况：</p>
<ul>
<li>使用的是第1个版本<code>github.com/golang/protobuf</code>的<code>protoc-gen-go</code>插件。</li>
<li>使用的是第2个版本<code>google.golang.org/protobuf</code>的<code>protoc-gen-go</code>插件并且<code>protoc-gen-go</code>版本号低于<code>v1.20</code>。从<code>v1.20</code>开始，第2个版本的<code>protoc-gen-go</code>插件不再支持生成gRPC服务定义。下面是官方说明：</li>
</ul>
<blockquote>
<p>The v1.20 <a
href="https://pkg.go.dev/google.golang.org/protobuf/cmd/protoc-gen-go"><code>protoc-gen-go</code></a>
does not support generating gRPC service definitions. In the future,
gRPC service generation will be supported by a new
<code>protoc-gen-go-grpc</code> plugin provided by the Go gRPC
project.</p>
<p>The <code>github.com/golang/protobuf</code> version of
<code>protoc-gen-go</code> continues to support gRPC and will continue
to do so for the foreseeable future.</p>
</blockquote>
<h2 id="官方示例">官方示例</h2>
<h3 id="下载代码">下载代码</h3>
<p>以<code>grpc-go</code>的v1.41.0版本为例，下载代码并进入到<code>grpc-go/examples/helloworld</code>目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b v1.41.0 https://github.com/grpc/grpc-go</span><br><span class="line"><span class="built_in">cd</span> grpc-go/examples/helloworld</span><br></pre></td></tr></table></figure>
<h3 id="运行代码">运行代码</h3>
<ul>
<li><p>启动服务端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run greeter_server/main.go</span><br></pre></td></tr></table></figure>
<p>终端会打印如下内容，表示服务端已经启动并且在监听<code>50051</code>端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2022/01/02 13:01:08 server listening at [::]:50051</span><br></pre></td></tr></table></figure></li>
<li><p>启动客户端。客户端会发送<code>SayHello</code>请求给服务端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run greeter_client/main.go</span><br></pre></td></tr></table></figure>
<p>终端会打印如下内容，表示收到了服务端的响应。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2022/01/02 13:01:25 Greeting: Hello world</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="工程开发">工程开发</h2>
<p>自己在使用<code>protobuf</code>和<code>grpc-go</code>开发的时候，按照如下步骤来操作：</p>
<ul>
<li>定义<code>.proto</code>文件，包括消息体和rpc服务接口定义</li>
<li>使用<code>protoc</code>命令来编译<code>.proto</code>文件，用于生成<code>xx.pb.go</code>和<code>xx_grpc.pb.go</code>文件</li>
<li>在服务端实现rpc里定义的方法</li>
<li>客户端调用rpc方法，获取响应结果</li>
</ul>
<p>我们通过对上面的<code>grpc-go/examples/helloworld</code>做修改，来说明上述步骤。</p>
<ul>
<li><p>第一步，在<code>helloworld.proto</code>里增加一个rpc方法<code>SayHelloAgain</code>，参数和返回值和<code>SayHello</code>保持一样。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The greeting service definition.</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="comment">// Sends a greeting</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// send another greeting</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHelloAgain (HelloRequest) <span class="keyword">returns</span> (HelloReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第二步，在<code>grpc-go/examples/helloworld</code>目录使用<code>protoc</code>命令编译<code>.proto</code>文件，生成新的<code>helloworld.pb.go</code>和<code>helloword_grpc.pb.go</code>文件。命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative \</span><br><span class="line">    --go-grpc_out=. --go-grpc_opt=paths=source_relative \</span><br><span class="line">    helloworld/helloworld.proto</span><br></pre></td></tr></table></figure></li>
<li><p>第三步，在服务端实现rpc里新定义的方法<code>SayHelloAgain</code>。在<code>greeter_server/main.go</code>添加如下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHelloAgain(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, <span class="type">error</span>) &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;Received: %v&quot;</span>, in.GetName())</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: <span class="string">&quot;Hello again &quot;</span> + in.GetName()&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第四步，在客户端调用新定义的rpc方法，获取响应结果。在<code>greeter_client/main.go</code>添加如下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r2, err2 := c.SayHelloAgain(ctx, &amp;pb.HelloRequest&#123;Name: *name&#125;)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err2)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;Greeting: %s&quot;</span>, r2.GetMessage())</span><br></pre></td></tr></table></figure></li>
<li><p>第五步，运行程序</p>
<ul>
<li><p>先启动服务端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run greeter_server/main.go</span><br></pre></td></tr></table></figure></li>
<li><p>再启动客户端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run greeter_client/main.go Alice</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p>客户端会打印如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2022/01/02 13:37:58 Greeting: Hello alice</span><br><span class="line">2022/01/02 13:37:58 Greeting: Hello again alice</span><br></pre></td></tr></table></figure>
<p>至此，我们就对如何在Go工程里使用<code>protobuf</code>和<code>gRPC</code>有了一个初步的了解和入门。</p>
<h2 id="进阶学习">进阶学习</h2>
<p>想要进一步学习，主要是深入了解<code>protobuf</code>和<code>gRPC</code>在Go语言里的使用技巧和原理</p>
<ul>
<li><p><code>protobuf</code>官方学习地址：</p>
<ul>
<li>https://developers.google.com/protocol-buffers/docs/proto3</li>
<li>https://developers.google.com/protocol-buffers/docs/gotutorial</li>
<li>https://developers.google.com/protocol-buffers/docs/reference/go-generated</li>
<li>https://developers.google.com/protocol-buffers/docs/reference/proto3-spec</li>
</ul></li>
<li><p><code>gRPC</code>官方学习地址：</p>
<ul>
<li>https://grpc.io/docs/languages/go/</li>
</ul></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><p>https://grpc.io/docs/languages/go/quickstart/</p></li>
<li><p>https://github.com/protocolbuffers/protobuf-go/releases/tag/v1.20.0#v1.20-grpc-support</p></li>
<li><p>https://stackoverflow.com/questions/64828054/differences-between-protoc-gen-go-and-protoc-gen-go-grpc</p></li>
<li><p>https://github.com/golang/protobuf</p></li>
<li><p>https://github.com/protocolbuffers/protobuf-go</p></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
        <category>rpc</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>go-redis</title>
    <url>/undefined/c4c77b25/</url>
    <content><![CDATA[<p>本文主要介绍Go的redis第三方package
go-redis/redis的使用方法，包括安装、连接数据库、基本操作等。
<span id="more"></span></p>
<h1 id="go-redisredis">go-redis/redis</h1>
<h2 id="安装">安装</h2>
<p>首先，使用以下命令安装<code>go-redis/redis</code>包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/go-redis/redis/v8</span><br></pre></td></tr></table></figure>
<h2 id="连接数据库">连接数据库</h2>
<p>使用以下代码连接到Redis数据库：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-redis/redis/v8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ctx = context.Background()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">        Addr:     <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">        Password: <span class="string">&quot;&quot;</span>, <span class="comment">// no password set</span></span><br><span class="line">        DB:       <span class="number">0</span>,  <span class="comment">// use default DB</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    err := rdb.Ping(ctx).Err()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Error connecting to the database:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Successfully connected to the database&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设置键值">设置键值</h2>
<p>使用以下代码向Redis数据库中设置键值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := rdb.Set(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>, <span class="number">0</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Error setting key:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Key set successfully&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="获取键值">获取键值</h2>
<p>使用以下代码从Redis数据库中获取键值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">val, err := rdb.Get(ctx, <span class="string">&quot;key&quot;</span>).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Error getting key:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Key value: %s\n&quot;</span>, val)</span><br></pre></td></tr></table></figure>
<h2 id="删除键值">删除键值</h2>
<p>使用以下代码从Redis数据库中删除键值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = rdb.Del(ctx, <span class="string">&quot;key&quot;</span>).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Error deleting key:&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;Key deleted successfully&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="references">References</h2>
<ul>
<li><a href="https://github.com/go-redis/redis">go-redis/redis
GitHub</a></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Go标准库之log使用详解</title>
    <url>/undefined/122db1f5/</url>
    <content><![CDATA[<p>本文主要介绍Go标准库log的使用方法，包括使用标准错误输出、自定义Logger等。
<span id="more"></span> # Go标准库之log使用详解</p>
<h2 id="简介">简介</h2>
<p>log包实现了简单的日志打印功能，支持日志输出到控制台或者日志文件。log包里核心的数据结构只有1个Logger，定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Logger represents an active logging object that generates lines of</span></span><br><span class="line"><span class="comment">// output to an io.Writer. Each logging operation makes a single call to</span></span><br><span class="line"><span class="comment">// the Writer&#x27;s Write method. A Logger can be used simultaneously from</span></span><br><span class="line"><span class="comment">// multiple goroutines; it guarantees to serialize access to the Writer.</span></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu     sync.Mutex <span class="comment">// ensures atomic writes; protects the following fields</span></span><br><span class="line">	prefix <span class="type">string</span>     <span class="comment">// prefix on each line to identify the logger (but see Lmsgprefix)</span></span><br><span class="line">	flag   <span class="type">int</span>        <span class="comment">// properties</span></span><br><span class="line">	out    io.Writer  <span class="comment">// destination for output</span></span><br><span class="line">	buf    []<span class="type">byte</span>     <span class="comment">// for accumulating text to write</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Logger结构体里的字段，在使用上我们只需要关心prefix，flag和out这3个字段的含义：</p>
<ul>
<li><p>out：表示日志输出的地方。可以是标准输出os.Stdout，os.Stderr或者指定的本地文件</p></li>
<li><p>flag：日志的属性设置。表示每行日志最开头打印的内容。取值如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// These flags define which text to prefix to each log entry generated by the Logger.</span></span><br><span class="line"><span class="comment">// Bits are or&#x27;ed together to control what&#x27;s printed.</span></span><br><span class="line"><span class="comment">// With the exception of the Lmsgprefix flag, there is no</span></span><br><span class="line"><span class="comment">// control over the order they appear (the order listed here)</span></span><br><span class="line"><span class="comment">// or the format they present (as described in the comments).</span></span><br><span class="line"><span class="comment">// The prefix is followed by a colon only when Llongfile or Lshortfile</span></span><br><span class="line"><span class="comment">// is specified.</span></span><br><span class="line"><span class="comment">// For example, flags Ldate | Ltime (or LstdFlags) produce,</span></span><br><span class="line"><span class="comment">//	2009/01/23 01:23:23 message</span></span><br><span class="line"><span class="comment">// while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,</span></span><br><span class="line"><span class="comment">//	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Ldate         = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>     <span class="comment">// the date in the local time zone: 2009/01/23</span></span><br><span class="line">	Ltime                         <span class="comment">// the time in the local time zone: 01:23:23</span></span><br><span class="line">	Lmicroseconds                 <span class="comment">// microsecond resolution: 01:23:23.123123.  assumes Ltime.</span></span><br><span class="line">	Llongfile                     <span class="comment">// full file name and line number: /a/b/c/d.go:23</span></span><br><span class="line">	Lshortfile                    <span class="comment">// final file name element and line number: d.go:23. overrides Llongfile</span></span><br><span class="line">	LUTC                          <span class="comment">// if Ldate or Ltime is set, use UTC rather than the local time zone</span></span><br><span class="line">	Lmsgprefix                    <span class="comment">// move the &quot;prefix&quot; from the beginning of the line to before the message</span></span><br><span class="line">	LstdFlags     = Ldate | Ltime <span class="comment">// initial values for the standard logger</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>prefix：每行日志最开头的日志前缀</p>
<p><strong>注意</strong>：如果flag开启了Lmsgprefix，那这个prefix前缀就不是放在每行日志的最开头了，而是在具体被打印的内容的前面。比如prefix如果是"INFO:"</p>
<ul>
<li><p>flag不开启Lmsgprefix的时候，prefix在每行日志最开头，日志输出为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">INFO:<span class="number">2021</span>/<span class="number">12</span>/<span class="number">01</span> <span class="number">21</span>:<span class="number">00</span>:<span class="number">34</span> example1.<span class="keyword">go</span>:<span class="number">14</span>: your message</span><br></pre></td></tr></table></figure></li>
<li><p>flag开启Lmsgprefix的时候，prefix在要打印的内容"your
message"的前面，日志输出为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">12</span>/<span class="number">01</span> <span class="number">21</span>:<span class="number">02</span>:<span class="number">20</span> example1.<span class="keyword">go</span>:<span class="number">14</span>: INFO:your message</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p>Logger结构体实现了若干指针接收者方法，包括设置日志属性、打印日志等。</p>
<p>同时在log这个包里，自带了一个默认的Logger，源码定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> std = New(os.Stderr, <span class="string">&quot;&quot;</span>, LstdFlags)</span><br></pre></td></tr></table></figure>
<p>这个自带的std配套有若干辅助函数，用于设置日志属性和打印日志等。</p>
<p>这些辅助函数实际上就是对Logger结构体的方法做了一层封装，在辅助函数里面都是通过std这个Logger指针去调用Logger的方法。所以辅助函数和Logger结构体方法是一一对应的。</p>
<h2 id="log使用方法">log使用方法</h2>
<p>要使用log包打印日志，有2种方式，可以根据各自业务场景选择对应方法：</p>
<ul>
<li>方法1：使用log包里自带的std这个Logger指针。通常用于在控制台输出日志。</li>
<li>方法2：自定义Logger。通常用于把日志输出到文件里。</li>
</ul>
<p>方法1和方法2相比，没有本质区别，只是使用场景上有一个偏好。</p>
<p>当然方法1也可以实现输出日志到文件里，方法2也可以实现在控制台打印日志。</p>
<p>下面详细介绍下这两种方式的用法。</p>
<h2 id="方式1log自带的标准错误输出">方式1：log自带的标准错误输出</h2>
<p>talk is cheap, show me the code。我们先看一段代码示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example1.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 通过SetFlags设置Logger结构体里的flag属性</span></span><br><span class="line">	log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile | log.Lmsgprefix)</span><br><span class="line">	<span class="comment">// 通过SetPrefix设置Logger结构体里的prefix属性</span></span><br><span class="line">	log.SetPrefix(<span class="string">&quot;INFO:&quot;</span>)</span><br><span class="line">	<span class="comment">// 调用辅助函数Println打印日志到标准</span></span><br><span class="line">	log.Println(<span class="string">&quot;your message&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例，使用了log包里自带的std标准输出，先通过SetFlags和SetPrefix这2个log包里的函数设置好std指向的Logger结构体对象里的flag和prefix属性，然后通过log包里定义的Println函数，把日志打印到控制台。程序运行结果如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>/<span class="number">12</span>/<span class="number">01</span> <span class="number">18</span>:<span class="number">18</span>:<span class="number">53</span> example3.<span class="keyword">go</span>:<span class="number">14</span>: INFO:your message</span><br></pre></td></tr></table></figure>
<p>总结方式1的使用流程如下：</p>
<ol type="1">
<li><p>通过调用SetFlags，SetPrefix，SetOutput函数设置好日志属性。SetOutPut可以用于设置日志输出的地方，比如终端，文件等。</p>
<p>如果省略这个步骤，会使用std创建时设置的默认属性。我们回顾下std的创建代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// New creates a new Logger. The out variable sets the</span></span><br><span class="line"><span class="comment">// destination to which log data will be written.</span></span><br><span class="line"><span class="comment">// The prefix appears at the beginning of each generated log line, or</span></span><br><span class="line"><span class="comment">// after the log header if the Lmsgprefix flag is provided.</span></span><br><span class="line"><span class="comment">// The flag argument defines the logging properties.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(out io.Writer, prefix <span class="type">string</span>, flag <span class="type">int</span>)</span></span> *Logger &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Logger&#123;out: out, prefix: prefix, flag: flag&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> std = New(os.Stderr, <span class="string">&quot;&quot;</span>, LstdFlags)</span><br></pre></td></tr></table></figure>
<p>从上面的源码可以看出std是默认把日志输出到控制台，默认日志的prefix前缀为空串，默认flag属性是LstdFlags，也就是日志开头会打印日期和时间，比如：2009/01/23
01:23:23</p>
<p>调用SetXXX函数可以修改std的默认设置。</p></li>
<li><p>调用log包里的辅助函数Print[f|ln]，Fatal[f|ln]，Panic[f|ln]打印日志</p>
<ul>
<li>Fatal[f|ln]打印日志后会调用os.Exit(1)</li>
<li>Panic[f|ln]打印日志后会调用panic</li>
</ul></li>
</ol>
<p>上面的例子example1.go是使用log包自带的std这个Logger指针把日志输出到控制台，我们也可以使用std把日志输出到指定文件，调用SetOutput设置日志输出的参数即可。参见如下代码示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example2.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 日志文件名</span></span><br><span class="line">	fileName := fmt.Sprintf(<span class="string">&quot;app_%s.log&quot;</span>, time.Now().Format(<span class="string">&quot;20060102&quot;</span>))</span><br><span class="line">	<span class="comment">// 创建文件</span></span><br><span class="line">	f, err := os.OpenFile(fileName, os.O_RDWR | os.O_CREATE | os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;open file error: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// main退出之前，关闭文件</span></span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	<span class="comment">// 调用SetOutput设置日志输出的地方</span></span><br><span class="line">	log.SetOutput(f)</span><br><span class="line">	<span class="comment">//log.SetOutput(io.MultiWriter(os.Stdout, f))</span></span><br><span class="line">	<span class="comment">// 通过SetFlags设置Logger结构体里的flag属性</span></span><br><span class="line">	log.SetFlags(log.Ldate | log.Ltime | log.Lshortfile | log.Lmsgprefix)</span><br><span class="line">	<span class="comment">// 通过SetPrefix设置Logger结构体里的prefix属性</span></span><br><span class="line">	log.SetPrefix(<span class="string">&quot;INFO:&quot;</span>)</span><br><span class="line">	<span class="comment">// 调用辅助函数Println打印日志到指定文件</span></span><br><span class="line">	log.Println(<span class="string">&quot;your message&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码会在当前目录下生成一个app_YYYYMMDD.log文件，log.Println里打印的内容会输出到这个文件里。细心的同学，可能看到了上面被注释的一行代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">log.SetOutput(io.MultiWriter(os.Stdout, f))</span><br></pre></td></tr></table></figure>
<p>这个表示的含义是同时把打印内容输出到标准输出(控制台)和指定文件里。</p>
<h2 id="方式2自定义logger">方式2：自定义Logger</h2>
<p>方式1只建议打印到控制台的时候使用，对于打印到日志文件的场景，建议使用自定义Logger，参考如下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example3.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 打开文件</span></span><br><span class="line">	fileName := fmt.Sprintf(<span class="string">&quot;app_%s.log&quot;</span>, time.Now().Format(<span class="string">&quot;20060102&quot;</span>))</span><br><span class="line">	f, err := os.OpenFile(fileName, os.O_RDWR | os.O_APPEND | os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;open file error: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过New方法自定义Logger，New的参数对应的是Logger结构体的output, prefix和flag字段</span></span><br><span class="line">	logger := log.New(f, <span class="string">&quot;[INFO] &quot;</span>, log.LstdFlags | log.Lshortfile | log.Lmsgprefix)</span><br><span class="line">	<span class="comment">// 调用Logger的方法Println打印日志到指定文件</span></span><br><span class="line">	logger.Println(<span class="string">&quot;your message&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码会在当前目录下生成一个app_YYYYMMDD.log文件，logger.Println里打印的内容会输出到这个文件里。</p>
<p><strong>注意</strong>：New函数返回的是Logger指针，Logger结构体的方法都是指针接受者。</p>
<p>总结方式2的使用流程如下：</p>
<ol type="1">
<li>通过log.New创建一个新的Logger指针，在New函数里指定好output,
prefix和flag等日志属性</li>
<li>调用log包里的辅助函数Print[f|ln]，Fatal[f|ln]，Panic[f|ln]打印日志
<ul>
<li>Fatal[f|ln]打印日志后会调用os.Exit(1)</li>
<li>Panic[f|ln]打印日志后会调用panic</li>
</ul></li>
</ol>
<p>自定义Logger的方式，还可以实现打印日志到控制台，也可以实现同时打印日志到日志文件和控制台，只需要给New函数的第一个参数传递对应的io.Writer类型参数即可。</p>
<ul>
<li>如果要打印到控制台，参数可以用os.Stdout或者os.Stderr</li>
<li>如果要同时打印到控制台和日志文件，参数可以用io.MultiWriter(os.Stdout,
f)，参考上面的example2.go。</li>
</ul>
<h2 id="生产应用">生产应用</h2>
<p>生产系统中打印日志就比上面的要复杂多了，需要考虑至少以下几个方面：</p>
<ul>
<li><p>日志路径设置：支持配置日志文件路径，将日志打印到指定路径的文件里。</p></li>
<li><p>日志级别控制：支持Debug, Info, Warn, Error,
Fatal等不同日志级别。</p></li>
<li><p>日志切割：可以按照日期和日志大小进行自动切割。</p></li>
<li><p>性能：在大量日志打印的时候不能对应用程序性能造成明显影响。</p></li>
</ul>
<p>Go生态中，目前比较流行的是Uber开发的zap，在GitHub上的开源地址：https://github.com/uber-go/zap</p>
<h2 id="注意事项">注意事项</h2>
<ul>
<li>Lmsgprefix属性：不开启该属性时，Logger结构体里的prefix属性就会在每行日志最开头。开启该属性后，prefix就会在被打印的具体内容之前，而不是在每行最开头。</li>
<li>LUTC属性：对于Logger结构体里的flag属性，如果开启了LUTC属性，那打印的日志里显示的时间就不是本地时间了，而是UTC标准时间。比如中国在东八区，中国时间减去8小时就是UTC时间。</li>
<li>Fatal[f|ln]：打印日志后，会调用os.Exit(1)。如果defer关键字和Fatal[f|ln]一起使用要小心，因为如果在函数里执行了defer，但是最后是由于调用了os.Exit而退出的函数，那被defer的函数和方法是不会执行的。具体可以参考我之前写的文章<a
href="../../senior/p2">Go语言里被defer的函数一定会执行么？</a></li>
<li>Panic[f|ln]：打印日志后会调用panic，应用程序要考虑是否要通过recover来捕获panic，避免程序退出。</li>
<li>log打印的日志一定会换行。所以即使调用的是log包里的Print函数或方法，打印的日志也会换行。因此使用log包里的Print和Println没有区别了。</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>https://pkg.go.dev/log</li>
<li>https://www.flysnow.org/2017/05/06/go-in-action-go-log.html</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
        <category>std</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>27.Go-select语义</title>
    <url>/undefined/11c462bd/</url>
    <content><![CDATA[<p>本文主要介绍Go的select语义，包括select的含义、语法、示例等。
<span id="more"></span> # select语义</p>
<h2 id="含义">含义</h2>
<p>select语义是和channel绑定在一起使用的，select可以实现从多个channel收发数据。</p>
<p>语法上和switch类似，有case分支和default分支，只不过select的每个case后面跟的是channel的收发操作。</p>
<p>在执行select语句的时候，如果当下那个时间点没有一个case满足条件，就会走default分支。</p>
<p>至多只能有一个 default分支。</p>
<p>如果没有default分支，select语句就会阻塞，直到某一个case满足条件。</p>
<p>如果select里任何case和default分支都没有，就会一直阻塞。</p>
<p>如果多个case同时满足，select会随机选一个case执行。</p>
<h2 id="语法">语法</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">d</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> ch1 &lt;- data1: <span class="comment">// send data to channel</span></span><br><span class="line">		do sth</span><br><span class="line">	<span class="keyword">case</span> var_name = &lt;-ch2 : <span class="comment">// receive data from channel</span></span><br><span class="line">		do sth</span><br><span class="line">	<span class="keyword">case</span> data, ok := &lt;-ch3:</span><br><span class="line">		do sth</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		do sth</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语法上和<a href="../lesson6">switch</a>的一些区别：</p>
<ul>
<li>select关键字和后面的{ 之间，不能有表达式或者语句。</li>
<li>没有fallthrough语句</li>
<li>每个case关键字后面跟的必须是channel的发送或者接收操作</li>
<li>允许多个case分支使用相同的channel，case分支后的语句甚至可以重复</li>
</ul>
<h2 id="示例">示例</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">			ch1 &lt;- i</span><br><span class="line">			ch2 &lt;- i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> x := &lt;-ch1:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;receive %d from channel 1\n&quot;</span>, x)</span><br><span class="line">		<span class="keyword">case</span> y := &lt;-ch2:</span><br><span class="line">			fmt.Printf(<span class="string">&quot;receive %d from channel 2\n&quot;</span>, y)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例里，select语句会for循环执行10次，每次select语句都会随机从channel1或者channel2里接收一个值并打印。</p>
<h2 id="references">References</h2>
<ul>
<li>https://golang.google.cn/ref/spec#Select_statements</li>
<li>https://gobyexample.com/select</li>
<li>https://go101.org/article/channel.html</li>
<li>https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>26.panic和recover</title>
    <url>/undefined/7edf0729/</url>
    <content><![CDATA[<p>本文主要介绍Go的panic和recover的使用方法，包括panic的定义、示例、recover的定义、示例等。
<span id="more"></span> # panic和recover</p>
<p>panic和recover是Go的2个内置函数，用于程序运行期抛出异常(panic的功能)和处理异常(recover的功能)。</p>
<h2 id="panic">panic</h2>
<p>引发panic可以是程序显式调用panic函数，也可以是运行期错误，比如数组越界访问，除0等。</p>
<ul>
<li><p>定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="comment">// 入参是一个空interface，无返回值</span></span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>(<span class="number">12</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;invalid parameter&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(Error(<span class="string">&quot;cannot parse&quot;</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>如果在函数F里，显式调用了panic或者函数F执行过程中出现运行期错误，那F的执行会终止，接下来会有以下行为依次产生：</p>
<ul>
<li>F里被defer的函数会执行。</li>
<li>F的上一级函数，也就是调用F的函数，假设是函数E。对函数E而言，对F的调用就等同于调用了panic，函数E里被defer的函数被执行</li>
<li>如果函数E还有上一级函数，就继续往上，每一级函数里被defer的函数都被执行，直到没有上一级函数。</li>
<li>经过了以上步骤，panic的错误就会被抛出来，整个程序结束。</li>
</ul></li>
<li><p>既然可以用panic来抛运行期异常，那就有相应办法可以捕获异常，让程序正常往下执行。Go通过结合内置函数recover和defer语义，来实现捕获运行期异常。</p></li>
<li><p><strong>对于标准Go编译器，有些致命错误是无法被recover捕捉的，比如栈溢出(stack
overflow)或者内存超限(out of
memory)，遇到这种情况程序就会crash。</strong></p></li>
</ul>
<h2 id="recover">recover</h2>
<p>recover是Go的内置函数，可以捕获panic异常。recover必须结合defer一起使用才能生效。</p>
<p>程序正常执行过程中，没有panic产生，这时调用recover函数会返回nil，除此之外，没有其它任何效果。</p>
<p>如果当前goroutine触发了panic，可以在代码的适当位置调用recover函数捕获异常，让程序继续正常执行，而不是异常终止。</p>
<ul>
<li><p>定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 返回值是一个空interface，无入参</span></span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">/*捕获函数a内部的panic*/</span></span><br><span class="line">		r := <span class="built_in">recover</span>()</span><br><span class="line">		fmt.Println(<span class="string">&quot;panic recover&quot;</span>, r)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">/*因为函数a的panic已经被函数a内部的recover捕获了</span></span><br><span class="line"><span class="comment">		所以main里的recover捕获不到异常，r的值是nil*/</span></span><br><span class="line">		r := <span class="built_in">recover</span>()</span><br><span class="line">		fmt.Println(<span class="string">&quot;main recover&quot;</span>, r)</span><br><span class="line">	&#125;()</span><br><span class="line">	a()</span><br><span class="line">	fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上例的执行结果是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span> <span class="built_in">recover</span> <span class="number">1</span></span><br><span class="line">main</span><br><span class="line">main <span class="built_in">recover</span> &lt;<span class="literal">nil</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>recover在以下几种情况返回nil</p>
<ul>
<li>panic的参数是nil。这种情况recover捕获后，拿到的返回值也是nil。</li>
<li>goroutine没有panic产生。没有panic，那当然recover拿到的也就是nil了。</li>
<li>recover不是<strong>在被defer的函数里面</strong>被<strong>直接调用</strong>执行。</li>
</ul></li>
<li><p>一个更复杂的示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Returned normally from f.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered in f&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Calling g.&quot;</span>)</span><br><span class="line">    g(<span class="number">0</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Returned normally from g.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Panicking!&quot;</span>)</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, i))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Defer in g&quot;</span>, i)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Printing in g&quot;</span>, i)</span><br><span class="line">    g(i + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家可以下载<a
href="./recover2.go">recover2.go</a>代码，本地运行看看结果是否和预期相符。</p></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>https://go.dev/ref/spec#Run_time_panics</li>
<li>https://go.dev/blog/defer-panic-and-recover</li>
<li>https://go.dev/ref/spec#Handling_panics</li>
<li>https://chai2010.gitbooks.io/advanced-go-programming-book/content/appendix/appendix-a-trap.html</li>
<li>https://go101.org/article/control-flows-more.html</li>
<li>https://go101.org/article/panic-and-recover-more.html</li>
<li>https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>25.包package和模块Module</title>
    <url>/undefined/89a63806/</url>
    <content><![CDATA[<p>本文主要介绍Go的包package和模块Module的使用方法，包括package的定义、import语法、Go如何寻找import的package、init函数、注意事项等。
<span id="more"></span> # 包package和模块Module</p>
<h2 id="package定义">package定义</h2>
<p>package本质上就是一个目录，目录里包含有一个或者多个Go源程序文件，或者package。也就是说package里面还可以嵌套包含子package。</p>
<p>每个Go源文件都属于一个package，在源文件开头指定package名称</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> package_name</span><br></pre></td></tr></table></figure>
<p>package的代码结构示例如下：</p>
<figure>
<img
src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokepackage_structure.jpg"
alt="package_structure" />
<figcaption aria-hidden="true">package_structure</figcaption>
</figure>
<p>package里的变量、函数、结构体、方法等如果要被本package外的程序引用，需要在命名的时候首字母大写。</p>
<p>如果首字母小写，那就只能在同一个package里面被使用。</p>
<p><strong>注意</strong>：这里说的是同一个package，不是同一个文件。同一个package下，如果有多个源程序文件是声明的该package，那这些源程序文件里的变量、函数、结构体等，即使不是首字母大写，也可以互相跨文件直接调用，不用额外import。</p>
<p>package的使用分为4类情况：</p>
<ul>
<li>使用Go标准库自带的package，比如fmt。</li>
<li>使用go get获取到的第三方package/module</li>
<li>使用项目内部的package</li>
<li>使用其它项目的package/module</li>
</ul>
<h2 id="import语法示例">import语法示例</h2>
<h3 id="普通">普通</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span>                           <span class="comment">// 标准库</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span>                   <span class="comment">// 标准库sync的atomic子package</span></span><br><span class="line">	<span class="string">&quot;package1&quot;</span>                      <span class="comment">// 自开发的package</span></span><br><span class="line">	<span class="string">&quot;package2/package21&quot;</span>            <span class="comment">// 自开发package，嵌套子package</span></span><br><span class="line">	<span class="string">&quot;package2/package22&quot;</span>            <span class="comment">// 自开发package，嵌套子package</span></span><br><span class="line">	<span class="string">&quot;package3/package31/package311&quot;</span> <span class="comment">// 自开发package，多重嵌套</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>使用import路径里面定义的<strong>package名称</strong>来访问package里的方法，结构体等，而不是路径名称。</p>
<p>举个例子，假设上面import的路径package2/package21这个目录下的Go源程序文件开头声明的package名称是realpackage，那访问这个package里的方法，结构体等要用realpackage.xxx来访问，而不是用package21.xxx来访问。</p>
<p>一句话总结：<strong>import的是路径，访问用package名称</strong>。最佳实践就是让两者保持一致。</p>
<h3 id="别名">别名</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    newName <span class="string">&quot;package2/package21&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>可以用别名newName来访问package里的成员，newName.xxx。这个在包名很长或者包名有重复的时候可以用到。</p>
<h3 id="点操作">点操作</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    . <span class="string">&quot;package2/package21&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>.</code>可以让后面的package里的成员注册到当前包的上下文，这样就可以直接调用成员名，不需要加包前缀了。</p>
<p>比如以前要用package21.Hello()来调用package21这个包里的函数Hello，用了点操作后，可以直接调用函数Hello()，前面不用跟package名称。</p>
<h3 id="下划线">下划线</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    _ <span class="string">&quot;package2/package21&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>下划线<code>_</code>的效果：只会执行包里各个源程序文件的init方法，没法调用包里的成员。</p>
<h2 id="go如何寻找import的package">Go如何寻找import的package</h2>
<p>在代码里import某个package的时候，Go是如何去寻找对应的package呢？这个和Go环境变量GO111MODULE有关系。GO111MODULE的值可以通过如下命令查到</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> env | grep GO111MODULE</span><br></pre></td></tr></table></figure>
<p>on表示开启，off表示关闭。GO111MODULE是从Go
1.11开始引入，在随后的Go版本中Go Modules的行为有一些变化，具体可以参考<a
href="https://maelvls.dev/go111module-everywhere/#go111module-with-go-116">GO111MODULE
and Go Modules</a>。</p>
<p>下面以Go1.16及以上版本详细讲下GO111MODULE关闭和开启的情况下，Go是如何寻找import的package的。</p>
<h3 id="关闭go111module">关闭GO111MODULE</h3>
<ul>
<li><p>先从<span
class="math inline">\(GOROOT/src里找。\)</span>GOROOT是Go的安装路径，<span
class="math inline">\(GOROOT/src是Go标准库存放的路径，比如fmt,
strings等package都存放在\)</span>GOROOT/src里。$GOROOT的路径可以通过下面的命令查看到：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> env | grep ROOT <span class="comment">// linux or mac</span></span><br><span class="line"><span class="keyword">go</span> env | findstr ROOT <span class="comment">// windows</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果从<span
class="math inline">\(GOROOT/src找不到，再从\)</span>GOPATH/src里找。$GOPATH是安装Go后就会有的一个环境变量，Linux和Mac的默认路径是/Users/用户名/go，WIndows默认路径是C:/Users/用户名/go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> env | grep PATH <span class="comment">// linux or mac</span></span><br><span class="line"><span class="keyword">go</span> env | findstr PATH <span class="comment">// windows</span></span><br></pre></td></tr></table></figure>
<p>在Go 1.11之前，还没有Go
Modules，如果想import一些自己开发的package，被import的package必须建在<span
class="math inline">\(GOPATH/src路径下。一般而言，一个工程项目一定会有自己写的若干个package，因此这也导致工程项目本身也通常建在了\)</span>GOPATH/src路径下。</p></li>
</ul>
<h3 id="开启go111module">开启GO111MODULE</h3>
<p>Go 1.11开始，有了Go
Modules，工程项目可以建在任何地方，代码在import某个package的时候，会按照如下顺序寻找package：</p>
<ul>
<li><p>先从$GOROOT/src/路径找。(Go标准库会在这个路径找到)</p></li>
<li><p>再从$GOPATH/pkg/mod/路径找。(Go第三方库会在这个路径找到)</p></li>
<li><p>如果都找不到，再看当前项目有没有go.mod文件，有的话就从go.mod文件里指定的模块所在路径往下找。如果没有go.mod文件，那就直接提示package
xxx is not in GOROOT。(自己开发的本地库可以通过这个方式找到)</p></li>
</ul>
<p>官方推荐使用Go
Modules，从Go1.16版本开始，GO111MODULE环境变量默认开启为on模式。</p>
<h2 id="使用示例">使用示例</h2>
<h3 id="不开启go111modules时import-package">不开启GO111MODULES时import
package</h3>
<ol type="1">
<li>项目建在$GOPATH/src下面</li>
<li>import package的时候路径从$GOPATH/src往下找</li>
</ol>
<p>使用说明参考<a
href="https://github.com/jincheng9/go-tutorial/tree/main/workspace/lesson27/gopath/">gopath
package demo</a></p>
<h3
id="开启go111modules时import本项目里的package">开启GO111MODULES时import本项目里的package</h3>
<ol type="1">
<li><p>项目可以建在任何地方</p></li>
<li><p>在项目所在根目录创建go.mod文件, module_name是模块名称</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> mod init module_name</span><br></pre></td></tr></table></figure></li>
<li><p>import项目本地的package时指定go.mod文件里的模块名称</p>
<p>比如module_name叫project，在这个模块里，main.go使用了本项目里的util包，那在main.go里按照如下格式import这个package</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;project/util&quot;</span> <span class="comment">// project是模块名称, util是这个模块下的本地package</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用说明参考<a
href="https://github.com/jincheng9/go-tutorial/tree/main/workspace/lesson27/module">module
package demo</a></p>
<h3
id="开启go111modules时import第三方开发的module">开启GO111MODULES时import第三方开发的Module</h3>
<ol type="1">
<li><p>项目可以建在任何地方</p></li>
<li><p>在项目所在根目录创建go.mod文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> mod init module_name</span><br></pre></td></tr></table></figure></li>
<li><p>下载所需第三方Module，比如gin</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure></li>
<li><p>代码里import对应的Module</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>tips</strong>:
<code>go mod tidy</code>命令可以更新go.mod里的依赖内容，比如go.mod里少写了依赖的module，就可以执行该命令自动更新go.mod，在go.mod所在目录执行如下命令即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> mod tidy</span><br></pre></td></tr></table></figure>
<h3
id="开启go111modules时import本地的module">开启GO111MODULES时import本地的Module</h3>
<p>首先，Go官方并不推荐这种用法。import本地的module需要借助<code>replace</code>指令来实现。</p>
<p>举个例子，本地有2个模块<code>module1</code>和<code>module2</code>，<code>module1</code>要使用<code>module2</code>里的<code>Add</code>函数，目录结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">replace_module_demo</span><br><span class="line">|</span><br><span class="line">|------module1</span><br><span class="line">|        |---main.go</span><br><span class="line">|        |---go.mod        </span><br><span class="line">|------module2</span><br><span class="line">|        |---func.go</span><br><span class="line">|        |---go.mod</span><br></pre></td></tr></table></figure>
<p><code>module1</code>要使用<code>module2</code>里的<code>Add</code>函数，需要做2个事情：</p>
<ul>
<li>在<code>module1</code>代码里添加对
<code>module2</code>的import。具体表现为下面的代码示例里module1/main.go里import了<code>module2</code>。</li>
<li>在<code>module1</code>的<code>go.mod</code>里添加<code>require</code>和<code>replace</code>指令，把对<code>module2</code>的import通过<code>replace</code>指令指向本地的<code>module2</code>路径。具体参考module1/go.mod里的require和replace指令。</li>
</ul>
<p>代码如下：</p>
<p>module1/main.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="comment">// 模块module1要使用本地模块module2里的Add函数</span></span><br><span class="line">	<span class="comment">// 这里被import的本地模块的名称要和module2/go.mod里保持一致</span></span><br><span class="line">	<span class="string">&quot;module2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	b := <span class="number">2</span></span><br><span class="line">	sum := module2.Add(a, b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;sum of %d and %d is %d\n&quot;</span>, a, b, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>module1/go.mod，<strong>注意require后面的module必须指定版本号</strong>，版本号以
<code>v</code>开头，后面是由<code>.</code>分隔的3个整数组成，比如<code>v1.0.0</code>。3个整数从左往右，分别表示大版本号(major
version)，小版本号(minor version)和补丁版本(patch version)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module module1</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br><span class="line"></span><br><span class="line">require module2 v1<span class="number">.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">replace module2 =&gt; ../module2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>module2/func.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> module2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>module2/go.mod</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">module module2</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br></pre></td></tr></table></figure>
<p>在module1路径下执行<code>go run main.go</code>，结果为</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">sum of 1 and 2 is 3</span><br></pre></td></tr></table></figure>
<p>代码开源地址：<a
href="https://github.com/jincheng9/go-tutorial/tree/main/workspace/lesson27/replace_module_demo">demo
for using local module</a></p>
<h2 id="init函数">init函数</h2>
<p>init函数没有参数，没有返回值。</p>
<ul>
<li>一个package里可以有多个init函数(分布在单个源程序文件中或者多个源程序文件中)，并且按照它们呈现给编译器的顺序被调用。</li>
<li>init函数不能被显式调用，在main()函数执行之前，自动被调用</li>
<li>同一个pacakge里的init函数调用顺序不确定</li>
<li>不同package的init函数，根据package
import的依赖关系来决定调用顺序，比如package A里import了package
B，那package B的init()函数就会比package A的init函数先调用。</li>
<li><strong>无论package被import多少次，package里的init函数只会执行一次</strong></li>
</ul>
<h2 id="注意事项">注意事项</h2>
<ul>
<li><p>package目录名和package目录下的Go源程序文件开头声明的包名可以不一样，不过一般还是写成一样，避免出错。</p></li>
<li><p>禁止循环导入package。</p></li>
<li><p>Go Module版本号规则：<a
href="https://go.dev/ref/mod#versions">https://go.dev/ref/mod#versions</a>，版本号不符合规则就是非法版本，会导致编译失败。</p></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>https://www.callicoder.com/golang-packages/</li>
<li>https://www.liwenzhou.com/posts/Go/import_local_package_in_go_module/</li>
<li>https://maelvls.dev/go111module-everywhere/#go111module-with-go-116</li>
<li>https://go.dev/ref/mod#go-mod-file-replace</li>
<li>https://go.dev/ref/mod#versions</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>24.并发编程之原子操作sync/atomic</title>
    <url>/undefined/cd2f42bc/</url>
    <content><![CDATA[<p>本文主要介绍Go的sync/atomic包的使用方法、定义、方法等。
<span id="more"></span></p>
<h1 id="并发编程之原子操作syncatomic">并发编程之原子操作sync/atomic</h1>
<h2 id="syncatomic定义">sync/atomic定义</h2>
<p>官方文档地址：https://pkg.go.dev/sync/atomic@go1.18.1</p>
<p>Go语言标准库中的<code>sync/atomic</code>包提供了偏底层的原子内存原语(atomic
memory primitives)
，用于实现同步算法，其本质是将底层CPU提供的原子操作指令封装成了Go函数。</p>
<p>使用<code>sync/atomic</code>提供的原子操作可以确保在任意时刻只有一个goroutine对变量进行操作，避免并发冲突。</p>
<p>使用<code>sync/atomic</code>需要特别小心，Go官方建议只有在一些偏底层的应用场景里才去使用<code>sync/atomic</code>，其它场景建议使用<code>channel</code>
或者<code>sync</code>包里的锁。</p>
<blockquote>
<p>Share memory by communicating; don't communicate by sharing
memory.</p>
</blockquote>
<p><code>sync/atomic</code>提供了5种类型的原子操作和1个<code>Value</code>类型。</p>
<h3 id="种类型的原子操作">5种类型的原子操作</h3>
<ul>
<li>swap操作：<code>SwapXXX</code></li>
<li>compare-and-swap操作：<code>CompareAndSwapXXX</code></li>
<li>add操作：<code>AddXXX</code></li>
<li>load操作：<code>LoadXXX</code></li>
<li>store操作：<code>StoreXXX</code></li>
</ul>
<p>这几种类型的原子操作只支持几个基本的数据类型。</p>
<p>add操作的<code>Addxxx</code>函数只支持<code>int32</code>,
<code>int64</code>, <code>uint32</code>, <code>uint64</code>,
<code>uintptr</code>这5种基本数据类型。</p>
<p>其它类型的操作函数只支持<code>int32</code>, <code>int64</code>,
<code>uint32</code>, <code>uint64</code>, <code>uintptr</code>,
<code>unsafe.Pointer</code>这6种基本数据类型。</p>
<h3 id="value类型">Value类型</h3>
<p>由于上面5种类型的原子操作只支持几种基本的数据类型，因此为了扩大原子操作的使用范围，Go团队在1.4版本的<code>sync/atomic</code>
包中引入了一个新的类型<code>Value</code>。<code>Value</code>类型可以用来读取(Load)和修改(Store)<strong>任意类型</strong>的值。</p>
<p>Go
1.4版本的<code>Value</code>类型只有<code>Load</code>和<code>Store</code>2个方法，Go
1.17版本又给<code>Value</code>类型新增了<code>CompareAndSwap</code>和<code>Swap</code>这2个新方法。</p>
<h2 id="syncatomic实践">sync/atomic实践</h2>
<h3 id="swap操作">swap操作</h3>
<p>swap操作支持<code>int32</code>, <code>int64</code>,
<code>uint32</code>, <code>uint64</code>, <code>uintptr</code>,
<code>unsafe.Pointer</code>这6种基本数据类型，对应有6个swap操作函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt32</span><span class="params">(addr *<span class="type">int32</span>, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (old <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapInt64</span><span class="params">(addr *<span class="type">int64</span>, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (old <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapPointer</span><span class="params">(addr *unsafe.Pointer, <span class="built_in">new</span> unsafe.Pointer)</span></span> (old unsafe.Pointer)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (old <span class="type">uint32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (old <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (old <span class="type">uintptr</span>)</span><br></pre></td></tr></table></figure>
<p>swap操作实现的功能是把<code>addr</code>
指针指向的内存里的值替换为新值<code>new</code>，然后返回旧值<code>old</code>，是如下伪代码的原子实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">old = *addr</span><br><span class="line">*addr = <span class="built_in">new</span></span><br><span class="line"><span class="keyword">return</span> old</span><br></pre></td></tr></table></figure>
<p>我们拿<code>SwapInt32</code>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// swap.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> newValue <span class="type">int32</span> = <span class="number">200</span></span><br><span class="line">	<span class="keyword">var</span> dst <span class="type">int32</span> = <span class="number">100</span></span><br><span class="line">	<span class="comment">// 把dst的值替换为newValue</span></span><br><span class="line">	old := atomic.SwapInt32(&amp;dst, newValue)</span><br><span class="line">	<span class="comment">// 打印结果</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;old value: &quot;</span>, old, <span class="string">&quot; new value:&quot;</span>, dst)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序的执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">old value:  100  new value: 200</span><br></pre></td></tr></table></figure>
<h3 id="compare-and-swap操作">compare-and-swap操作</h3>
<p>compare-and-swap(CAS)操作支持<code>int32</code>, <code>int64</code>,
<code>uint32</code>, <code>uint64</code>, <code>uintptr</code>,
<code>unsafe.Pointer</code>
这6种基本数据类型，对应有6个compare-and-swap操作函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt32</span><span class="params">(addr *<span class="type">int32</span>, old, <span class="built_in">new</span> <span class="type">int32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapInt64</span><span class="params">(addr *<span class="type">int64</span>, old, <span class="built_in">new</span> <span class="type">int64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapPointer</span><span class="params">(addr *unsafe.Pointer, old, <span class="built_in">new</span> unsafe.Pointer)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint32</span><span class="params">(addr *<span class="type">uint32</span>, old, <span class="built_in">new</span> <span class="type">uint32</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint64</span><span class="params">(addr *<span class="type">uint64</span>, old, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, old, <span class="built_in">new</span> <span class="type">uintptr</span>)</span></span> (swapped <span class="type">bool</span>)</span><br></pre></td></tr></table></figure>
<p>compare-and-swap操作实现的功能是先比较<code>addr</code>
指针指向的内存里的值是否为旧值<code>old</code>相等。</p>
<ul>
<li>如果相等，就把<code>addr</code>指针指向的内存里的值替换为新值<code>new</code>，并返回<code>true</code>，表示操作成功。</li>
<li>如果不相等，直接返回<code>false</code>，表示操作失败。</li>
</ul>
<p>compare-and-swap操作是如下伪代码的原子实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> *addr == old &#123;</span><br><span class="line">	*addr = <span class="built_in">new</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>我们拿<code>CompareAndSwapInt32</code>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compare-and-swap.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> dst <span class="type">int32</span> = <span class="number">100</span></span><br><span class="line">	oldValue := atomic.LoadInt32(&amp;dst)</span><br><span class="line">	<span class="keyword">var</span> newValue <span class="type">int32</span> = <span class="number">200</span></span><br><span class="line">	<span class="comment">// 先比较dst的值和oldValue的值，如果相等，就把dst的值替换为newValue</span></span><br><span class="line">	swapped := atomic.CompareAndSwapInt32(&amp;dst, oldValue, newValue)</span><br><span class="line">	<span class="comment">// 打印结果</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;old value: %d, swapped value: %d, swapped success: %v\n&quot;</span>, oldValue, dst, swapped)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序的执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">old value: 100, swapped value: 200, swapped success: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="add操作">add操作</h3>
<p>add操作支持<code>int32</code>, <code>int64</code>,
<code>uint32</code>, <code>uint64</code>,
<code>uintptr</code>这5种基本数据类型，对应有5个add操作函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt32</span><span class="params">(addr *<span class="type">int32</span>, delta <span class="type">int32</span>)</span></span> (<span class="built_in">new</span> <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddInt64</span><span class="params">(addr *<span class="type">int64</span>, delta <span class="type">int64</span>)</span></span> (<span class="built_in">new</span> <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint32</span><span class="params">(addr *<span class="type">uint32</span>, delta <span class="type">uint32</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUint64</span><span class="params">(addr *<span class="type">uint64</span>, delta <span class="type">uint64</span>)</span></span> (<span class="built_in">new</span> <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, delta <span class="type">uintptr</span>)</span></span> (<span class="built_in">new</span> <span class="type">uintptr</span>)</span><br></pre></td></tr></table></figure>
<p>add操作实现的功能是把<code>addr</code>
指针指向的内存里的值和<code>delta</code>做加法，然后返回新值，是如下伪代码的原子实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">*addr += delta</span><br><span class="line"><span class="keyword">return</span> *addr</span><br></pre></td></tr></table></figure>
<p>我们拿<code>AddInt32</code>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个goroutine并发读写sum，有并发冲突，最终计算得到的sum值是不准确的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line">	N := <span class="number">100</span></span><br><span class="line">	wg.Add(N)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">			sum += i</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(<span class="type">int32</span>(i))</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;func test1, sum=&quot;</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用原子操作计算sum，没有并发冲突，最终计算得到sum的值是准确的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line">	N := <span class="number">100</span></span><br><span class="line">	wg.Add(N)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">			atomic.AddInt32(&amp;sum, i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(<span class="type">int32</span>(i))</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;func test2, sum=&quot;</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test1()</span><br><span class="line">	test2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序的执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func test1, <span class="built_in">sum</span>= 4857</span><br><span class="line">func test2, <span class="built_in">sum</span>= 4950</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：对于test1函数，你本地运行得到的结果可能和我的不一样，这个值并不是一个固定值。</p>
<h3 id="load操作">load操作</h3>
<p>load操作支持<code>int32</code>, <code>int64</code>,
<code>uint32</code>, <code>uint64</code>, <code>uintptr</code>,
<code>unsafe.Pointer</code>这6种基本数据类型，对应有6个load操作函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt32</span><span class="params">(addr *<span class="type">int32</span>)</span></span> (val <span class="type">int32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadInt64</span><span class="params">(addr *<span class="type">int64</span>)</span></span> (val <span class="type">int64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadPointer</span><span class="params">(addr *unsafe.Pointer)</span></span> (val unsafe.Pointer)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint32</span><span class="params">(addr *<span class="type">uint32</span>)</span></span> (val <span class="type">uint32</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUint64</span><span class="params">(addr *<span class="type">uint64</span>)</span></span> (val <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadUintptr</span><span class="params">(addr *<span class="type">uintptr</span>)</span></span> (val <span class="type">uintptr</span>)</span><br></pre></td></tr></table></figure>
<p>load操作实现的功能是返回<code>addr</code>
指针指向的内存里的值，是如下伪代码的原子实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> *addr</span><br></pre></td></tr></table></figure>
<p>我们拿<code>LoadInt32</code>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// load.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">int32</span> = <span class="number">100</span></span><br><span class="line">	result := atomic.LoadInt32(&amp;sum)</span><br><span class="line">	fmt.Println(<span class="string">&quot;result=&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序的执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">result= 100</span><br></pre></td></tr></table></figure>
<h3 id="store操作">store操作</h3>
<p>store操作支持<code>int32</code>, <code>int64</code>,
<code>uint32</code>, <code>uint64</code>, <code>uintptr</code>,
<code>unsafe.Pointer</code>这6种基本数据类型，对应有6个store操作函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt32</span><span class="params">(addr *<span class="type">int32</span>, val <span class="type">int32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreInt64</span><span class="params">(addr *<span class="type">int64</span>, val <span class="type">int64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StorePointer</span><span class="params">(addr *unsafe.Pointer, val unsafe.Pointer)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint32</span><span class="params">(addr *<span class="type">uint32</span>, val <span class="type">uint32</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUint64</span><span class="params">(addr *<span class="type">uint64</span>, val <span class="type">uint64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreUintptr</span><span class="params">(addr *<span class="type">uintptr</span>, val <span class="type">uintptr</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>store操作实现的功能是把<code>addr</code>
指针指向的内存里的值修改为<code>val</code>，是如下伪代码的原子实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">*addr = val</span><br></pre></td></tr></table></figure>
<p>我们拿<code>StoreInt32</code>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum <span class="type">int32</span> = <span class="number">100</span></span><br><span class="line">	<span class="keyword">var</span> newValue <span class="type">int32</span> = <span class="number">200</span></span><br><span class="line">	<span class="comment">// 将sum的值修改为newValue</span></span><br><span class="line">	atomic.StoreInt32(&amp;sum, newValue)</span><br><span class="line">	<span class="comment">// 读取修改后的sum值</span></span><br><span class="line">	result := atomic.LoadInt32(&amp;sum)</span><br><span class="line">	<span class="comment">// 打印结果</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;result=&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序的执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">result= 200</span><br></pre></td></tr></table></figure>
<h4 id="value类型-1">Value类型</h4>
<p>Go标准库里的<code>sync/atomic</code>包提供了<code>Value</code>类型，可以用来并发读取和修改任何类型的值。</p>
<p><code>Value</code>类型的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A Value provides an atomic load and store of a consistently typed value.</span></span><br><span class="line"><span class="comment">// The zero value for a Value returns nil from Load.</span></span><br><span class="line"><span class="comment">// Once Store has been called, a Value must not be copied.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Value must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">	v any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Value</code>类型有4个方法：<code>CompareAndSwap</code>,
<code>Load</code>, <code>Store</code>, <code>Swap</code>，定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> CompareAndSwap(old, <span class="built_in">new</span> any) (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Load() (val any)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Store(val any)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Value)</span></span> Swap(<span class="built_in">new</span> any) (old any)</span><br></pre></td></tr></table></figure>
<p>源码实现：https://cs.opensource.google/go/go/+/refs/tags/go1.18.1:src/sync/atomic/value.go</p>
<p>下面是一个具体的示例：对<code>map[string][string]</code>类型做并发读写，为了避免加锁，使用<code>value</code>
类型来读取和修改<code>map[string][string]</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfig</span><span class="params">()</span></span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 从数据库或者文件系统中读取配置信息，然后以map的形式存放在内存里</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requests</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 将从外界中接收到的请求放入到channel里</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// config变量用来存放该服务的配置信息</span></span><br><span class="line">	<span class="keyword">var</span> config atomic.Value</span><br><span class="line">	<span class="comment">// 初始化时从别的地方加载配置文件，并存到config变量里</span></span><br><span class="line">	config.Store(loadConfig())</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 每10秒钟定时拉取最新的配置信息，并且更新到config变量里</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">			<span class="comment">// 对应于赋值操作 config = loadConfig()</span></span><br><span class="line">			config.Store(loadConfig())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 创建协程，每个工作协程都会根据它所读取到的最新的配置信息来处理请求</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> r := <span class="keyword">range</span> requests() &#123;</span><br><span class="line">				<span class="comment">// 对应于取值操作 c := config</span></span><br><span class="line">				<span class="comment">// 由于Load()返回的是一个interface&#123;&#125;类型，所以我们要先强制转换一下</span></span><br><span class="line">				c := config.Load().(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">				<span class="comment">// 这里是根据配置信息处理请求的逻辑...</span></span><br><span class="line">				_, _ = r, c</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结和注意事项">总结和注意事项</h2>
<ul>
<li><p>原子操作由底层CPU的原子操作指令支持。</p></li>
<li><p>5种原子操作和<code>Value</code>类型的官方文档地址：https://pkg.go.dev/sync/atomic@go1.18.1</p></li>
<li><p>CAS操作会有ABA问题</p></li>
<li><p>对于386处理器架构，64-bit原子操作函数使用了奔腾MMX或更新处理器型号才支持的CPU指令。对于非Linux的ARM处理器架构，64-bit原子操作函数使用了ARMv6k
core或更新处理器型号才支持的CPU指令。对于ARM, 386和32-bit
MIPS处理器架构，原子操作的调用者要对进行原子访问的64bit字(
word)按照64-bit进行内存对齐。变量或者分配的结构体、数组和切片的第1个字可以认为是64-bit对齐的。(
这块涉及到内存对齐，后面抽个专题详解)</p></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>https://pkg.go.dev/sync/atomic@go1.18.1</li>
<li>https://blog.betacat.io/post/golang-atomic-value-exploration/</li>
<li>https://gfw.go101.org/article/concurrent-atomic-operation.html</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>23.并发编程之sync.Map</title>
    <url>/undefined/13a29458/</url>
    <content><![CDATA[<p>本文主要介绍Go的sync包里的Map的使用方法、定义、方法等。 <span id="more"></span>
# sync.Map</p>
<h2 id="定义">定义</h2>
<p>Map是sync包里的一个结构体类型，定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// some fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go语言里普通map的读写不是并发安全的，sync.Map的读写是并发安全的。</p>
<p>sync.Map可以理解为类似一个map[interface{}]interface{}的结构，key可以类型不一样，value也可以类型不一样，多个goroutine对其进行读写不需要额外加锁。</p>
<p><strong>Go官方设计sync.Map主要满足以下2个场景的用途</strong></p>
<ol type="1">
<li><p><strong>每个key只写一次，其它对该key的操作都是读操作</strong></p></li>
<li><p><strong>多个goroutine同时读写map，但是每个goroutine只读写各自的keys</strong></p></li>
</ol>
<p>以上2种场景，相对于对普通的map加Mutex或者RWMutex来实现并发安全，使用sync.Map不用在业务代码里加锁，会大幅减少锁竞争，提升性能。<strong>其它更为常见的场景还是使用普通的Map，搭配Mutex或者RWMutex来使用</strong>。</p>
<p>不能对sync.Map使用值传递方式进行函数调用。</p>
<p>sync.Map结构体类型有如下几个方法：</p>
<ul>
<li><p>Delete，删除map里的key，即使key不存在，执行Delete操作也没任何影响</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>Load，从map里取出key对应的value。如果key存在map里，返回值value就是对应的值，ok就是true。如果key不在map里，返回值value就是nil，ok就是false。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m* Map)</span></span> Load(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>LoadAndDelete，删除map里的key。如果key存在map里，返回值value就是对应的值，loaded就是true。如果key不在map里，返回值value就是nil，loaded就是false。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m* Map)</span></span> LoadAndDelete(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>LoadOrStore，从map里取出key对应的value。如果key在map里不存在，就把LoadOrStrore函数调用传入的参数&lt;key,
value&gt;存储到map里，并返回参数里的value。如果key在map里，那loaded是true，如果key不在map里，那loaded是false。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m* Map)</span></span> LoadOrStore(key, value <span class="keyword">interface</span>&#123;&#125;) (actual <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>Range，遍历map里的所有&lt;key, value&gt;对，把每个&lt;key,
value&gt;对，都作为参数传递给<strong>f</strong>去调用，如果遍历执行过程中，<strong>f</strong>返回false，那range迭代就结束了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m* Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>Store，往map里插入&lt;key,
vaue&gt;对，即使key已经存在于map里，也没有任何影响</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m* Map)</span></span> Store(key, value <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Delete, Load, LoadAndDelete, LoadOrStore,
Store的均摊时间复杂度是O(1)，Range的时间复杂度是O(N)</p>
<h2 id="使用">使用</h2>
<ul>
<li><p>初始化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 sync.Map</span><br><span class="line">m2 := sync.Map&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>示例1：统计字符串里每个字符出现的次数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*统计字符串里每个字符出现的次数*/</span></span><br><span class="line">    m := sync.Map&#123;&#125;</span><br><span class="line">    str := <span class="string">&quot;abcabcd&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> str &#123;</span><br><span class="line">        temp, ok := m.Load(value)</span><br><span class="line">        <span class="comment">//fmt.Println(temp, ok)</span></span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            m.Store(value, <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*temp是个interface变量，要转int才能和1做加法*/</span></span><br><span class="line">            m.Store(value, temp.(<span class="type">int</span>)+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*使用sync.Map里的Range遍历map*/</span></span><br><span class="line">    m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>&#123;</span><br><span class="line">        fmt.Println(key, value)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>示例2：多个goroutine并发写sync.Map，不加锁。如果是普通的map，这么来写就会出现运行时错误“fatal
error: concurrent map writes”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m sync.Map</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sync.Map里每个key只写一次，属于场景1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeMap</span><span class="params">(key <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m.Store(key, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    size := <span class="number">2</span></span><br><span class="line">    wg.Add(size)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        i := i</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            changeMap(i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*使用sync.Map里的Range遍历map*/</span></span><br><span class="line">    m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>&#123;</span><br><span class="line">        fmt.Println(key, value)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注意事项">注意事项</h2>
<ul>
<li><p>sync.Map不支持len和cap函数</p></li>
<li><p>在评估要不要使用sync.Map的时候，先考察业务场景是否符合上面描述的场景1和2，符合再考虑用sync.Map，不符合就用普通map+Mutex或者RWMutex。</p></li>
</ul>
<h2 id="references">References</h2>
<p>https://pkg.go.dev/sync@go1.17.2#Map</p>
]]></content>
      <categories>
        <category>Golang</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>22.并发编程之sync.Cond</title>
    <url>/undefined/2463f2ef/</url>
    <content><![CDATA[<p>本文主要介绍Go的sync包的sync.Cond的使用方法、定义、方法等。
<span id="more"></span> # sync.Cond</p>
<h2 id="定义">定义</h2>
<p>Cond是sync包里的一个结构体类型，表示条件变量。我们知道sync.WaitGroup可以用于等待所有goroutine都执行完成，<strong>sync.Cond可以用于控制goroutine什么时候开始执行</strong>。</p>
<p>Cond结构体类型定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    L Locker</span><br><span class="line">    <span class="comment">// some other fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cond结构体类型以下几个方法与其紧密相关：</p>
<ul>
<li><p>NewCond函数，用于创建条件变量，条件变量的成员<code>L</code>是NewCond函数的参数<code>l</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span></span> *Cond</span><br></pre></td></tr></table></figure></li>
<li><p>Broadcast，发出广播，唤醒所有等待条件变量c的goroutine开始执行。<strong>注意</strong>：在调用Broadcast方法之前，要确保目标goroutine处于Wait阻塞状态，不然会出现死锁问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast()</span><br></pre></td></tr></table></figure></li>
<li><p>Signal，发出信号，唤醒某一个等待条件变量c的goroutine开始执行。<strong>注意</strong>：在调用Signal方法之前，要确保目标goroutine处于Wait阻塞状态，不然会出现死锁问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal()</span><br></pre></td></tr></table></figure></li>
<li><p>Wait，这个方法会解锁c.L以及阻塞当前goroutine往下执行，解锁和阻塞组合在一起构成原子操作。Wait被Broadcast或者Signal唤醒时，会先对c.L加锁，然后Wait才return返回。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>每个Cond变量都有一个Locker类型的成员L，L通常是*Mutex或者*RWMutex类型，<strong>调用Wait方法时要对L加锁</strong>。</p>
<p>不要对Cond变量使用值传递进行函数调用。</p>
<h2 id="示例">示例</h2>
<p>下面这个示例，先开启了10个goroutine，这10个goroutine都进入Wait阻塞状态，等待被唤醒。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">    <span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line">    cond := sync.NewCond(&amp;mutex)</span><br><span class="line">    size := <span class="number">10</span></span><br><span class="line">    wg.Add(size+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        i := i</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="comment">/*调用Wait方法时，要对L加锁*/</span></span><br><span class="line">            cond.L.Lock()</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%d ready\n&quot;</span>, i)</span><br><span class="line">            <span class="comment">/*Wait实际上是会先解锁cond.L，再阻塞当前goroutine</span></span><br><span class="line"><span class="comment">            这样其它goroutine调用上面的cond.L.Lock()才能加锁成功，才能进一步执行到Wait方法，</span></span><br><span class="line"><span class="comment">            等待被Broadcast或者signal唤醒。</span></span><br><span class="line"><span class="comment">            Wait被Broadcast或者Signal唤醒的时候，会再次对cond.L加锁，加锁后Wait才会return</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            cond.Wait()</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%d done\n&quot;</span>, i)</span><br><span class="line">            cond.L.Unlock()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*这里sleep 2秒，确保目标goroutine都处于Wait阻塞状态</span></span><br><span class="line"><span class="comment">    如果调用Broadcast之前，目标goroutine不是处于Wait状态，会死锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        cond.Broadcast()</span><br><span class="line">    &#125;()</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="references">References</h2>
<p>https://pkg.go.dev/sync@go1.17.2#Cond</p>
]]></content>
      <categories>
        <category>Golang</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>21.并发编程之sync.Mutex和sync.RWMutex</title>
    <url>/undefined/e1832eac/</url>
    <content><![CDATA[<p>本文主要介绍Go的sync包里的Mutex和RWMutex的使用方法，包括定义、方法等。
<span id="more"></span> # sync.Mutex和sync.RWMutex</p>
<h2 id="sync.mutex">sync.Mutex</h2>
<h3 id="定义">定义</h3>
<p>Mutex是sync包里的一个结构体类型，含义就是互斥锁。Mutex变量的默认值或者说零值是一个没有加锁的mutex，也就是当前mutex的状态是unlocked。</p>
<p>不要对Mutex使用值传递方式进行函数调用。</p>
<p>Mutex允许一个goroutine对其加锁，其它goroutine对其解锁，不要求加锁和解锁在同一个goroutine里。</p>
<p>Mutex结构体类型有2个方法</p>
<ul>
<li><p>Lock()加锁。Lock()方法会把Mutex变量m锁住，如果m已经锁住了，如果再次调用Lock()就会阻塞，直到锁释放。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock()</span><br></pre></td></tr></table></figure></li>
<li><p>Unlock()解锁。Unlock()方法会把Mutex变量m解锁，如果m没有被锁，还去调用Unlock，会遇到runtime
error。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="不加锁">不加锁</h3>
<ul>
<li><p>场景举例：多个
goroutine对共享变量同时执行写操作，并发是不安全的，结果和预期不符。</p></li>
<li><p>示例代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum <span class="type">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*多个goroutine同时访问add</span></span><br><span class="line"><span class="comment">sum是多个goroutine共享的</span></span><br><span class="line"><span class="comment">也就是多个goroutine同时对共享变量sum做写操作不是并发安全的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	size := <span class="number">100</span></span><br><span class="line">	wg.Add(size)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=size; i++ &#123;</span><br><span class="line">		i := i</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			add(i)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;sum of 1 to %d is: %d\n&quot;</span>, size, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="加锁">加锁</h3>
<ul>
<li><p>示例代码，通过对共享变量加互斥锁来保证并发安全，结果和预期相符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum <span class="type">int</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"><span class="comment">/*多个goroutine同时访问add</span></span><br><span class="line"><span class="comment">sum是多个goroutine共享的</span></span><br><span class="line"><span class="comment">通过加互斥锁来保证并发安全</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	mutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mutex.Unlock()</span><br><span class="line">	sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	size := <span class="number">100</span></span><br><span class="line">	wg.Add(size)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=size; i++ &#123;</span><br><span class="line">		i := i</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			add(i)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;sum of 1 to %d is: %d\n&quot;</span>, size, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="sync.rwmutex">sync.RWMutex</h2>
<h3 id="定义-1">定义</h3>
<p>RWMutex是sync包里的一个结构体类型，含义是读写锁。RWMutex变量的零值是一个没有加锁的mutex。</p>
<p>不要对RWMutex变量使用值传递的方式进行函数调用。</p>
<p>RWMutex允许一个goroutine对其加锁，其它goroutine对其解锁，不要求加锁和解锁在同一个goroutine里。</p>
<p>RWMutex结构体类型的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// some fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RWMutex结构体类型有5个方法：</p>
<ul>
<li><p>Lock()，加写锁。某个goroutine加了写锁后，其它goroutine不能获取读锁，也不能获取写锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock()</span><br></pre></td></tr></table></figure></li>
<li><p>Unlock()，释放写锁。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock()</span><br></pre></td></tr></table></figure></li>
<li><p>RLock()，加读锁。某个goroutine加了读锁后，其它goroutine可以获取读锁，但是不能获取写锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock()</span><br></pre></td></tr></table></figure></li>
<li><p>RUnlock()，释放读锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock()</span><br></pre></td></tr></table></figure></li>
<li><p>RLocker()，获取一个类型为Locker的接口，Locker类型定义了Lock()和Unlock()方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLocker() Locker</span><br></pre></td></tr></table></figure>
<p>类型Locker的定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Mutex和RWMutex这2个结构体类型实现了Locker这个interface里的所有方法，因此可以把Mutex和RWMutex变量或者指针赋值给Locker实例，然后通过Locker实例来加锁和解锁，这个在条件变量sync.Cond里会用到，可以参考<a
href="./workspace/lesson24">sync.Cond</a></p></li>
</ul>
<h3 id="示例">示例</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    成员count:计数器</span></span><br><span class="line"><span class="comment">    成员rw: 读写锁，用于实现count的读写并发安全</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    count <span class="type">int</span></span><br><span class="line">    rw sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> getCounter() <span class="type">int</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    读数据的时候加读锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    c.rw.RLock()</span><br><span class="line">    <span class="keyword">defer</span> c.rw.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> c.count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> add() &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    写数据的时候加写锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    c.rw.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.rw.Unlock()</span><br><span class="line">    c.count++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    size := <span class="number">100</span></span><br><span class="line">    wg.Add(size)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> c Counter</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    开启size个goroutine对变量c的数据成员count同时进行读写操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            c.getCounter()</span><br><span class="line">            c.add()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;count=&quot;</span>, c.count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项">注意事项</h2>
<ul>
<li>Mutex和RWMutex都不是递归锁，不可重入</li>
</ul>
<h2 id="references">References</h2>
<ul>
<li><p>https://pkg.go.dev/sync@go1.17.2#Mutex</p></li>
<li><p>https://pkg.go.dev/sync@go1.17.2#RWMutex</p></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>20.并发编程之sync.Once</title>
    <url>/undefined/b89422d4/</url>
    <content><![CDATA[<p>本文主要介绍Go的sync包的sync.Once的使用方法、定义、方法等。
<span id="more"></span> # sync.Once</p>
<h2 id="定义">定义</h2>
<p>Once是sync包里的一个结构体类型，Once可以在并发场景下让某个操作只执行一次，比如设计模式里的单例只创建一个实例，比如只加载一次配置文件，比如对同一个channel只关闭一次（对一个已经close的channel再次close会引发panic）等。</p>
<p>定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// some fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体只有1个方法Do，参数是要执行的函数。（<strong>注意</strong>：参数是函数类型，而不是函数的返回值，所以只需要把函数名作为参数给到Do即可）</p>
<p>可以看到Do方法的参数<strong>f</strong>这个函数类型没有参数，所以如果要执行的函数f需要传递参数就要结合Go的闭包来使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(o *Once)</span></span> Do(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>)</span><br></pre></td></tr></table></figure>
<p>参考下面的例子，print函数通过Once执行，只会执行1次</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;test once&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line">    size := <span class="number">10</span></span><br><span class="line">    wg.Add(size)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*启用size个goroutine，每个goroutine都调用once.Do(print)</span></span><br><span class="line"><span class="comment">    最终print只会执行一次</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            once.Do(<span class="built_in">print</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*等待所有goroutine执行完成*/</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sync.once实现并发安全的单例">sync.Once实现并发安全的单例</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">    member <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Singleton</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过sync.Once实现单例，只会生成一个Singleton实例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;once&quot;</span>)</span><br><span class="line">        instance = &amp;Singleton&#123;&#125;</span><br><span class="line">        instance.member = <span class="number">100</span></span><br><span class="line">    &#125;)</span><br><span class="line">    fmt.Println(instance.member)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    size := <span class="number">10</span></span><br><span class="line">    wg.Add(size)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    多个goroutine同时去获取Singelton实例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            instance = getInstance()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项">注意事项</h2>
<ul>
<li><p>Once变量作为函数参数传递时，只能传指针，不能传值。传值给函数A的话，对于函数A而言，参数列表里的once形参会是一个新生成的once局部变量，和外部传入的once实参不一样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;test once&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(once *sync.Once)</span></span> &#123;</span><br><span class="line">    once.Do(test)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line">    size := <span class="number">10</span></span><br><span class="line">    wg.Add(size)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*启用size个goroutine，每个goroutine都调用once.Do(print)</span></span><br><span class="line"><span class="comment">    最终print只会执行一次</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="built_in">print</span>(&amp;once)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*等待所有goroutine执行完成*/</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果once.Do(f)方法调用的函数<strong>f</strong>发生了panic，那Do也会认为函数<strong>f</strong>已经return了。</p></li>
<li><p>如果多个goroutine执行了都去调用once.Do(f)，只有某次的函数<strong>f</strong>调用返回了，所有Do方法调用才会返回，否则Do方法会一直阻塞等待。如果在f里继续调用同一个once变量的Do方法，就会死锁了，因为Do在等待<strong>f</strong>返回，<strong>f</strong>又在等待Do返回。</p></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>19.并发编程之sync包介绍和sync.WaitGroup</title>
    <url>/undefined/675fd54b/</url>
    <content><![CDATA[<p>本文主要介绍Go的sync包的使用方法，包括sync.WaitGroup的介绍、定义、方法等。
<span id="more"></span> # 并发编程之sync包介绍和sync.WaitGroup</p>
<h2 id="sync包介绍">sync包介绍</h2>
<p>sync包提供了基本的并发编程同步原语(concurrency primitives or
synchronization
primitives)，例如互斥锁sync.Mutex。sync包囊括了以下数据类型：</p>
<ul>
<li>sync.Cond</li>
<li>sync.Locker</li>
<li>sync.Map</li>
<li>sync.Mutex</li>
<li>sync.Once</li>
<li>sync.Pool</li>
<li>sync.RWMutex</li>
<li>sync.WaitGroup</li>
</ul>
<p>除了sync.Once和sync.WaitGroup这2个类型之外，其它类型主要给一些偏底层的库程序用。业务代码里的goroutine同步，Go设计者是建议通过channel通信来实现。</p>
<h2 id="sync.waitgroup">sync.WaitGroup</h2>
<p>WaitGroup是sync包里的一个结构体类型，定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// some fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体有如下3个方法</p>
<ul>
<li><p>Add：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>Done：Done调用会将WiatGroup的计数器减1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done()</span><br></pre></td></tr></table></figure></li>
<li><p>Wait：Wait调用会阻塞，直到WaitGroup的计数器为0</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait()</span><br></pre></td></tr></table></figure></li>
</ul>
<p>定义一个WaitGroup变量的目的是为了等待若干个goroutine执行完成，主goroutine调用Add方法，指明要等待的子goroutine数量，这些子goroutine执行完成后调用Done方法。同时，主goroutine要调用Wait方法阻塞程序，等WaitGroup的计数器减小到0时，Wait方法不再阻塞。</p>
<p>示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">/*worker执行完成后，会调用Done将wg计数器减1*/</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d starting\n&quot;</span>, id)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/* wg跟踪10个goroutine */</span></span><br><span class="line">    size := <span class="number">10</span></span><br><span class="line">    wg.Add(size)</span><br><span class="line">    <span class="comment">/* 开启10个goroutine并发执行 */</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Wait一直阻塞，直到wg的计数器变为0 */</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>注意事项</strong></p>
<ul>
<li><p>WaitGroup不要拷贝传值，如果要显式地把WaitGroup作为函数参数，<strong>一定要传指针</strong>。</p>
<p>WaitGroup给函数A传值，在函数A内部这个WaitGroup会是一个局部变量，对WaitGroup的操作只会在函数内部生效。示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, wg sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="comment">/*worker执行完成后，会调用Done将wg计数器减1*/</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d starting\n&quot;</span>, id)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="comment">/* wg跟踪10个goroutine */</span></span><br><span class="line">    size := <span class="number">10</span></span><br><span class="line">    wg.Add(size)</span><br><span class="line">    <span class="comment">/* 开启10个goroutine并发执行 */</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(i, wg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 这个例子里Wait会一直阻塞，因为函数worker内部的Done调用对外部的wg其实不生效*/</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行时wg.Wait()会报错：fatal error: all goroutines are asleep -
deadlock!</p>
<p>改为下面的传指针就正常了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="comment">/*worker执行完成后，会调用Done将wg计数器减1*/</span></span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d starting\n&quot;</span>, id)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="comment">/* wg跟踪10个goroutine */</span></span><br><span class="line">    size := <span class="number">10</span></span><br><span class="line">    wg.Add(size)</span><br><span class="line">    <span class="comment">/* 开启10个goroutine并发执行 */</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        <span class="comment">/*wg传指针给worker*/</span></span><br><span class="line">        <span class="keyword">go</span> worker(i, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Wait会一直阻塞，直到wg的计数器为0*/</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="references">references</h2>
<ul>
<li>https://pkg.go.dev/sync@go1.17.2</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>18.goroutine和channel</title>
    <url>/undefined/f2a18148/</url>
    <content><![CDATA[<p>本文主要介绍goroutine和channel的概念、语法、注意事项等。
<span id="more"></span></p>
<h1 id="goroutine和channel">goroutine和channel</h1>
<h2 id="goroutine">goroutine</h2>
<h3 id="概念和语法">概念和语法</h3>
<ul>
<li><p>定义：goroutine是轻量级的用户态线程，可以在代码里创建成千上万个goroutine来并发工作。如此多的goroutine是Go运行时来调度的。Go运行时会把goroutine的任务分配给CPU去执行。<strong>注意</strong>，goroutine不是我们通常理解的线程，线程是操作系统调度的。</p></li>
<li><p>Go编程里不需要自己在代码里写线程和协程，想让某个任务并发执行，就把这个任务封装为一个函数，然后启动一个goroutine去执行这个函数就行了。</p></li>
<li><p>语法：go 函数名([参数列表])，示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	<span class="comment">/*开启一个goroutine去执行hello函数*/</span></span><br><span class="line">		<span class="keyword">go</span> hello()</span><br><span class="line">		fmt.Println(<span class="string">&quot;main end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Go会为main()函数创建一个默认的goroutine，如果main()函数结束了，那所有在main()中启动的goroutine都会立马结束。比如下面的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*开启一个goroutine去执行hello函数*/</span></span><br><span class="line">    <span class="keyword">go</span> hello()</span><br><span class="line">    fmt.Println(<span class="string">&quot;main end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果可能有以下3种：</p>
<ul>
<li><p>main end // 只打印main end</p></li>
<li><p>main end // 先打印main end，再打印hello</p>
<p>hello</p></li>
<li><p>hello // 先打印hello，再打印main end</p>
<p>main end</p></li>
</ul>
<p>这是因为main函数的goroutine和hello这个goroutine是并发执行的，有可能main执行完了，hello还没执行，这个时候只打印main
end。有可能hello先执行完，main后执行完，也可能反过来。所以共有3种情况。</p></li>
</ul>
<h3 id="goroutine注意事项">goroutine注意事项</h3>
<p><strong>goroutine和闭包closure一起使用时要注意</strong>，避免多个goroutine闭包使用同一个变量，否则goroutine执行的时候，这个变量的值可能已经被改了，和原来预期不符。比如下面例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d starting\n&quot;</span>, id)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="comment">/* wg跟踪10个goroutine */</span></span><br><span class="line">    size := <span class="number">10</span></span><br><span class="line">    wg.Add(size)</span><br><span class="line">    <span class="comment">/* 开启10个goroutine并发执行 */</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            worker(i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Wait会一直阻塞，直到wg的计数器为0*/</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在for循环里，用到了goroutine和闭包，每个闭包共享变量<code>i</code>，在闭包真正执行的时候，闭包里面用到的变量<strong>i</strong>的值可能已经被改了，所以闭包里调用worker的时候的传参i就不是想象中的从0到9。</p>
<p>有2种方法规避</p>
<ul>
<li><p>方法1，把变量作为闭包的参数传给闭包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d starting\n&quot;</span>, id)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="comment">/* wg跟踪10个goroutine */</span></span><br><span class="line">    size := <span class="number">10</span></span><br><span class="line">    wg.Add(size)</span><br><span class="line">    <span class="comment">/* 开启10个goroutine并发执行 */</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            worker(id)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Wait会一直阻塞，直到wg的计数器为0*/</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法2，在启动goroutine执行闭包前，定义一个新的变量<strong>i</strong>，这样每个闭包就可以用各自预期的变量值了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d starting\n&quot;</span>, id)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="comment">/* wg跟踪10个goroutine */</span></span><br><span class="line">    size := <span class="number">10</span></span><br><span class="line">    wg.Add(size)</span><br><span class="line">    <span class="comment">/* 开启10个goroutine并发执行 */</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        <span class="comment">/*定义一个新的变量*/</span></span><br><span class="line">        i := i</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            worker(i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Wait会一直阻塞，直到wg的计数器为0*/</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>多个goroutine之间可以通过channel来通信</p></li>
</ul>
<h2 id="channel">channel</h2>
<h3 id="概念和语法-1">概念和语法</h3>
<ul>
<li><p>定义：channel是一种类型，零值是nil。</p>
<p>多个goroutine之间，可以通过channel来通信，一个goroutine可以发送数据到指定channel，其它goroutine可以从这个channel里接收数据。</p>
<p>channel就像队列，满足FIFO原则，定义channel的时候必须指定channel要传递的元素类型。</p></li>
<li><p>语法：</p>
<p><strong>未初始化的channel变量的值是nil，为nil的channel不能用于通信</strong>。nil
channel收发消息都会阻塞，可能引起死锁。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*channel_name是变量名，data_type是通道里的数据类型</span></span><br><span class="line"><span class="comment">channel_size是channel通道缓冲区的容量，表示最多可以存放的元素个数，这个参数是可选的，不给就表示没有缓冲区，通过cap()函数可以获取channel的容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> channel_name <span class="keyword">chan</span> data_type = <span class="built_in">make</span>(<span class="keyword">chan</span> data_type, [channel_size])</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span> </span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> ch3 <span class="keyword">chan</span> []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> ch4 <span class="keyword">chan</span> struct_type <span class="comment">// 可以往通道传递结构体变量</span></span><br><span class="line"></span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch6 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">100</span>)</span><br><span class="line">ch7 := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br><span class="line">ch8 := <span class="built_in">make</span>(<span class="keyword">chan</span> struct_type)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="channel三种操作">channel三种操作</h3>
<p>channel有3种操作，发送数据，接收数据和关闭channel。发送和接收都是用<code>&lt;-</code>符号</p>
<ul>
<li><p>发送值到通道：channel &lt;- value</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch里</span></span><br></pre></td></tr></table></figure></li>
<li><p>从通道接收值：value &lt;- channel</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">x := &lt;-ch <span class="comment">// 从通道ch里接收值，并赋值给变量x</span></span><br><span class="line">&lt;-ch <span class="comment">// 从通道里接收值，不做其它处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y <span class="type">int</span></span><br><span class="line">y = &lt;-ch <span class="comment">// 从通道ch里接收值，并赋值给变量y</span></span><br></pre></td></tr></table></figure></li>
<li><p>关闭通道: close(channel)，关闭nil
channel会触发<code>panic: close of nil channel</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="built_in">close</span>(ch) <span class="comment">// 关闭通道</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="channel缓冲区">channel缓冲区</h3>
<p>channel默认没有缓冲区，可以在定义channel的时候指定缓冲区容量，也就是缓冲区最多可以存储的元素个数，通过内置函数<strong>cap</strong>可以获取到channel的容量。</p>
<h4 id="无缓冲区情况">无缓冲区情况</h4>
<p>channel无缓冲区的时候，往channel发送数据和从channel接收数据都会<strong>阻塞</strong>。</p>
<p>往channel发送数据的时候，必须有其它goroutine从channel里接收了数据，发送操作才可以成功，发送操作所在的goroutine才能继续往下执行。从channel里接收数据也是同理，必须有其它goroutine往channel里发送了数据，接收操作才可以成功，接收操作所在的goroutine才能继续往下执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchChannel</span><span class="params">(ch <span class="keyword">chan</span> Cat)</span></span> &#123;</span><br><span class="line">	value := &lt;- ch</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type: %T, value: %v\n&quot;</span>, value, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Cat)</span><br><span class="line">	a := Cat&#123;<span class="string">&quot;yingduan&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">	<span class="comment">// 启动一个goroutine，用于从ch这个通道里获取数据</span></span><br><span class="line">	<span class="keyword">go</span> fetchChannel(ch)</span><br><span class="line">	<span class="comment">// 往cha这个通道里发送数据</span></span><br><span class="line">	ch &lt;- a</span><br><span class="line">	<span class="comment">// main这个goroutine在这里等待2秒</span></span><br><span class="line">	time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的例子，有2个点可以<strong>思考</strong>下</p>
<ul>
<li><p>如果go fetchChannel(ch)和下面的
ch&lt;-a这2行交换顺序会怎么样？</p>
<p>Answer:
如果交换了顺序，main函数就会堵塞在ch&lt;-a这一行，因为这个发送是阻塞的，不会往下执行，这个时候没有任何goroutine会从channel接收数据，错误信息如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fatal <span class="type">error</span>: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure></li>
<li><p>如果没有time.Sleep(2*time.Second)这一行，那程序运行结果会是怎么样？</p>
<p>Answer:
可能main函数里的end和函数fetchChannel里的print内容都打印，<strong>也可能只会打印main函数里的end</strong>。因为fetchChannel里的value
:=
&lt;-ch执行之后，main里的ch&lt;-a就不再阻塞，继续往下执行了，所以可能main里最后的fmt.Println比fetchChannel里的fmt.Printf先执行，main执行完之后程序就结束了，所有goroutine自动结束，就不再执行fetchChannel里的fmt.Printf了。main里加上time.Sleep就可以允许fetchChannel这个goroutine有足够的时间执行完成。</p></li>
</ul>
<h4 id="有缓冲区情况">有缓冲区情况</h4>
<p>可以在初始化channel的时候通过make指定channel的缓冲区容量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>) <span class="comment">// 定义了一个可以缓冲区容量为100的channel</span></span><br></pre></td></tr></table></figure>
<p>对于有缓冲区的channel，对发送方而言：</p>
<ul>
<li>如果缓冲区未满，那发送方发送数据到channel缓冲区后，就可以继续往下执行，不用阻塞等待接收方从channel里接收数据。</li>
<li>如果缓冲区已满，那发送方发送数据到channel会阻塞，直到接收方从channel里接收了数据，这样缓冲区才有空间存储发送方发送的数据，发送方所在goroutine才能继续往下执行。</li>
</ul>
<p>对于接收方而言，在有值可以从channel接收之前，会一直阻塞。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// 下面2个发送操作不用阻塞等待接收方接收数据</span></span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">	ch &lt;- <span class="number">20</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	如果添加下面这行代码，就会一直阻塞，因为缓冲区已满，运行会报错</span></span><br><span class="line"><span class="comment">	fatal error: all goroutines are asleep - deadlock!</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	ch &lt;- 30</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	fmt.Println(&lt;-ch) <span class="comment">// 10</span></span><br><span class="line">	fmt.Println(&lt;-ch) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历通道channel">遍历通道channel</h3>
<ul>
<li><p>range迭代从channel里不断取数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addData</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	每3秒往通道ch里发送一次数据</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	size := <span class="built_in">cap</span>(ch)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">		time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 数据发送完毕，关闭通道</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// 开启一个goroutine，用于往通道ch里发送数据</span></span><br><span class="line">	<span class="keyword">go</span> addData(ch)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* range迭代从通道ch里获取数据</span></span><br><span class="line"><span class="comment">	通道close后，range迭代取完通道里的值后，循环会自动结束</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的例子，有个点可以思考下：</p>
<ul>
<li><p>如果删掉close(ch)这一行代码，结果会怎么样？</p>
<p>Answer:
如果通道没有close，采用range从channel里循环取值，当channel里的值取完后，range会阻塞，如果没有继续往channel里发送值，go运行时会报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fatal <span class="type">error</span>: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>for死循环不断获取channel里的数据，如果channel的值取完后，继续从channel里获取，会存在2种情况</p>
<ul>
<li>如果channel已经被close了，继续从channel里获取值会拿到对应channel里数据类型的零值</li>
<li>如果channel没有被close，也不再继续往channel里发送数据，接收方会阻塞报错</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addData</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	每3秒往通道ch里发送一次数据</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	size := <span class="built_in">cap</span>(ch)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">		time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 数据发送完毕，关闭通道</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// 开启一个goroutine，用于往通道ch里发送数据</span></span><br><span class="line">	<span class="keyword">go</span> addData(ch)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	for循环取完channel里的值后，因为通道close了，再次获取会拿到对应数据类型的零值</span></span><br><span class="line"><span class="comment">	如果通道不close，for循环取完数据后就会阻塞报错</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		value, ok := &lt;-ch</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			fmt.Println(value)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;finish&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="单向通道">单向通道</h3>
<p>如果channel作为函数的形参，可以控制限制数据和channel之间的数据流向，控制只能往channel发送数据或者只能从channel接收数据。</p>
<p>不做限制的时候，channel是双向的，既可以往channel写数据，也可以从channel读数据。</p>
<ul>
<li><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">chan</span> &lt;- <span class="type">int</span> <span class="comment">// 只写，只能往channel写数据，不能从channel读数据</span></span><br><span class="line">&lt;- <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// 只读，只能从channel读数据，不能往channel写数据</span></span><br></pre></td></tr></table></figure></li>
<li><p>实例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(ch <span class="keyword">chan</span>&lt;-<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数ch是只写channel，不能从channel读数据，否则编译报错</span></span><br><span class="line"><span class="comment">	receive from send-only type chan&lt;- int</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	ch &lt;- <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数ch是只读channel，不能往channel里写数据，否则编译报错</span></span><br><span class="line"><span class="comment">	send to receive-only type &lt;-chan int</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> write(ch)</span><br><span class="line">	<span class="keyword">go</span> read(ch)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待3秒，保证write和read这2个goroutine都可以执行完成</span></span><br><span class="line">	time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="channel注意事项">channel注意事项</h3>
<ul>
<li>channel被close后，如果再往channel里发送数据，会引发panic</li>
<li>channel被close后，如果再次close，也会引发panic</li>
<li>channel被close后，如果channel还有值，接收方可以一直从channel里获取值，直到channel里的值都已经取完。</li>
<li>channel被close后，如果channel里没有值了，接收方继续从channel里取值，会得到channel里存的数据类型对应的默认零值，如果一直取值，就一直拿到零值。</li>
<li><a
href="https://github.com/jincheng9/go-tutorial/tree/main/workspace/senior/p9">从Go面试题看channel注意事项</a></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>https://go.dev/doc/faq#closures_and_goroutines</li>
<li>https://www.liwenzhou.com/posts/Go/14_concurrence/</li>
<li>https://github.com/jincheng9/go-tutorial/tree/main/workspace/senior/p9</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Go-cli</title>
    <url>/undefined/5d128426/</url>
    <content><![CDATA[<p>本文主要介绍Go标准库之cmd命令使用详解，包括go命令的基本使用、go命令的子命令、go命令的参数、go命令的返回值、go命令的错误处理、go命令的环境变量、go命令的模块管理、go命令的编译运行、go命令的单元测试、go命令的代码检查等内容。
<span id="more"></span> # Go标准库之cmd命令使用详解</p>
<h2 id="go命令">go命令</h2>
<p>语法：go <command> [arguments]</p>
<p>go命令支持的命令有如下这些：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">bug         start a bug report</span><br><span class="line">build       compile packages and dependencies</span><br><span class="line">clean       remove object files and cached files</span><br><span class="line">doc         show documentation <span class="keyword">for</span> <span class="keyword">package</span> or symbol</span><br><span class="line">env         <span class="built_in">print</span> Go environment information</span><br><span class="line">fix         update packages to use <span class="built_in">new</span> APIs</span><br><span class="line">fmt         gofmt (reformat) <span class="keyword">package</span> sources</span><br><span class="line">generate    generate Go files by processing source</span><br><span class="line">get         add dependencies to current module and install them</span><br><span class="line">install     compile and install packages and dependencies</span><br><span class="line">list        list packages or modules</span><br><span class="line">mod         module maintenance</span><br><span class="line">run         compile and run Go program</span><br><span class="line">test        test packages</span><br><span class="line">tool        run specified <span class="keyword">go</span> tool</span><br><span class="line">version     <span class="built_in">print</span> Go version</span><br><span class="line">vet         report likely mistakes in packages</span><br></pre></td></tr></table></figure>
<p>如果不知道这些命令怎么用，可以使用go help <cmd>查看官方说明。</p>
<h3 id="简单的">简单的</h3>
<h4 id="go-bug给go语言官方提bug">go bug(给go语言官方提bug)</h4>
<p>命令语法：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go bug</span><br></pre></td></tr></table></figure>
<p>在终端(terminal)执行这个命令，会自动跳转到GitHub上的go语言官方repo，自动开1个issue</p>
<h4 id="go-env处理go环境变量">go env(处理go环境变量)</h4>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> [-json] [-u] [-w] [var ...]</span><br></pre></td></tr></table></figure>
<p>-json：表示把结果以json格式展示，只在查看环境变量的时候使用，不能和-u,
-w放在一起使用</p>
<p>-u:
u表示unset，恢复环境变量的默认设置，后面必须有环境变量的名称，表示具体恢复哪个环境变量的值</p>
<p>-w:
w表示write，设置环境变量的值，后面必须跟name=value的形式，表示把环境变量name的值设置为value</p>
<p>主要4个场景的用法</p>
<ul>
<li><p>查看全部环境变量的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line">go <span class="built_in">env</span></span><br><span class="line"><span class="comment"># 方法2：以json形式展示结果</span></span><br><span class="line">go <span class="built_in">env</span> -json</span><br></pre></td></tr></table></figure></li>
<li><p>查看具体某个(1个或者多个)环境变量的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line">go <span class="built_in">env</span> GO111MODULE GOPATH</span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line">go <span class="built_in">env</span> | grep GO111MODULE</span><br><span class="line"><span class="comment"># 方法3</span></span><br><span class="line">go <span class="built_in">env</span> | findstr GO111MODULE</span><br></pre></td></tr></table></figure></li>
<li><p>设置某个(1个或者多个)环境变量的值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> -w GO111MODULE=on</span><br></pre></td></tr></table></figure></li>
<li><p>恢复某个(1个或者多个)环境变量的值为默认值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go <span class="built_in">env</span> -u GO111MODULE</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="go-version查看可执行文件的go版本">go
version(查看可执行文件的go版本)</h4>
<p>命令语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> version [-m] [-v] [file ...]</span><br></pre></td></tr></table></figure>
<p>go
version既可以用来查看当前系统安装的go的版本号，也可以查看可执行文件是使用哪个版本的go编译出来的，命令里最后一个参数既可以是可执行文件，也可以是目录。</p>
<p>-m:
m代指module，后面必须带上可执行文件或者目录作为参数，用于展示可执行文件依赖的模块的版本信息</p>
<p>-v:
v代指verbose，表示打印更为详细的信息，最后一个参数是目录的时候才真正起作用</p>
<ul>
<li><p>查看当前系统安装的go的版本号</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure></li>
<li><p>查看可执行文件是使用哪个版本的go编译生成的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go version binfile</span><br></pre></td></tr></table></figure>
<p>比如我们使用go build main.go
编译生成了一个可执行文件main，那就可以使用如下命令来查看main这个可执行文件是使用哪个版本的go编译出来的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go version main</span><br></pre></td></tr></table></figure></li>
<li><p>查看目录下的所有可执行文件是使用哪个版本的go编译生成的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go version <span class="built_in">dir</span></span><br></pre></td></tr></table></figure></li>
<li><p>查看可执行文件使用的go版本以及可执行文件依赖的模块信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go version -m binfile</span><br><span class="line">go version -m <span class="built_in">dir</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="代码检查">代码检查</h3>
<h4 id="go-fmt">go fmt</h4>
<h4 id="go-vet">go vet</h4>
<p>命令语法：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go vet [-n] [-x] [-vettool prog] [build flags] [vet flags] [packages]</span><br></pre></td></tr></table></figure>
<p>vet的中文含义是”审查“，因此这个命令就是对Go代码做检查，报告潜在可能的错误</p>
<h4 id="go-fix">go fix</h4>
<h3 id="编译运行">编译运行</h3>
<h4 id="go-build">go build</h4>
<h4 id="go-clean">go clean</h4>
<h4 id="go-run">go run</h4>
<h3 id="单元测试">单元测试</h3>
<h4 id="go-test">go test</h4>
<h3 id="模块管理">模块管理</h3>
<h4 id="go-mod">go mod</h4>
<h4 id="go-install">go install</h4>
<h4 id="go-get">go get</h4>
<p>更新go.sum?写个example</p>
<h4 id="go-list">go list</h4>
<h2 id="references">References</h2>
<ul>
<li>https://pkg.go.dev/cmd/go</li>
<li>https://github.com/hyper0x/go_command_tutorial</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>17.Go-defer语义</title>
    <url>/undefined/362a394c/</url>
    <content><![CDATA[<p>本文主要介绍Go中defer语义的含义和用途，以及注意事项。 <span id="more"></span> #
defer语义</p>
<h2 id="defer含义">defer含义</h2>
<ul>
<li><p>defer是延迟的意思，在Go里可以放在某个函数或者方法调用的前面，让该函数或方法延迟执行</p></li>
<li><p>语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> function([parameter_list]) <span class="comment">// 延迟执行函数</span></span><br><span class="line"><span class="keyword">defer</span> method([parameter_list]) <span class="comment">// 延迟执行方法</span></span><br></pre></td></tr></table></figure>
<p>defer本身是在某个函数体内执行，比如在函数A内调用了defer
func_name()，只要defer
func_name()这行代码被执行到了，那func_name这个函数就会<strong>被延迟到函数A
return或者panic之前执行</strong>。</p>
<p><strong>注意</strong>：如果是函数是因为调用了<code>os.Exit()</code>而退出，那<code>defer</code>就不会被执行了。参见<a
href="https://github.com/jincheng9/go-tutorial/tree/main/workspace/senior/p2">Go语言里被defer的函数一定会执行么？</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> func_name([parameter_list])</span><br><span class="line"><span class="keyword">defer</span> package_name.func_name([parameter_list]) <span class="comment">// 例如defer fmt.Println(&quot;blabla&quot;)</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果在函数内调用了<strong>多次defer</strong>，那在函数return之前，defer的函数调用满足LIFO原则，先defer的函数后执行，后defer的函数先执行。比如在函数A内先后执行了defer
f1(), defer f2(), defer f3()，那函数A return之前，会按照f3(), f2(),
f1()的顺序执行，再return。</p></li>
</ul>
<h2 id="defer的用途">defer的用途？</h2>
<p>Answer：defer常用于成对的操作，比如文件打开后要关闭、锁的申请和释放、sync.WaitGroup跟踪的goroutine的计数器的释放等。为了确保资源被释放，可以结合defer一起使用，避免在代码的各种条件分支里去释放资源，容易遗漏和出错。</p>
<ul>
<li><p>示例1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumN</span><span class="params">(N <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 调用defer wg.Done()确保sumN执行完之后，可以对wg的计数器减1</span></span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=N; i++ &#123;</span><br><span class="line">		sum += i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;sum from 1 to %d is %d\n&quot;</span>, N, sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设置wg跟踪的计数器数量为1</span></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 开启sumN这个goroutine去计算1到100的和</span></span><br><span class="line">	<span class="keyword">go</span> sumN(<span class="number">100</span>)</span><br><span class="line">	<span class="comment">// Wait会一直等待，直到wg的计数器为0</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	</span><br><span class="line">	fmt.Println(<span class="string">&quot;finish&quot;</span>)		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>defer结合goroutine和闭包一起使用，可以让任务函数内部不用关心Go并发里的同步原语，更多内容可以参考<a
href="./workspace/lesson19">goroutine</a>和<a
href="./workspace/lesson21">sync.WaitGroup</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    size := <span class="number">10</span></span><br><span class="line">    wg.Add(size)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        i := i </span><br><span class="line">        <span class="comment">/*把worker的调用和defer放在一个闭包里</span></span><br><span class="line"><span class="comment">        这样worker函数内部就不用使用WaitGroup了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            worker(i)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注意事项">注意事项</h2>
<ol type="1">
<li><p>defer后面跟的必须是函数或者方法调用，defer后面的表达式不能加括号。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> (fmt.Println(<span class="number">1</span>)) <span class="comment">// 编译报错，因为defer后面跟的表达式不能加括号</span></span><br></pre></td></tr></table></figure></li>
<li><p>被defer的函数的参数在执行到defer语句的时候就被确定下来了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(i) <span class="comment">// 最终打印0</span></span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，被defer的函数fmt.Println的参数<strong>i</strong>在执行到defer这一行的时候，<strong>i</strong>的值是0，fmt.Println的参数就被确定下来是0了，因此最终打印的结果是0，而不是1。</p></li>
<li><p>被defer的函数执行顺序满足LIFO原则，后defer的先执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Print(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，输出的结果是3210，后defer的先执行。</p></li>
<li><p>被defer的函数可以对defer语句所在的函数的命名返回值做读取和修改操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// f returns 42</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// result is accessed after it was set to 6 by the return statement</span></span><br><span class="line">		result *= <span class="number">7</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，被defer的函数func对defer语句所在的函数<strong>f</strong>的命名返回值result做了修改操作。</p>
<p>调用函数<strong>f</strong>，返回的结果是42。</p>
<p>执行顺序是函数<strong>f</strong>先把要返回的值6赋值给result，然后执行被defer的函数func，result被修改为42，然后函数<strong>f</strong>返回result，也就是返回了42。</p>
<p>官方说明如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Each time a <span class="string">&quot;defer&quot;</span> statement executes, the function value and parameters to</span><br><span class="line">the call are evaluated as usual and saved anew but the actual function is not </span><br><span class="line">invoked. Instead, deferred functions are invoked immediately before the </span><br><span class="line">surrounding function returns, in the reverse order they were deferred. That</span><br><span class="line">is, <span class="keyword">if</span> the surrounding function returns through an explicit <span class="keyword">return</span> statement, </span><br><span class="line">deferred functions are executed after any result parameters are set by that </span><br><span class="line"><span class="keyword">return</span> statement but before the function returns to its caller. If a deferred</span><br><span class="line">function value evaluates to <span class="literal">nil</span>, execution panics when the function is </span><br><span class="line">invoked, not when the <span class="string">&quot;defer&quot;</span> statement is executed.</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="references">References</h2>
<ul>
<li><p>https://go.dev/blog/defer-panic-and-recover</p></li>
<li><p>https://golang.google.cn/ref/spec#Defer_statements</p></li>
<li><p>https://stackoverflow.com/questions/52718143/is-golang-defer-statement-execute-before-or-after-return-statement</p></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>16.Go-接口interface</title>
    <url>/undefined/f28eaa9a/</url>
    <content><![CDATA[<p>本文主要介绍Go中接口interface的基础语法，包括接口的定义、实现、多个struct类型实现同一个interface、一个struct类型实现多个interface、空接口interface、断言、动态判断数据类型等内容。
<span id="more"></span> # 接口interface</p>
<ul>
<li><p>定义：接口是一种抽象的类型，是一组method的集合，里头只有method方法，没有数据成员。当两个或两个以上的类型都有相同的处理方法时才需要用到接口。先定义接口，然后多个struct类型去实现接口里的方法，就可以通过接口变量去调用struct类型里实现的方法。</p>
<p>比如动物都会叫唤，那可以先定义一个名为动物的接口，接口里有叫唤方法speak，然后猫和狗这2个struct类型去实现各自的speak方法。</p></li>
<li><p>语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">  method_name1([参数列表]) [返回值列表]</span><br><span class="line">  method_name2([参数列表]) [返回值列表]</span><br><span class="line">  method_nameN([参数列表]) [返回值列表]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体类型</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">    data_member1 data_type</span><br><span class="line">    data_member2 data_type</span><br><span class="line">    data_memberN data_type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口interface_name里的方法method_name1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(struct_var struct_name)</span></span> method_name1([参数列表])[返回值列表] &#123;</span><br><span class="line">    <span class="comment">/*具体方法实现*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口interface_name里的方法method_name2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(struct_var struct_name)</span></span> method_name2([参数列表])[返回值列表] &#123;</span><br><span class="line">    <span class="comment">/*具体方法实现*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口interface_name里的方法method_name3</span></span><br><span class="line"><span class="comment">注意：下面用了指针接受者。函数可以使用值接受者或者指针接受者，上面的method_name1和method_name1使用的是值接受者。</span></span><br><span class="line"><span class="comment">如果用了指针接受者，那给interface变量赋值的时候要传指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(struct_var *struct_name)</span></span> method_name3([参数列表])[返回值列表] &#123;</span><br><span class="line">    <span class="comment">/*具体方法实现*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// all animals can speak</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cat Cat)</span></span> speak() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;cat miaomiaomiao&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dog</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(dog *Dog)</span></span> speak() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;dog wangwangwang&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> animal Animal = Cat&#123;<span class="string">&quot;gaffe&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">    animal.speak() <span class="comment">// cat miaomiaomiao</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    因为Dog的speak方法用的是指针接受者，因此给interface赋值的时候，要赋指针</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    animal = &amp;Dog&#123;<span class="string">&quot;caiquan&quot;</span>, <span class="number">2</span>&#125;</span><br><span class="line">    animal.speak() <span class="comment">// dog wangwangwang</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>struct结构体类型在实现interface里的所有方法时，关于interface变量赋值有2个点要<strong>注意</strong></p>
<ul>
<li><p>只要有某个方法的实现使用了<strong>指针接受者</strong>，那给包含了这个方法的interface变量赋值的时候要<strong>使用指针</strong>。比如上面的Dog类型要赋值给Animal，必须使用指针，因为Dog实现speak方法用了指针接受者。</p></li>
<li><p>如果全部方法都使用的是值接受者，那给interface变量赋值的时候用值或者指针都可以。比如上面的例子，animal的初始化用下面的方式一样可以：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> animal Animal = &amp;Cat&#123;<span class="string">&quot;gaffe&quot;</span>, <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>多个struct类型可以实现同一个interface</strong>：多个类型都有共同的方法(行为)。比如上面示例里的猫和狗都会叫唤，猫和狗就是2个类型，叫唤就是speak方法。</p></li>
<li><p><strong>一个struct类型可以实现多个interface</strong>。比如猫这个类型，既是猫科动物，也是哺乳动物。猫科动物可以是一个interface，哺乳动物可以是另一个interface，猫这个struct类型可以实现猫科动物和哺乳动物这2个interface里的方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// interface1，猫科动物的共同行为</span></span><br><span class="line"><span class="keyword">type</span> Felines <span class="keyword">interface</span> &#123;</span><br><span class="line">    feet() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface2, 哺乳动物的共同行为</span></span><br><span class="line"><span class="keyword">type</span> Mammal <span class="keyword">interface</span> &#123;</span><br><span class="line">    born()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫既是猫科动物也是哺乳动物，2个行为都实现</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cat Cat)</span></span> feet() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;cat feet&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cat *Cat)</span></span> born() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;cat born&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cat := Cat&#123;<span class="string">&quot;rich&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> a Felines = cat</span><br><span class="line">    a.feet()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b Mammal = &amp;cat</span><br><span class="line">    b.born()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>interface可以嵌套：一个interface里包含其它interface</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// interface1</span></span><br><span class="line"><span class="keyword">type</span> Felines <span class="keyword">interface</span> &#123;</span><br><span class="line">    feet() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// interface2, 嵌套了interface1</span></span><br><span class="line"><span class="keyword">type</span> Mammal <span class="keyword">interface</span> &#123;</span><br><span class="line">    Felines</span><br><span class="line">    born()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫实现Mammal这个interface里的所有方法</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cat Cat)</span></span> feet() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;cat feet&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cat *Cat)</span></span> born() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;cat born&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cat := Cat&#123;<span class="string">&quot;rich&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">    <span class="comment">/*Mammal有feet和born方法，2个都可以调用*/</span></span><br><span class="line">    <span class="keyword">var</span> a Mammal = &amp;cat</span><br><span class="line">    a.feet()</span><br><span class="line">    a.born()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b Felines = cat</span><br><span class="line">    b.feet()</span><br><span class="line">    <span class="comment">// b.born() 调用这个会编译报错，因为Felines没有born方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>空接口interface</p>
<ul>
<li><p>如果空interface作为函数参数，可以接受任何类型的实参</p>
<ul>
<li><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印空interface的类型和具体的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T, value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 传map实参给空接口</span></span><br><span class="line">    dict := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line">    <span class="built_in">print</span>(dict) <span class="comment">// type:map[string]int, value:map[a:1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传struct实参给空接口</span></span><br><span class="line">    cat := Cat&#123;<span class="string">&quot;nimo&quot;</span>, <span class="number">2</span>&#125;</span><br><span class="line">    <span class="built_in">print</span>(cat) <span class="comment">// type:main.Cat, value:&#123;nimo 2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>如果空interface作为变量，可以把任何类型的变量赋值给空interface</p>
<ul>
<li><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 空接口x</span></span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印空interface的类型和具体的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T, value:%v\n&quot;</span>, x, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义空接口x</span></span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 将map变量赋值给空接口x</span></span><br><span class="line">    x = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line">    <span class="built_in">print</span>(x) <span class="comment">// type:map[string]int, value:map[a:1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传struct变量估值给空接口x</span></span><br><span class="line">    cat := Cat&#123;<span class="string">&quot;nimo&quot;</span>, <span class="number">2</span>&#125;</span><br><span class="line">    x = cat</span><br><span class="line">    <span class="built_in">print</span>(x) <span class="comment">// type:main.Cat, value:&#123;nimo 2&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>空接口作为map的值，可以实现map的value是不同的数据类型</p>
<ul>
<li><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个map类型的变量，key是string类型，value是空接口类型</span></span><br><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;) </span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个map类型的变量，key是string类型，value是空接口类型</span></span><br><span class="line">    dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">// value可以是int类型</span></span><br><span class="line">    dict[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span> </span><br><span class="line">    <span class="comment">// value可以是字符串类型</span></span><br><span class="line">    dict[<span class="string">&quot;b&quot;</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">    <span class="comment">// value可以是bool类型</span></span><br><span class="line">    dict[<span class="string">&quot;c&quot;</span>] = <span class="literal">true</span></span><br><span class="line">    fmt.Println(dict) <span class="comment">// map[a:1 b:b c:true]</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T, value:%v\n&quot;</span>, dict[<span class="string">&quot;b&quot;</span>], dict[<span class="string">&quot;b&quot;</span>]) <span class="comment">// type:string, value:b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>x.(T)</p>
<ul>
<li><p>断言：断言接口变量x是T类型</p>
<ul>
<li><p>语法：value是将x转化为T类型后的变量，ok是布尔值，true表示断言成功，false表示断言失败</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x是接口变量，如果要判断x是不是</span></span><br><span class="line">value, ok := x.(<span class="type">string</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">x = <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="comment">// 断言接口变量x的类型是string</span></span><br><span class="line">v, ok := x.(<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    <span class="comment">// 断言成功</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;assert true, value:&quot;</span>, v)</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 断言失败</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;assert false&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>动态判断数据类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">/*动态判断x的数据类型*/</span></span><br><span class="line">    <span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type: int, value: %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type: string，value: %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type: bool, value: %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> Cat:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type: Cat, value: %v\n&quot;</span>, v)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type: map[string]int, value: %v\n&quot;</span>, v)</span><br><span class="line">        v[<span class="string">&quot;a&quot;</span>] = <span class="number">10</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;type: %T, value: %v\n&quot;</span>, x, x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;   </span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    x = <span class="string">&quot;a&quot;</span></span><br><span class="line">    checkType(x) <span class="comment">//type: string，value: a</span></span><br><span class="line">    </span><br><span class="line">    x = Cat&#123;<span class="string">&quot;hugo&quot;</span>, <span class="number">3</span>&#125;</span><br><span class="line">    checkType(x) <span class="comment">// type: Cat, value: &#123;hugo 3&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在checkType里对map做修改</span></span><br><span class="line"><span class="comment">    会影响外面的实参x</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    x = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line">    checkType(x) <span class="comment">// type: map[string]int, value: map[a:1]</span></span><br><span class="line">    fmt.Println(x) <span class="comment">// map[a:10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<blockquote>
<p><strong>注意事项</strong></p>
<p>如果把一个结构体变量赋值给interface变量，那结构体需要实现interface里的所有方法，否则会编译报错：xx
does not implement yy，表示结构体xx没有实现接口yy</p>
</blockquote></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>15.Go-map集合</title>
    <url>/undefined/c6b790b1/</url>
    <content><![CDATA[<p>本文主要介绍Go语言中map集合的定义、初始化、使用、遍历、删除等操作。
<span id="more"></span> # map集合</p>
<h2 id="定义">定义</h2>
<p>Go语言里的map底层是通过<strong>hash</strong>实现的，是一种<strong>无序</strong>的基于&lt;key,
value&gt;对组成的数据结构，key是唯一的，类似python的dict。</p>
<p>map必须初始化后才能写map。</p>
<p>如果只是声明map，但没有初始化，只能读，不能写。参考下面的例子的说明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> counter <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	map没有初始化，读map相当于读了一个空map</span></span><br><span class="line"><span class="comment">	下例中：value是int的零值0，ok是false</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	value, ok := counter[<span class="string">&quot;a&quot;</span>]</span><br><span class="line">	fmt.Println(value, ok)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*counter没有初始化，给counter赋值会在运行时报错</span></span><br><span class="line"><span class="comment">	  panic: assignment to entry in nil map</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	counter[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">	fmt.Println(counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map_var <span class="keyword">map</span>[key_data_type]value_data_type = <span class="keyword">map</span>[key_data_type]value_data_type&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map_var = <span class="keyword">map</span>[key_data_type]value_data_type&#123;&#125;</span><br><span class="line"></span><br><span class="line">map_var := <span class="keyword">map</span>[key_data_type]value_data_type&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*cap是map容量，超过后会自动扩容*/</span></span><br><span class="line">map_var := <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type, [<span class="built_in">cap</span>]) </span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dict <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    dict[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">    fmt.Println(dict)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> dict2 = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    dict2[<span class="string">&quot;b&quot;</span>] = <span class="number">2</span></span><br><span class="line">    fmt.Println(dict2)</span><br><span class="line">    </span><br><span class="line">    dict3 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;test&quot;</span>:<span class="number">0</span>&#125;</span><br><span class="line">    dict3[<span class="string">&quot;c&quot;</span>] = <span class="number">3</span></span><br><span class="line">    fmt.Println(dict2)</span><br><span class="line">    </span><br><span class="line">    dict4 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">    dict4[<span class="string">&quot;d&quot;</span>] = <span class="number">4</span></span><br><span class="line">    fmt.Println(dict4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="使用">使用</h2>
<ul>
<li><p>判断key在map里是否存在</p>
<ul>
<li><p>语法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, is_exist := <span class="keyword">map</span>[key]</span><br></pre></td></tr></table></figure>
<p>如果key存在，那is_exist就是true,
value是对应的值。否则is_exist就是false,
value是map的value数据类型的零值。</p>
<p><strong>注意</strong>:
如果key不存在，通过map[key]访问不会给map自动插入这个新key。C++是会自动插入新key的，两个语言不一样。如果确定key存在，可以直接使用map[key]拿到value。</p></li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 构造一个map</span></span><br><span class="line">    str := <span class="string">&quot;aba&quot;</span></span><br><span class="line">    dict := <span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> str&#123;</span><br><span class="line">        dict[value]++</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(dict) <span class="comment">// map[97:2 98:1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问map里不存在的key，并不会像C++一样自动往map里插入这个新key</span></span><br><span class="line">    value, ok := dict[<span class="string">&#x27;z&#x27;</span>]</span><br><span class="line">    fmt.Println(value, ok) <span class="comment">// 0 false</span></span><br><span class="line">    fmt.Println(dict) <span class="comment">// map[97:2 98:1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问map里已有的key</span></span><br><span class="line">    value2 := dict[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">    fmt.Println(value2) <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>遍历map：使用range迭代。</p></li>
<li><p>len(map)：通过内置的len()函数可以获取map里&lt;key,
value&gt;对的数量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">counter := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(counter))</span><br><span class="line">counter[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(counter))</span><br></pre></td></tr></table></figure></li>
<li><p>map作为函数形参，可以在函数体内部改变外部实参的值。示例如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildMap</span><span class="params">(str <span class="type">string</span>, m <span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">/*函数内对map变量m的修改会影响main里的实参mapping*/</span></span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> str &#123;</span><br><span class="line">		m[value]++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mapping := <span class="keyword">map</span>[<span class="type">rune</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	str := <span class="string">&quot;abc&quot;</span></span><br><span class="line">	buildMap(str, mapping)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	mapping的值被buildMap修改了</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> mapping &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;key:%v, value:%d\n&quot;</span>, key, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="delete函数">delete函数</h2>
<ul>
<li><p>删除key，参数为map和对应的key。允许删除一个不存在的key，对map无任何影响。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    dict :=  <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;</span><br><span class="line">    fmt.Println(dict) <span class="comment">// map[a:1 b:2]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除&quot;a&quot;这个key</span></span><br><span class="line">    <span class="built_in">delete</span>(dict, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    fmt.Println(dict) <span class="comment">// map[b:2]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除&quot;c&quot;这个不在的key，对map结果无影响</span></span><br><span class="line">    <span class="built_in">delete</span>(dict, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    fmt.Println(dict) <span class="comment">// map[b:2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="注意事项">注意事项</h2>
<ul>
<li><p>key必须支持==和!=比较，才能用作map的key。</p>
<p>因此切片slice，函数类型function，集合map，不能用作map的key</p></li>
<li><p>map不是并发安全的，并发读写要加锁</p></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>14.Gorange迭代</title>
    <url>/undefined/57393c42/</url>
    <content><![CDATA[<p>本文主要介绍Go中range迭代的使用方法，包括对字符串、数组、切片、集合和通道的迭代。
<span id="more"></span> # range迭代</p>
<p>range可以用于for循环，对字符串，数组array，切片slice，集合map或通道channel进行迭代</p>
<h2 id="range对字符串string进行迭代">range对字符串string进行迭代</h2>
<ul>
<li><p>有2种方法可以对string进行range遍历，一种是只拿到字符串的下标索引，一种是同时拿到下标索引和对应的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;abcdgfg&quot;</span></span><br><span class="line">    <span class="comment">// 方法1：可以通过range拿到字符串的下标索引</span></span><br><span class="line">    <span class="keyword">for</span> index := <span class="keyword">range</span>(str) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index:%d, value:%d\n&quot;</span>, index, str[index])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法2：可以通过range拿到字符串的下标索引和对应的值</span></span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span>(str) &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;index=&quot;</span>, index, <span class="string">&quot;, value=&quot;</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以直接通过len获取字符串长度进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> index:=<span class="number">0</span>; index&lt;<span class="built_in">len</span>(str); index++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index:%d, value:%d\n&quot;</span>, index, str[index])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="range对数组array进行迭代">range对数组array进行迭代</h2>
<ul>
<li><p>一维数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SIZE = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    注意：数组的大小不能用变量，比如下面的SIZE必须是常量，如果是变量就会编译报错</span></span><br><span class="line"><span class="comment">    non-constant array bound size</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    array := [SIZE]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法1：只拿到数组的下标索引</span></span><br><span class="line">    <span class="keyword">for</span> index := <span class="keyword">range</span> array &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d value=%d &quot;</span>, index, array[index])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法2：同时拿到数组的下标索引和对应的值</span></span><br><span class="line">    <span class="keyword">for</span> index, value:= <span class="keyword">range</span> array &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d value=%d &quot;</span>, index, value)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>二维数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    array := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line">    <span class="comment">// 只拿到行的索引</span></span><br><span class="line">    <span class="keyword">for</span> index := <span class="keyword">range</span> array &#123;</span><br><span class="line">        <span class="comment">// array[index]类型是一维数组</span></span><br><span class="line">        fmt.Println(reflect.TypeOf(array[index]))</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d, value=%v\n&quot;</span>, index, array[index])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拿到行索引和该行的数据</span></span><br><span class="line">    <span class="keyword">for</span> row_index, row_value := <span class="keyword">range</span> array &#123;</span><br><span class="line">        fmt.Println(row_index, reflect.TypeOf(row_value), row_value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 双重遍历，拿到每个元素的值</span></span><br><span class="line">    <span class="keyword">for</span> row_index, row_value := <span class="keyword">range</span> array &#123;</span><br><span class="line">        <span class="keyword">for</span> col_index, col_value := <span class="keyword">range</span> row_value &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;array[%d][%d]=%d &quot;</span>, row_index, col_index, col_value)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="range对切片slice进行迭代">range对切片slice进行迭代</h2>
<ul>
<li><p>一维切片：会根据切片的长度len()进行遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    <span class="comment">// 方式1</span></span><br><span class="line">    <span class="keyword">for</span> index := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d, value=%d\n&quot;</span>, index, slice[index])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    <span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d, value=%d\n&quot;</span>, index, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>二维切片：range遍历方式类似二维数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := [][]<span class="type">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;&#125;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(slice))</span><br><span class="line">    <span class="comment">// 方法1，拿到行索引</span></span><br><span class="line">    <span class="keyword">for</span> index := <span class="keyword">range</span> slice&#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d, type:%v, value=%v\n&quot;</span>, index, reflect.TypeOf(slice[index]), slice[index])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法2，拿到行索引和该行的值，每行都是一维切片</span></span><br><span class="line">    <span class="keyword">for</span> row_index, row_value := <span class="keyword">range</span> slice&#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d, type:%v, value=%v\n&quot;</span>, row_index, reflect.TypeOf(row_value), row_value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法3，双重遍历，获取每个元素的值</span></span><br><span class="line">    <span class="keyword">for</span> row_index, row_value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">        <span class="keyword">for</span> col_index, col_value := <span class="keyword">range</span> row_value &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;slice[%d][%d]=%d &quot;</span>, row_index, col_index, col_value)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="range对集合map进行迭代">range对集合map进行迭代</h2>
<ul>
<li><p>有如下2种方法可以遍历map，一种是拿到key，一种是拿到key,value</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hash := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line">    <span class="comment">// 方法1，拿到key，再根据key获取value</span></span><br><span class="line">    <span class="keyword">for</span> key := <span class="keyword">range</span> hash&#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;key=%s, value=%d\n&quot;</span>, key, hash[key])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法2，同时拿到key和value</span></span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> hash&#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;key=%s, value=%d\n&quot;</span>, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* nil map不能存放key-value键值对，比如下面的方式会报错：panic: assignment to entry in nil map</span></span><br><span class="line"><span class="comment">    var hash2 map[string]int </span></span><br><span class="line"><span class="comment">    hash2[&quot;a&quot;] = 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="range对通道channel进行迭代">range对通道channel进行迭代</h2>
<p>对channel进行range迭代，会循环从channel里取数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addData</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	每3秒往通道ch里发送一次数据</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	size := <span class="built_in">cap</span>(ch)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">		ch &lt;- i</span><br><span class="line">		time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 数据发送完毕，关闭通道</span></span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// 开启一个goroutine，用于往通道ch里发送数据</span></span><br><span class="line">	<span class="keyword">go</span> addData(ch)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* range迭代从通道ch里获取数据</span></span><br><span class="line"><span class="comment">	通道close后，range迭代取完通道里的值后，循环会自动结束</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>13.Go切片Slice</title>
    <url>/undefined/fe31314e/</url>
    <content><![CDATA[<p>本文主要介绍Go中切片slice的定义和使用方法，包括切片的定义、切片的底层数据结构、切片的使用、切片截取、切片常用的几个函数、切片的底层原理等内容。
<span id="more"></span></p>
<h1 id="切片slice">切片Slice</h1>
<h2 id="概念">概念</h2>
<p>切片slice：切片是对数组的抽象。Go数组的长度在定义后是固定的，不可改变的。</p>
<p>切片的长度和容量是不固定的，可以动态增加元素，切片的容量也会根据情况自动扩容</p>
<ul>
<li><p>切片的底层数据结构</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切片slice是个struct结构体，里面实际有个指针array，类型是unsafe.Pointer，也就是个指针，指向存放数据的数组。</p>
<p>len是切片的长度，cap是切片的容量。</p></li>
<li><p>定义和初始化</p>
<ul>
<li><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice_var []data_type <span class="comment">// 元素类型为data_type的切片</span></span><br><span class="line"><span class="keyword">var</span> slice_var []data_type = <span class="built_in">make</span>([]data_type, <span class="built_in">len</span>, <span class="built_in">cap</span>)<span class="comment">// cap是切片容量，是make的可选参数</span></span><br><span class="line"><span class="keyword">var</span> slice_var []data_type = <span class="built_in">make</span>([]data_type, <span class="built_in">len</span>)</span><br><span class="line">slice_var := []data_type&#123;&#125;</span><br><span class="line">slice_var := <span class="built_in">make</span>([]data_type, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(param []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;slice len:%d, cap:%d, value:%v\n&quot;</span>, <span class="built_in">len</span>(param), <span class="built_in">cap</span>(param), param)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice1 := []<span class="type">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">    slice2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">100</span>)</span><br><span class="line">    printSlice(slice1)</span><br><span class="line">    printSlice(slice2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>零值nil</p>
<ul>
<li><p>如果slice类型的变量定义后没有初始化赋值，那值就是默认值nil。对于nil切片，len和cap函数执行结果都是0。</p>
<p><strong>注意</strong>：下例里的slice有赋值，所以slice!=nil。slice2没有赋值，slice2==nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(param []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;param len:%d, cap:%d, value:%v\n&quot;</span>, <span class="built_in">len</span>(param), <span class="built_in">cap</span>(param), param)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> slice2 []<span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;slice==nil&quot;</span>, slice==<span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">    printSlice(slice)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;slice2==nil&quot;</span>, slice2==<span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">    printSlice(slice2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="切片的使用">切片的使用</h2>
<p>切片访问：对切片的访问，类似数组一样，可以用下标索引或者range迭代的方式进行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="comment">/*下标访问切片*/</span></span><br><span class="line">	slice[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	slice[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">	slice[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(slice); i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;slice[%d]=%d\n&quot;</span>, i, slice[i])		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*range迭代访问切片*/</span></span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;slice[%d]=%d\n&quot;</span>, index, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片截取">切片截取</h3>
<p>切片截取<code>:</code>类似Python，使用冒号<code>:</code>来对数组或者切片做截取。</p>
<p>冒号<code>:</code>截取后的新slice变量底层有个指针，会指向原数组或者原切片的数组空间，对新切片的修改也会影响原数组或者原切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(param []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;param len:%d, cap:%d, value:%v\n&quot;</span>, <span class="built_in">len</span>(param), <span class="built_in">cap</span>(param), param)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> slice2 []<span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;slice==nil&quot;</span>, slice==<span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">    printSlice(slice)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;slice2==nil&quot;</span>, slice2==<span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">    printSlice(slice2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对数组做切片</span></span><br><span class="line">    array := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">// array是数组</span></span><br><span class="line">    slice3 := array[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// slice3是切片</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;slice3 type:&quot;</span>, reflect.TypeOf(slice3))</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice3=&quot;</span>, slice3) <span class="comment">// slice3= [2 3]</span></span><br><span class="line">    </span><br><span class="line">    slice4 := slice3[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice4=&quot;</span>, slice4) <span class="comment">// slice4= [3]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* slice5-&gt;slice4-&gt;slice3-&gt;array</span></span><br><span class="line"><span class="comment">    对slice5的修改，会影响到slice4, slice3和array</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    slice5 := slice4[:]</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice5=&quot;</span>, slice5) <span class="comment">// slice5= [3]</span></span><br><span class="line">    </span><br><span class="line">    slice5[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;array=&quot;</span>, array) <span class="comment">// array= [1 2 10]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;slice3=&quot;</span>, slice3) <span class="comment">// slice3= [2 10]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;slice4=&quot;</span>, slice4) <span class="comment">// slice4= [10]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;slice5=&quot;</span>, slice5) <span class="comment">// slice5= [10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="切片常用的几个函数">切片常用的几个函数</h3>
<p>len()和cap()函数：类似C++的vector里的size和capacity</p>
<ul>
<li>len()：获取切片的长度，也就是实际存储了多少个元素</li>
<li>cap():
获取切片的容量。如果切片的元素个数要超过当前容量，会自动扩容</li>
</ul>
<p>append()：通过append函数给切片加元素</p>
<ul>
<li><p>append不改变原切片的值，比如下例里的append(slice,
4)并不会改变slice的值</p></li>
<li><p>只能对切片使用append()函数，不能对数组使用append()</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="comment">// 往原切片里加一个元素</span></span><br><span class="line">    test := <span class="built_in">append</span>(slice, <span class="number">4</span>)</span><br><span class="line">    <span class="comment">// append不会改变slice的值，除非把append的结果重新赋值给slice</span></span><br><span class="line">    fmt.Println(slice) <span class="comment">// [1 2 3]</span></span><br><span class="line">    fmt.Println(test) <span class="comment">// [1 2 3 4]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过append给切片添加切片</span></span><br><span class="line">    temp := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    test = <span class="built_in">append</span>(test, temp...) <span class="comment">// 注意，第2个参数有...结尾</span></span><br><span class="line">    fmt.Println(test) <span class="comment">// [1 2 3 4 1 2]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*下面对array数组做append就会报错:  first argument to append must be slice; have [3]int</span></span><br><span class="line"><span class="comment">    array := [3]int&#123;1, 2, 3&#125;</span></span><br><span class="line"><span class="comment">    array2 := append(array, 1)</span></span><br><span class="line"><span class="comment">    fmt.Println(array2)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>copy()：拷贝一个切片里的数据到另一个切片</p>
<ul>
<li><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span>(dstSlice, srcSlice) <span class="comment">// 把srcSlice切片里的元素拷贝到dstSlice切片里</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>​ <strong>注意事项</strong>：只从源切片srcSlice拷贝min(len(srcSlice),
len(dstSlice))个元素到目标切片dstSlice里。如果dstSlice的长度是0，那一个都不会从srcSlice拷贝到dstSlice里。如果dstSlice的长度M小于srcSlice的长度N，则只会拷贝srcSlice里的前M个元素到目标切片dstSlice里。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>, <span class="number">3</span>) <span class="comment">// 切片b的长度是1</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">copy</span>(b, a) <span class="comment">// 只拷贝1个元素到b里</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;a=&quot;</span>, a) <span class="comment">// a= [1 2]</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;b=&quot;</span>, b) <span class="comment">// b= [1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数传参">函数传参</h3>
<ul>
<li><p>slice切片如果是函数参数，函数体内对切片底层数组的修改会影响到实参。比如下例里的change1函数第一行</p></li>
<li><p><strong>如果在函数体内通过append直接对切片添加新元素，不会改变外部切片的值</strong>，比如下例里的change1函数第2行。但是如果函数使用切片指针作为参数，在函数体内可以通过切片指针修改外部切片的值，比如下例里的change2函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change1</span><span class="params">(param []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	param[<span class="number">0</span>] = <span class="number">100</span> <span class="comment">// 这个会改变外部切片的值</span></span><br><span class="line">	param = <span class="built_in">append</span>(param, <span class="number">200</span>) <span class="comment">// append不会改变外部切片的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change2</span><span class="params">(param *[]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	*param = <span class="built_in">append</span>(*param, <span class="number">300</span>) <span class="comment">// 传切片指针，通过这种方式append可以改变外部切片的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line">	fmt.Println(slice) <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line">	change1(slice)</span><br><span class="line">	fmt.Println(slice) <span class="comment">// [100, 0]</span></span><br><span class="line"></span><br><span class="line">	change2(&amp;slice)</span><br><span class="line">	fmt.Println(slice) <span class="comment">// [100, 0, 300]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="切片的底层原理">切片的底层原理</h2>
<ol type="1">
<li><a
href="https://github.com/jincheng9/go-tutorial/blob/main/workspace/senior/p8">Go
Quiz: 从Go面试题看slice的底层原理和注意事项</a></li>
<li><a
href="https://github.com/jincheng9/go-tutorial/blob/main/workspace/senior/p13">Go
Quiz: 从Go面试题搞懂slice range遍历的坑</a></li>
</ol>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>12.Go结构体</title>
    <url>/undefined/ffa5bf91/</url>
    <content><![CDATA[<p>本文主要介绍Go中结构体的定义和使用方法，包括结构体的定义、访问结构体内的成员、结构体指针、方法和可见性等内容。
<span id="more"></span> # 结构体</p>
<h2 id="定义">定义</h2>
<ul>
<li><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_type <span class="keyword">struct</span> &#123;</span><br><span class="line">    member_name1 data_type1</span><br><span class="line">    member_name2 data_type2</span><br><span class="line">    member_name3, member_name4 data_type3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1：必须给结构体里每个成员赋值，如果只给部分成员赋值会编译报错</span></span><br><span class="line">struct_var := struct_type&#123;value1, value2, value3, value4&#125;</span><br><span class="line"><span class="comment">// 方式2：可以给部分或者全部成员赋值，没有赋值的成员的值是成员所属类型的零值</span></span><br><span class="line">struct_var2 := struct_type&#123;member_name1:value1, member_name2:value2&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">    title <span class="type">string</span></span><br><span class="line">    author <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">book1 := Book&#123;<span class="number">1</span>, <span class="string">&quot;go tutorial&quot;</span>, <span class="string">&quot;jincheng9&quot;</span>&#125;</span><br><span class="line">book2 := Book&#123;id:<span class="number">2</span>, title:<span class="string">&quot;day day up&quot;</span>, author:<span class="string">&quot;unknown&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="访问结构体内的成员">访问结构体内的成员</h2>
<p>访问结构体内的成员使用点<code>.</code>
，格式为：<strong>结构体变量<code>.</code>成员</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">    author <span class="type">string</span></span><br><span class="line">    title <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> book Book</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">(book Book)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;id:&quot;</span>, book.id)</span><br><span class="line">    fmt.Println(<span class="string">&quot;author:&quot;</span>, book.author)</span><br><span class="line">    fmt.Println(<span class="string">&quot;title:&quot;</span>, book.title)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    book1 := Book&#123;<span class="number">1</span>, <span class="string">&quot;go tutorial&quot;</span>, <span class="string">&quot;jincheng9&quot;</span>&#125;</span><br><span class="line">    book2 := Book&#123;id:<span class="number">2</span>, title:<span class="string">&quot;day day up&quot;</span>, author:<span class="string">&quot;unknown&quot;</span>&#125;</span><br><span class="line">    printBook(book1)</span><br><span class="line">    printBook(book2)</span><br><span class="line">    </span><br><span class="line">    book.id = <span class="number">10</span></span><br><span class="line">    book.author = <span class="string">&quot;test&quot;</span></span><br><span class="line">    book.title = <span class="string">&quot;test&quot;</span></span><br><span class="line">    printBook(book)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体指针">结构体指针</h2>
<ul>
<li><p>语法。<strong>注意</strong>:结构体指针访问结构体里的成员，也是用点<code>.</code>，这个和C++用<code>-&gt;</code>不一样</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> struct_pointer *struct_type <span class="comment">// 指针struct_pointer指向结构体struct_type</span></span><br><span class="line">struct_var := struct_type&#123;&#125; <span class="comment">// 结构体变量</span></span><br><span class="line">struct_pointer = &amp;struct_var <span class="comment">// 指针赋值</span></span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">    author <span class="type">string</span></span><br><span class="line">    title <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">(book *Book)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;id:&quot;</span>, book.id)</span><br><span class="line">    fmt.Println(<span class="string">&quot;author:&quot;</span>, book.author)</span><br><span class="line">    fmt.Println(<span class="string">&quot;title:&quot;</span>, book.title)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    book := Book&#123;<span class="number">1</span>, <span class="string">&quot;expert&quot;</span>, <span class="string">&quot;go&quot;</span>&#125;</span><br><span class="line">    bookPtr := &amp;book</span><br><span class="line">    printBook(bookPtr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="方法">方法</h2>
<ul>
<li><p>Go没有C++的class概念，但是可以对struct结构体类型定义方法，结构体对象调用该方法，来达到类似效果</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">    author <span class="type">string</span></span><br><span class="line">    title <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(book Book)</span></span> printBook() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;id:%d, author:%s, title:%s\n&quot;</span>, book.id, book.author, book.title)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(book *Book)</span></span> changeTitle1() &#123;</span><br><span class="line">    book.title = <span class="string">&quot;new title1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个无法改变调用该方法的结构体变量里的成员的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(book Book)</span></span> changeTitle2() &#123;</span><br><span class="line">    book.title = <span class="string">&quot;new title2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    book := Book&#123;<span class="number">1</span>, <span class="string">&quot;expert&quot;</span>, <span class="string">&quot;go&quot;</span>&#125;</span><br><span class="line">    book.printBook()</span><br><span class="line">    </span><br><span class="line">    book.changeTitle1() <span class="comment">// 会修改变量book里的成员title的值</span></span><br><span class="line">    book.printBook()</span><br><span class="line">    </span><br><span class="line">    book.changeTitle2() <span class="comment">// 不会对book的值有任何影响</span></span><br><span class="line">    book.printBook()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="可见性">可见性</h2>
<ul>
<li>结构体标识符和结构体的成员标识符可见性
<ul>
<li>如果结构体要被其它package使用，那结构体的标识符或者说结构体的名称首字母要大写</li>
<li>如果结构体的成员要被其它package使用，那结构体和结构体的成员标识符首字母都要大写，否则只能在当前包里使用</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>11.Go指针</title>
    <url>/undefined/d36541d4/</url>
    <content><![CDATA[<p>本文主要介绍Go中指针的基础语法，包括指针的定义、初始化、默认值、指向数组的指针、指针数组、指向指针的指针、向函数传递指针参数、指向结构体的指针等内容。
<span id="more"></span> # 指针</p>
<h2 id="指针的基础语法">指针的基础语法</h2>
<p>指针的值是指向的变量的内存地址。</p>
<ul>
<li><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *var_type</span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intPtr *<span class="type">int</span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">10</span></span><br><span class="line">    <span class="comment">// 方式1</span></span><br><span class="line">    <span class="keyword">var</span> intPtr *<span class="type">int</span> = &amp;i</span><br><span class="line">    fmt.Println(<span class="string">&quot;pointer value:&quot;</span>, intPtr, <span class="string">&quot; point to: &quot;</span>, *intPtr)</span><br><span class="line">    fmt.Println(<span class="string">&quot;type of pointer:&quot;</span>, reflect.TypeOf(intPtr))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式2</span></span><br><span class="line">    intPtr2 := &amp;i</span><br><span class="line">    fmt.Println(*intPtr2)</span><br><span class="line">    fmt.Println(<span class="string">&quot;type of pointer:&quot;</span>, reflect.TypeOf(intPtr2))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式3</span></span><br><span class="line">    <span class="keyword">var</span> intPtr3 = &amp;i;</span><br><span class="line">    fmt.Println(*intPtr3)</span><br><span class="line">    fmt.Println(<span class="string">&quot;type of pointer:&quot;</span>, reflect.TypeOf(intPtr3))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式4</span></span><br><span class="line">    <span class="keyword">var</span> intPtr4 *<span class="type">int</span></span><br><span class="line">    intPtr4 = &amp;i</span><br><span class="line">    fmt.Println(*intPtr4)</span><br><span class="line">    fmt.Println(<span class="string">&quot;type of pointer:&quot;</span>, reflect.TypeOf(intPtr4))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="默认值">默认值</h2>
<ul>
<li><p>不赋值的时候，默认值是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intPtr5 *<span class="type">int</span>    </span><br><span class="line">fmt.Println(<span class="string">&quot;intPtr5==nil:&quot;</span>, intPtr5==<span class="literal">nil</span>) <span class="comment">// intPtr5==nil: true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="指向数组的指针">指向数组的指针</h2>
<ul>
<li><p>注意这里和C++不一样，C++的数组名就是指向数组首元素的地址，Go不是</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arrayPtr *[<span class="number">3</span>]<span class="type">int</span> = &amp;array <span class="comment">// C++赋值就不用加&amp;</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(array); i++ &#123;</span><br><span class="line">  <span class="comment">// arrayPtr[i]的值就是数组array里下标索引i对应的值</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;arrayPtr[%d]=%d\n&quot;</span>, i, arrayPtr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="指针数组">指针数组</h2>
<ul>
<li><p>定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ptr [SIZE]*<span class="type">int</span> <span class="comment">// 指向int的指针数组，数组里有多个指针，每个都指向一个int</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SIZE = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ptrArray [SIZE]*<span class="type">int</span></span><br><span class="line">    a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;SIZE; i++ &#123;</span><br><span class="line">        ptrArray[i] = &amp;a[i]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;SIZE; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, *ptrArray[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意字符串不能对其中的字符取地址</p>
</blockquote></li>
</ul>
<h2 id="指向指针的指针">指向指针的指针</h2>
<ul>
<li><p>定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> ptr1 *<span class="type">int</span> = &amp;a</span><br><span class="line"><span class="keyword">var</span> ptr2 **<span class="type">int</span> = &amp;ptr1</span><br><span class="line"><span class="keyword">var</span> ptr3 ***<span class="type">int</span> = &amp;ptr2</span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> ptr1 *<span class="type">int</span> = &amp;a</span><br><span class="line">    <span class="keyword">var</span> ptr2 **<span class="type">int</span> = &amp;ptr1</span><br><span class="line">    <span class="keyword">var</span> ptr3 ***<span class="type">int</span> = &amp;ptr2</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;*ptr1=&quot;</span>, *ptr1)</span><br><span class="line">    fmt.Println(<span class="string">&quot;**ptr2=&quot;</span>, **ptr2)</span><br><span class="line">    fmt.Println(<span class="string">&quot;***ptr3=&quot;</span>, ***ptr3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="向函数传递指针参数">向函数传递指针参数</h2>
<ul>
<li><p>示例：通过指针参数修改实参的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个可以交换外部传入的2个实参的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a *<span class="type">int</span>, b *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *a, *b = *b, *a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个无法交换外部传入的2个实参的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap2</span><span class="params">(a *<span class="type">int</span>, b *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    a, b = b, a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    swap(&amp;a, &amp;b)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a=&quot;</span>, a, <span class="string">&quot; b=&quot;</span>, b) <span class="comment">// a= 2  b= 1</span></span><br><span class="line">    </span><br><span class="line">    swap2(&amp;a, &amp;b)</span><br><span class="line">    fmt.Println(<span class="string">&quot;a=&quot;</span>, a, <span class="string">&quot; b=&quot;</span>, b) <span class="comment">// a= 2  b= 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="指向结构体的指针">指向结构体的指针</h2>
<p>指向结构体的指针在访问结构体成员的时候使用点<code>.</code>，和C++里用箭头-&gt;不一样。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>10.Go数组</title>
    <url>/undefined/7bc5e1cb/</url>
    <content><![CDATA[<p>本文主要介绍Go中数组的定义和使用方法，包括一维数组和多维数组的定义、初始化、访问等内容，以及数组作为函数参数传递的注意事项。
<span id="more"></span></p>
<h1 id="数组">数组</h1>
<h2 id="一维数组">一维数组</h2>
<ul>
<li><p>声明：数组的大小必须是常量，不能是变量，比如下面的语法里的size必须是常量</p>
<ul>
<li><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [size] variable_type</span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num_list [<span class="number">10</span>] <span class="type">int</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>初始化</p>
<ul>
<li><p>指定数组大小</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> float_num_list1 [<span class="number">5</span>]<span class="type">float32</span> = [<span class="number">5</span>]<span class="type">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;</span><br><span class="line"><span class="keyword">var</span> float_num_list2 = [<span class="number">5</span>]<span class="type">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;</span><br><span class="line">int_num_list := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> float_num_list1 &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[float_num_list1]index=&quot;</span>, index, <span class="string">&quot;value=&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> float_num_list2 &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[float_num_list2]index=&quot;</span>, index, <span class="string">&quot;value=&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> int_num_list &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[int_num_list]index=&quot;</span>, index, <span class="string">&quot;value=&quot;</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>不显式指定数组大小，编译器根据赋的值自行推导</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balance1 []<span class="type">int</span> = [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125; <span class="comment">// 等价于[2]int&#123;1,2&#125;</span></span><br><span class="line"><span class="keyword">var</span> balance2 = [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">balance3 := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;balance1=&quot;</span>, balance1)</span><br><span class="line">fmt.Println(<span class="string">&quot;balance2=&quot;</span>, balance2)</span><br><span class="line">fmt.Println(<span class="string">&quot;balance3=&quot;</span>, balance3)</span><br></pre></td></tr></table></figure></li>
<li><p>指定数组大小情况下，特殊的初始化方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">balance := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>:<span class="number">10</span>, <span class="number">3</span>:<span class="number">30</span>&#125; <span class="comment">// 将数组下标为1和3的元素分别初始化为10和30</span></span><br><span class="line">fmt.Println(balance) <span class="comment">// [0, 10, 0, 30, 0]</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>访问数组</p>
<ul>
<li><p>使用下标访问</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">balance := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>:<span class="number">10</span>, <span class="number">3</span>:<span class="number">30</span>&#125; <span class="comment">// 将数组下标为1和3的元素分别初始化为10和30</span></span><br><span class="line">fmt.Println(balance)</span><br><span class="line"></span><br><span class="line">num := balance[<span class="number">1</span>]</span><br><span class="line">fmt.Println(<span class="string">&quot;num=&quot;</span>, num)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++ &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;balance[%d]=%d\n&quot;</span>, i, balance[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>range遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> float_num_list1 [<span class="number">5</span>]<span class="type">float32</span> = [<span class="number">5</span>]<span class="type">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> float_num_list1 &#123;</span><br><span class="line">    <span class="comment">// index是数组下标</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;[float_num_list1]index=&quot;</span>, index) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> float_num_list1 &#123;</span><br><span class="line">    <span class="comment">// index是数组下标，value是对应的数组元素</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;[float_num_list1]index=&quot;</span>, index, <span class="string">&quot;value=&quot;</span>, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获取数组长度len(array)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [...]<span class="type">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; </span><br><span class="line">fmt.Println(<span class="string">&quot;array length=&quot;</span>, <span class="built_in">len</span>(a)) <span class="comment">// array length=5</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="多维数组">多维数组</h2>
<ul>
<li><p>声明：数组的大小必须是常量，不能是变量，比如下面语法里的size1，size2，...，sizeN必须是常量</p>
<ul>
<li><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [size1][size2]...[sizeN] variable_type</span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeDimArray [<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]<span class="type">int</span> <span class="comment">// 三维数组，大小是 2x3x4</span></span><br><span class="line"><span class="keyword">var</span> twoDimArray [<span class="number">2</span>][<span class="number">3</span>] <span class="comment">// 二维数组，大小是2x3</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>初始化</p>
<ul>
<li><p>初始化直接赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array1 := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span> &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, <span class="comment">// 如果花括号&#125;在下一行，这里必须有逗号。如果花括号在这一行可以不用逗号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化默认值，后续再赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array2 := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">array2[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">array2[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;array2=&quot;</span>, array2)</span><br></pre></td></tr></table></figure></li>
<li><p>append赋值，只能对slice切片类型使用append，不能对数组使用append。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">twoDimArray := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">row1 := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">row2 := []<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">twoDimArray = <span class="built_in">append</span>(twoDimArray, row1)</span><br><span class="line">fmt.Println(<span class="string">&quot;twoDimArray=&quot;</span>, twoDimArray)</span><br><span class="line"></span><br><span class="line">twoDimArray = <span class="built_in">append</span>(twoDimArray, row2)</span><br><span class="line">fmt.Println(<span class="string">&quot;twoDimArray=&quot;</span>, twoDimArray)</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>访问二维数组</p>
<ul>
<li><p>数组下标遍历具体的元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array1 := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span> &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;array1[%d][%d]=%d &quot;</span>, i, j, array1[i][j])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数组下标遍历某行元素</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    array := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line">    <span class="keyword">for</span> index := <span class="keyword">range</span> array &#123;</span><br><span class="line">        <span class="comment">// array[index]类型是一维数组</span></span><br><span class="line">        fmt.Println(reflect.TypeOf(array[index])) </span><br><span class="line">        fmt.Printf(<span class="string">&quot;index=%d, value=%v\n&quot;</span>, index, array[index])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>range遍历</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">twoDimArray := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span> &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> index := <span class="keyword">range</span> twoDimArray &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;row %d is &quot;</span>, index) <span class="comment">//index的值是0,1，表示二维数组的第1行和第2行</span></span><br><span class="line">    fmt.Println(twoDimArray[index]) <span class="comment">//twoDimArray[index]类型就是一维数组</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">for</span> row_index, row_value := <span class="keyword">range</span> twoDimArray &#123;</span><br><span class="line">    <span class="keyword">for</span> col_index, col_value := <span class="keyword">range</span> row_value &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;twoDimArray[%d][%d]=%d &quot;</span>, row_index, col_index, col_value)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>注意事项</p>
<ul>
<li><p>slice类型的每一维度的大小可以不相同，比如下例里的第0行size是3，第1行size是2。如果直接访问twoDimArray[2][2]会报错。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">twoDimArray := [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">row1 := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">row2 := []<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">twoDimArray = <span class="built_in">append</span>(twoDimArray, row1)</span><br><span class="line">fmt.Println(<span class="string">&quot;twoDimArray=&quot;</span>, twoDimArray)</span><br><span class="line"></span><br><span class="line">twoDimArray = <span class="built_in">append</span>(twoDimArray, row2)</span><br><span class="line">fmt.Println(<span class="string">&quot;twoDimArray=&quot;</span>, twoDimArray)</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>数组作为函数参数进行传递</p>
<ul>
<li><p>如果数组作为函数参数，实参和形参的定义必须相同，要么都是长度相同的数组，要么都是slice类型。如果实参和形参的类型一个是数组，一个是slice，或者实参和形参都是数组但是长度不一致都会编译报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(array [5]<span class="type">int</span>, size <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        sum += array[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumSlice</span><span class="params">(array []<span class="type">int</span>, size <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        sum += array[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">5</span>]<span class="type">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">// a := [...]int&#123;1, 2, 3, 4, 5&#125;也可以去调用sum，编译器会自动推导出a的长度5</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;type of a:&quot;</span>, reflect.TypeOf(a)) <span class="comment">// type of a: [5]int</span></span><br><span class="line">    ans := sum(a, <span class="number">5</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;ans=&quot;</span>, ans)</span><br><span class="line">    </span><br><span class="line">    b := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    ans2 := sumSlice(b, <span class="number">5</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;ans2=&quot;</span>, ans2)</span><br><span class="line">    </span><br><span class="line">    array := [...]<span class="type">int</span> &#123;<span class="number">1</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;type of array:&quot;</span>, reflect.TypeOf(array)) <span class="comment">// type of array: [1]int，是一个数组类型</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;array=&quot;</span>, array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>值传递和引用传递</p>
<ul>
<li><p><strong>Go语言里只有值传递，没有引用传递</strong>。</p></li>
<li><p>如果数组作为函数参数，在函数体内不能改变外部实参的值。如果使用数组作为形参，想修改实参的值，那就要传指向数组的指针</p></li>
<li><p>如果slice作为函数参数，在函数体内可以改变外部实参的值，<strong>但是这并不意味着slice是引用传递</strong>，slice传参也是值传递。只不过slice这个结构里有一个指针指向底层的数组，实参把值拷贝给形参的时候，形参slice里的指针和外部实参slice的指针的值相同，也就指向了同一块数组内存空间，所以形参slice对数组元素做修改也会影响外部实参的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// changeArray无法改变实参数组的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeArray</span><span class="params">(array [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// changeArray2可以改变实参的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeArray2</span><span class="params">(array *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// changeArray3可以改变实参的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeArray3</span><span class="params">(array []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">param := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">changeArray(param)</span><br><span class="line">fmt.Println(<span class="string">&quot;param=&quot;</span>, param) <span class="comment">// param= [1 2 3]</span></span><br><span class="line">changeArray2(&amp;param)</span><br><span class="line">fmt.Println(<span class="string">&quot;param=&quot;</span>, param) <span class="comment">// param= [10 2 3]</span></span><br><span class="line"></span><br><span class="line">sliceArray := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">changeArray3(sliceArray)</span><br><span class="line">fmt.Println(<span class="string">&quot;sliceArray=&quot;</span>, sliceArray) <span class="comment">// sliceArray= [10 2 3]</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>09.Go函数，闭包和方法</title>
    <url>/undefined/66c36c37/</url>
    <content><![CDATA[<p>本文主要介绍Go函数，闭包和方法的定义和使用方法。 <span id="more"></span> #
函数，闭包和方法</p>
<h2 id="函数定义">函数定义</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">([parameter list])</span></span> [return_types] &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无参数">无参数</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无返回值">无返回值</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回1个值">返回1个值</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回多个值">返回多个值</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(a <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(a <span class="type">int</span>, b <span class="type">string</span>)</span></span>(<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(a, b <span class="type">int</span>, c, d <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给返回值命名">给返回值命名</h3>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func2.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数add的返回值有2个，类型是int，标识符分别是c和d</span></span><br><span class="line"><span class="comment">可以在函数体内直接给c和d赋值，return后面可以带，也可以不带返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addAndSub</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (c <span class="type">int</span>, d <span class="type">int</span>) &#123;</span><br><span class="line">	c = a + b</span><br><span class="line">	d = a - b</span><br><span class="line">	<span class="keyword">return</span> <span class="comment">// 这一行写为 return c, d 也可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a1, b1 := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">	c1, d1 := addAndSub(a1, b1)</span><br><span class="line">	<span class="comment">/*输出结果是：3 -1*/</span></span><br><span class="line">	fmt.Println(c1, d1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>函数的参数列表不允许部分形参有命名，部分形参没命名，如果违背这个原则，就会报如下的编译错误。</li>
<li>函数的返回值列表不允许部分返回值变量有命名，部分返回值变量没命名，如果违背这个原则，就会报如下的编译错误。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">syntax error: mixed named and unnamed <span class="keyword">function</span> parameters</span><br></pre></td></tr></table></figure>
<p>一句话总结：要么都不命名，要么都命名(都命名的情况下，允许形参或者返回值变量使用<code>_</code>作为命名)。</p>
<h2 id="nil函数">nil函数</h2>
<p>函数也是一种类型，函数变量的默认值是<code>nil</code>，执行<code>nil</code>函数会引发panic</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">// f是一个函数类型，值是nil</span></span><br><span class="line"><span class="comment">// 编译正常，运行报错panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line">f() </span><br></pre></td></tr></table></figure>
<h2 id="函数参数传递">函数参数传递</h2>
<p><strong>Go里的函数传参只有值传递这一种方式</strong>：和C++里的传值一样，参加下例里的swap</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>, c, d <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> a+b, c+d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|swap]a=&quot;</span>, a, <span class="string">&quot;b=&quot;</span>, b)</span><br><span class="line">	a, b = b, a</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|swap]a=&quot;</span>, a, <span class="string">&quot;b=&quot;</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapRef</span><span class="params">(pa *<span class="type">int</span>, pb *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|swapRef]a=&quot;</span>, *pa, <span class="string">&quot;b=&quot;</span>, *pb)</span><br><span class="line">	<span class="keyword">var</span> temp = *pa</span><br><span class="line">	*pa = *pb</span><br><span class="line">	*pb = temp</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|swapRef]a=&quot;</span>, *pa, <span class="string">&quot;b=&quot;</span>, *pb)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">	c, d := <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span></span><br><span class="line">	res1, res2 := add(a, b, c, d)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;res1=&quot;</span>, res1, <span class="string">&quot;res2=&quot;</span>, res2)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|main]a=&quot;</span>, a, <span class="string">&quot;b=&quot;</span>, b)</span><br><span class="line">	swap(a, b)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|main]a=&quot;</span>, a, <span class="string">&quot;b=&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|main]a=&quot;</span>, a, <span class="string">&quot;b=&quot;</span>, b)</span><br><span class="line">	swapRef(&amp;a, &amp;b)</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;[func|main]a=&quot;</span>, a, <span class="string">&quot;b=&quot;</span>, b)	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然swap函数无法改变外部实参的值，swapRef函数可以改变外部实参的值，但是swap和swapRef函数其实都是值传递，细节区别是：</p>
<ul>
<li>swap是直接把变量a和b的值拷贝一份给形参</li>
<li>swapRef是把变量a和b的地址拷贝一份给形参</li>
</ul>
<p>所以，要清楚这2个其实都是值传递，Go里的函数传参也只有值传递这一种方式，并没有像C++那样的引用变量和引用传递。</p>
<p>后续学习了Go里的map等变量类型，可以参考这篇文章<a
href="../senior/p3">Go有引用变量和引用传递么？</a></p>
<h2 id="函数高级用法">函数高级用法</h2>
<p>函数作为其它函数的实参：函数定义后可以作为另一个函数的实参，比如下例的函数realFunc作为函数calValue的实参</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// define function getSquareRoot1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSquareRoot1</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deffine a function variable</span></span><br><span class="line"><span class="keyword">var</span> getSquareRoot2 = <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// define a function type</span></span><br><span class="line"><span class="keyword">type</span> callback_func <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// function calValue accepts a function variable cb as its second argument</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calValue</span><span class="params">(x <span class="type">int</span>, cb callback_func)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[func|calValue]&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> cb(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">realFunc</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[func|realFunc]callback function&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> x*x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="number">100.00</span></span><br><span class="line">	result1 := getSquareRoot1(num)</span><br><span class="line">	result2 := getSquareRoot2(num)</span><br><span class="line">	fmt.Println(<span class="string">&quot;result1=&quot;</span>, result1)</span><br><span class="line">	fmt.Println(<span class="string">&quot;result2=&quot;</span>, result2)</span><br><span class="line"></span><br><span class="line">	value := <span class="number">81</span></span><br><span class="line">	result3 := calValue(value, realFunc) <span class="comment">// use function realFunc as argument of calValue</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;result3=&quot;</span>, result3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3
id="闭包匿名函数顾名思义就是没有函数名">闭包：匿名函数。顾名思义就是没有函数名。</h3>
<p>参考下面的代码示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func3.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		定义2个匿名函数，也就是闭包。</span></span><br><span class="line"><span class="comment">		闭包可以直接调用，也可以赋值给一个变量，后续调用</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	result1 := <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b</span><br><span class="line">	&#125;(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> sub = <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a - b</span><br><span class="line">	&#125;</span><br><span class="line">	result2 := sub(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="comment">/*输出结果：3 -1*/</span></span><br><span class="line">	fmt.Println(result1, result2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法类似c-class里的方法只是go没有class的概念">方法：类似C++
class里的方法，只是go没有class的概念。</h2>
<ul>
<li><p>定义：function_name是类型var_data_type的实例的方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(var_name var_data_type)</span></span> function_name([parameter_list])[<span class="keyword">return</span> <span class="keyword">type</span>] &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>示例：getArea是Circle的方法，Circle的实例可以调用该方法</p></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> getArea() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3.14</span> * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">changeRadius和changeRadius2的区别是后者可以改变变量c的成员radius的值，前者不能改变</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> changeRadius(radius <span class="type">float64</span>) &#123;</span><br><span class="line">	c.radius = radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Circle)</span></span> changeRadius2(radius <span class="type">float64</span>) &#123;</span><br><span class="line">	c.radius = radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> addRadius(x <span class="type">float64</span>) <span class="type">float64</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> c.radius + x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c Circle</span><br><span class="line">	c.radius = <span class="number">10</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;radius=&quot;</span>, c.radius, <span class="string">&quot;area=&quot;</span>, c.getArea())	<span class="comment">//10, 314</span></span><br><span class="line"></span><br><span class="line">	c.changeRadius(<span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;radius=&quot;</span>, c.radius, <span class="string">&quot;area=&quot;</span>, c.getArea())	<span class="comment">//10, 314	</span></span><br><span class="line"></span><br><span class="line">	c.changeRadius2(<span class="number">20</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;radius=&quot;</span>, c.radius, <span class="string">&quot;area=&quot;</span>, c.getArea())	<span class="comment">//20, 1256</span></span><br><span class="line"></span><br><span class="line">	result := c.addRadius(<span class="number">3.6</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;radius=&quot;</span>, c.radius, <span class="string">&quot;result=&quot;</span>, result) <span class="comment">// 20, 23.6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="references">References</h2>
<ul>
<li>https://yourbasic.org/golang/named-return-values-parameters/</li>
<li>https://golangshowcase.com/question/mixed-named-and-unnamed-parameters-in-golang</li>
<li>https://www.geeksforgeeks.org/named-return-parameters-in-golang/</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>08.Go循环控制</title>
    <url>/undefined/b0e5566e/</url>
    <content><![CDATA[<p>本文主要介绍Go中的循环控制，包括for循环的4种用法、break、continue、goto、break和label结合使用等内容。
<span id="more"></span></p>
<h1 id="循环控制">循环控制</h1>
<h2 id="for的4种用法">for的4种用法</h2>
<ul>
<li><p>用法1: 类似C++的<code>for(int i=0; i&lt;100; i++)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> init; condition; post &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> init; condition; &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ; condition; &#123; <span class="comment">// 类似下面的用法2</span></span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用法2：类似C++的while循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用法3: 死循环，类似C++的<code>for(;;)</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用法4: For-each range循环,
类似python的<code>for k,v in dict.items()</code></p>
<p>可以对slice，map，数组和字符串等数据类型进行For-each迭代循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> map1 &#123; <span class="comment">// 遍历map</span></span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> list &#123; <span class="comment">// 遍历数组</span></span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> index, character := <span class="keyword">range</span> str &#123; <span class="comment">// 遍历字符串</span></span><br><span class="line">  do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>break：跳出当前for循环或者switch控制逻辑</p></li>
<li><p>continue：结束当前循环，继续下一轮for循环</p></li>
</ul>
<h2 id="goto">goto：</h2>
<p>类似C++里的goto</p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">label: statement</span><br><span class="line"><span class="keyword">goto</span> label</span><br></pre></td></tr></table></figure>
<ul>
<li>代码示例1</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	LOOP: </span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;Enter your age:&quot;</span>)</span><br><span class="line">		<span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line">		_, err := fmt.Scan(&amp;age) <span class="comment">// 接受控制台输入</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">			<span class="keyword">goto</span> LOOP</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> age &lt; <span class="number">18</span> &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;You are not eligible to vote!&quot;</span>)</span><br><span class="line">			<span class="keyword">goto</span> LOOP</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;You are eligible to vote!&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;all finish&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="break和label结合">break和label结合</h2>
<p>break和label结合使用，可以跳出二重或者多重for循环。</p>
<p>例1：<code>break A</code>直接跳出整个外层for循环，所以下面的例子只执行<code>i=0, j=0</code>这一次循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终输出 0 0 Hello, 世界</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">A:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; i &lt; <span class="number">2</span>; j++ &#123;</span><br><span class="line">			<span class="built_in">print</span>(i, <span class="string">&quot; &quot;</span>, j, <span class="string">&quot; &quot;</span>)</span><br><span class="line">			<span class="keyword">break</span> A</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, 世界&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2：下面的例子，break只能跳出位于里层的for循环，会执行<code>i=0, j=0</code>和<code>i=1, j=0</code>这2次循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 输出 0 0 1 0 Hello, 世界</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; i &lt; <span class="number">2</span>; j++ &#123;</span><br><span class="line">			<span class="built_in">print</span>(i, <span class="string">&quot; &quot;</span>, j, <span class="string">&quot; &quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, 世界&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>07.Go条件语句</title>
    <url>/undefined/ca0019fd/</url>
    <content><![CDATA[<p>本文主要介绍Go中的条件语句，包括if和switch语句的使用方法。
<span id="more"></span></p>
<h1 id="条件语句">条件语句</h1>
<h2 id="if">If</h2>
<p>布尔表达式可以不加括号</p>
<ul>
<li><p>if/else</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression &#123;</span><br><span class="line">  do sth1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  do sth2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>if/else if/else</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression1 &#123;</span><br><span class="line">  do sth1</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> expression2 &#123;</span><br><span class="line">  do sth2</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  do sth3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>if/else嵌套</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> expression1 &#123;</span><br><span class="line">  <span class="keyword">if</span> expression11 &#123;</span><br><span class="line">    do sth11</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    do sth12</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> expression2 &#123;</span><br><span class="line">  do sth2</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  do sth3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>if赋予初始值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> variant:=value ; expression &#123;</span><br><span class="line">  do sth1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  do sth2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是赋予初始值只能使用<code>variant:=value</code>的变量定义方式</p>
</blockquote></li>
</ul>
<h2 id="switch">switch</h2>
<ul>
<li><p>每一个case分支都是唯一的，从上往下逐一判断，直到匹配为止。如果某些case分支条件重复了，编译会报错</p></li>
<li><p>默认情况下每个case分支最后自带break效果，匹配成功就不会执行其它case。</p>
<p>如果需要执行后面的case，可以使用fallthrough。</p>
<p>使用 fallthrough 会强制执行紧接着的下一个 case 语句，不过fallthrough
不会去分析紧接着的下一条 case
的表达式结果是否满足条件，而是直接执行case里的语句块。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Foo prints and returns n.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> Foo(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> Foo(<span class="number">1</span>), Foo(<span class="number">2</span>), Foo(<span class="number">3</span>):</span><br><span class="line">        fmt.Println(<span class="string">&quot;First case&quot;</span>)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> Foo(<span class="number">4</span>):</span><br><span class="line">        fmt.Println(<span class="string">&quot;Second case&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如上面的例子，执行结果如下，并不会去执行<code>fallthrough</code>的下一个case分支里的表达式<code>Foo(4)</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">First case</span><br><span class="line">Second case</span><br></pre></td></tr></table></figure></li>
<li><p>switch使用方法1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> variable &#123;</span><br><span class="line">  <span class="keyword">case</span> value1:</span><br><span class="line">    do sth1</span><br><span class="line">  <span class="keyword">case</span> value2:</span><br><span class="line">    do sth2</span><br><span class="line">  <span class="keyword">case</span> value3, value4: <span class="comment">// 可以匹配多个值，只要一个满足条件即可</span></span><br><span class="line">    do sth34</span><br><span class="line">  <span class="keyword">case</span> value5:</span><br><span class="line">    do sth5</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>switch使用方法2</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// freebsd, openbsd,</span></span><br><span class="line">		<span class="comment">// plan9, windows...</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的写法和这个等价</span></span><br><span class="line">os := runtime.GOOS</span><br><span class="line"><span class="keyword">switch</span> os &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// freebsd, openbsd,</span></span><br><span class="line">		<span class="comment">// plan9, windows...</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>switch使用方法3。case分支的每个condition结果必须是一个bool值，要么为true，要么为false</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> condition1:</span><br><span class="line">  	do sth1</span><br><span class="line">  <span class="keyword">case</span> condition2:</span><br><span class="line">  	do sth2</span><br><span class="line">  <span class="keyword">case</span> condition3, condition4:</span><br><span class="line">  	do sth34</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  	do sth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>switch使用方法4。只适用于<code>interface</code>的类型判断，而且<code>&#123;</code>要和<code>switch</code>在同一行，<code>&#123;</code>前面不能有分号<code>;</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">10</span></span><br><span class="line">	<span class="keyword">switch</span> t := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;I&#x27;m a bool&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;I&#x27;m an int&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Don&#x27;t know type %T\n&quot;</span>, t)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>https://yourbasic.org/golang/switch-statement/</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>06.Go中的运算符</title>
    <url>/undefined/e6208f17/</url>
    <content><![CDATA[<p>本文主要介绍Go中的运算符，包括算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符等内容。
<span id="more"></span> # 运算符</p>
<h2 id="算术运算符">算术运算符</h2>
<ul>
<li><p>加+, 减-, 乘*,除 /, 模%, 自增++, 自减--</p></li>
<li><p>go里的除法/和C++里一样，如果是2个整数相除，结果还是整数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;6/5=&quot;</span>, <span class="number">6</span>/<span class="number">5</span>) <span class="comment">// 结果是1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="关系运算符">关系运算符</h2>
<ul>
<li>相等==</li>
<li>不等!=</li>
<li>大于&gt;，大于等于&gt;=</li>
<li>小于&lt;，小于等于&lt;=</li>
</ul>
<h2 id="逻辑运算符">逻辑运算符</h2>
<ul>
<li>与&amp;&amp;</li>
<li>或||</li>
<li>非!</li>
</ul>
<h2 id="位运算符">位运算符</h2>
<ul>
<li>按位与<code>&amp;</code></li>
<li>按位或<code>|</code></li>
<li>按位异或<code>^</code></li>
<li>左移<code>&lt;&lt;</code></li>
<li>右移<code>&gt;&gt;</code></li>
<li>取反<code>^</code></li>
</ul>
<h2 id="赋值运算符">赋值运算符</h2>
<ul>
<li>=, +=, -=, *=, /=, %=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^=, |=</li>
</ul>
<h2 id="其它运算符">其它运算符</h2>
<ul>
<li>返回变量的内存地址&amp;
<ul>
<li>&amp;a给出变量a的内存地址</li>
</ul></li>
<li>指针操作<code>*</code>，取指针指向的变量的值
<ul>
<li>*a中a是一个指针类型的变量</li>
</ul></li>
<li>Go没有三目运算符<code>?:</code></li>
</ul>
<h2 id="运算符优先级">运算符优先级</h2>
<p>参考：https://go.dev/ref/spec#Operator_precedence</p>
<h2 id="references">References</h2>
<ul>
<li><p>https://github.com/jincheng9/golang-cheat-sheet-cn#%E6%93%8D%E4%BD%9C%E7%AC%A6</p></li>
<li><p>https://go.dev/ref/spec#Operator_precedence</p></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>02.Go的程序结构</title>
    <url>/undefined/b15049a7/</url>
    <content><![CDATA[<p>本文主要介绍Go的程序结构，包括包声明、引入包、函数、变量、语句和表达式、注释等内容。
<span id="more"></span> # Go的程序结构 * 包声明</p>
<ul>
<li><p>引入包</p></li>
<li><p>函数</p></li>
<li><p>变量</p></li>
<li><p>语句和表达式</p></li>
<li><p>注释</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.go</span></span><br><span class="line"><span class="comment">// package declaration</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// import package</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// global variable</span></span><br><span class="line"><span class="keyword">var</span> g <span class="type">int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">  res := add(a, b)</span><br><span class="line">  fmt.Println(<span class="string">&quot;a=&quot;</span>, a, <span class="string">&quot;b=&quot;</span>, b, <span class="string">&quot;a+b=&quot;</span>, res)</span><br><span class="line">  fmt.Println(<span class="string">&quot;g=&quot;</span>, g)</span><br><span class="line">  fmt.Println(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="注意事项">注意事项</h1>
<ul>
<li><p>func main()是程序开始执行的函数(但是如果有func
init()函数，则会先执行init函数，再执行main函数)</p></li>
<li><p>源程序文件所在的目录名称与包名称没有直接关系，不需要一致。不过通常保持一致，这符合Go的编码规范。</p></li>
<li><p>源程序文件名与包名没有直接关系，不需要将源程序文件名与文件开头申明的包名保持一样，通常这2者是不一样的。</p></li>
<li><p>只有在源程序文件开头声明package main，并且有func
main()定义，才能生成可执行程序，否则go run file.go会报错，报错内容:</p>
<figure class="highlight plaintext"><figcaption><span>command-line-arguments is not a main packagego</span></figcaption><table><tr><td class="code"><pre><span class="line">package command-line-arguments is not a main package</span><br><span class="line">和</span><br><span class="line">runtime.main_main·f: function main is undeclared in the main package</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="编译和运行">编译和运行</h1>
<p>Go是编译型语言 * 编译+运行分步执行 * go build hello.go * ./hello *
编译+运行一步到位 * go run hello.go</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>03.Go的基础数据类型</title>
    <url>/undefined/b52965b/</url>
    <content><![CDATA[<p>本文主要介绍Go的基础数据类型，包括数字、字符串、bool等类型，以及类型转换的方法。
<span id="more"></span> # 基础数据类型 ## 数字</p>
<ul>
<li><p>整数：int, uint8, uint16, uint32, uint64, int8, int16, int32,
int64</p></li>
<li><p>浮点数：float32, float64</p></li>
<li><p>复数：</p>
<ul>
<li><p>complex64：实部和虚部都是float32类型的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v <span class="type">complex64</span> = <span class="number">1</span> + <span class="number">0.5i</span></span><br></pre></td></tr></table></figure></li>
<li><p>complex128：实部和虚部都是float64类型的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v <span class="type">complex128</span> = <span class="number">1</span> + <span class="number">0.5i</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>注意</strong>：虚部为1的情况，1不能省略，否则编译报错</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v <span class="type">complex64</span> = <span class="number">1</span> + i <span class="comment">// compile error: undefined i</span></span><br><span class="line"><span class="keyword">var</span> v <span class="type">complex64</span> = <span class="number">1</span> + <span class="number">1i</span> <span class="comment">// correct</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="字符串string">字符串：string</h2>
<ul>
<li><p>len(str)函数可以获取字符串长度</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;abcdgfg&quot;</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(str)) <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>注意</strong>：string是immutable的，不能在初始化string变量后，修改string里的值，除非对string变量重新赋值</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;abc&quot;</span></span><br><span class="line">    str = <span class="string">&quot;def&quot;</span> <span class="comment">// ok</span></span><br><span class="line">    <span class="comment">/* 下面的就不行，编译报错：cannot assign to str[0] (strings are immutable)</span></span><br><span class="line"><span class="comment">    str[0] = &quot;d&quot;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>字符串里字符的访问可以通过str[index]下标索引或者range迭代的方式进行访问</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str := <span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="comment">/*下标访问*/</span></span><br><span class="line">    size := <span class="built_in">len</span>(str)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;size; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, str[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*range迭代访问*/</span></span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> str &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>不能对string里的某个字符取地址：如果s[i]是字符串s里的第i个字符，那&amp;s[i]这种方式是非法的</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string3.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;abc&quot;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	the following code has compile error:</span></span><br><span class="line"><span class="comment">	cannot take the address of str[0]</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	fmt.Println(&amp;str[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>string可以使用 <code>:</code> 来做字符串截取</p>
<p><strong>注意</strong>：这里和<a
href="../lesson13">切片slice</a>的截取有区别</p>
<ul>
<li>字符串截取后赋值给新变量，对新变量的修改不会影响原字符串的值</li>
<li>切片截取后复制给新变量，对新变量的修改会影响原切片的值</li>
</ul>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string4.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;abc&quot;</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s)) <span class="comment">// 3</span></span><br><span class="line">	s1 := s[:]</span><br><span class="line">	s2 := s[:<span class="number">1</span>]</span><br><span class="line">	s3 := s[<span class="number">0</span>:]</span><br><span class="line">	s4 := s[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">	fmt.Println(s, s1, s2, s3, s4) <span class="comment">// abc abc a abc ab</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	strTest()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>string可以用<code>+</code>做字符串拼接</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string5.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="string">&quot;ch&quot;</span></span><br><span class="line">	b := <span class="string">&quot;ina&quot;</span></span><br><span class="line">	c := a + b</span><br><span class="line">	fmt.Println(c) <span class="comment">// china</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>string的更多用法可以参考：https://yourbasic.org/golang/string-functions-reference-cheat-sheet/</p></li>
</ul>
<h2 id="bool">bool</h2>
<p>值只能为<code>true</code>或<code>false</code>。</p>
<h2 id="其它数字类型">其它数字类型</h2>
<ul>
<li><p>byte：等价于uint8，数据范围0-255，定义的时候超过这个范围会编译报错</p></li>
<li><p>rune：等价于int32，数据范围-2147483648-2147483647</p>
<ul>
<li>字符串里的每一个字符的类型就是rune类型，或者说int32类型</li>
</ul></li>
<li><p>uint：在32位机器上等价于uint32，在64位机器上等价于uint64</p></li>
<li><p>uintptr:
无符号整数，是内存地址的十进制整数表示形式，应用代码一般用不到（https://stackoverflow.com/questions/59042646/whats-the-difference-between-uint-and-uintptr-in-golang）</p></li>
<li><p>reflect包的<code>TypeOf</code>函数或者<code>fmt.Printf</code>的<code>%T</code>可以用来获取变量的类型</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="type">byte</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">fmt.Println(reflect.TypeOf(b)) <span class="comment">// uint8</span></span><br><span class="line">fmt.Println(reflect.TypeOf(c)) <span class="comment">// int32</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, c) <span class="comment">// int32</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="类型转换">类型转换</h2>
<ul>
<li><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">type_name(expression)</span><br></pre></td></tr></table></figure></li>
<li><p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    total_weight := <span class="number">100</span></span><br><span class="line">    num := <span class="number">12</span></span><br><span class="line">    <span class="comment">// total_weight和num都是整数，相除结果还是整数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;average=&quot;</span>, total_weight/num) <span class="comment">//  average= 8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转成float32再相除，结果就是准确值了</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;average=&quot;</span>, <span class="type">float32</span>(total_weight)/<span class="type">float32</span>(num)) <span class="comment">// average= 8.333333</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 注意，float32只能和float32做运算，否则会报错，比如下例里float32和int相加，编译报错:</span></span><br><span class="line"><span class="comment">    invalid operation: float32(total_weight) + num (mismatched types float32 and int)</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">    res := float32(total_weight) + num</span></span><br><span class="line"><span class="comment">    fmt.Println(res)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：Go不支持隐式类型转换，要做数据类型转换必须按照type_name(expression)方式做显式的类型转换</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> f <span class="type">float32</span> = <span class="type">float32</span>(num)</span><br><span class="line">    fmt.Println(f) <span class="comment">// 10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    不支持隐式类型转换，比如下例想隐式讲num这个int类型转换为float32就会编译报错:</span></span><br><span class="line"><span class="comment">     cannot use num (type int) as type float32 in assignment</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">    var f float32 = num</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>https://gfw.go101.org/article/basic-types-and-value-literals.html</li>
<li>https://www.callicoder.com/golang-basic-types-operators-type-conversion/</li>
<li>https://yourbasic.org/golang/string-functions-reference-cheat-sheet/</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>04.Go中的变量</title>
    <url>/undefined/717b940e/</url>
    <content><![CDATA[<h1 id="变量定义">变量定义</h1>
<h2 id="全局变量">全局变量</h2>
<p>函数外定义的变量叫全局变量，以下是全局变量的定义方法。</p>
<ul>
<li><p>方法1 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span> = value</span><br></pre></td></tr></table></figure></p></li>
<li><p>方法2：注意，全局变量如果采用这个方式定义，那不能在全局范围内赋值，只能在函数体内给这个全局变量赋值
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span> <span class="comment">// value will be defaulted to 0, false, &quot;&quot; based on the type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果定义上面的全局变量，就不能紧接着在下一行通过name=value的方式对变量name做赋值，</span></span><br><span class="line"><span class="comment">比如name = 10，会编译报错：</span></span><br><span class="line"><span class="comment"> syntax error: non-declaration statement outside function body</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>方法3 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = value </span><br></pre></td></tr></table></figure></p></li>
<li><p>方法4 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	v1 <span class="type">int</span> = <span class="number">10</span></span><br><span class="line">	v2 <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	v5 <span class="type">int</span>   <span class="comment">// the value will be defaulted to 0</span></span><br><span class="line">	v6 <span class="type">bool</span>  <span class="comment">// the value will be defaulted to false</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	v3 = <span class="number">20</span></span><br><span class="line">	v4 = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>全局变量允许声明后不使用</strong>，编译不会报错。</p></li>
</ul>
<h2 id="局部变量">局部变量</h2>
<p>函数内定义的变量叫局部变量。</p>
<ul>
<li>和全局变量的定义相比，多了以下定义方法
<ul>
<li>方法5 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name := value</span><br></pre></td></tr></table></figure></li>
<li>方法6 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span></span><br><span class="line">name = value</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>局部变量定义后必须要被使用，否则编译报错</strong>，报错内容为<code>declared but not used</code>。</li>
</ul>
<h2 id="多变量定义">多变量定义：</h2>
<p>一次声明和定义多个变量</p>
<ul>
<li><p>全局变量</p>
<ul>
<li><p>方法1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure></li>
<li><p>方法2</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c <span class="type">bool</span></span><br></pre></td></tr></table></figure></li>
<li><p>方法3</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;str&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>局部变量：和全局变量相比，多了以下定义方法</p>
<ul>
<li><p>方法4</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line">a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, d <span class="type">int</span></span><br><span class="line">c = <span class="number">10</span></span><br><span class="line">d = <span class="number">20</span></span><br></pre></td></tr></table></figure></li>
<li><p>方法5</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">a1, b1 := <span class="number">1</span>, <span class="string">&quot;str&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="变量类型及其零值">变量类型及其零值</h2>
<ul>
<li><p>零值：英文叫<a href="https://go.dev/ref/spec#The_zero_value">zero
vaue</a>，没有显式初始化的变量，Go编译器会给一个默认值，也叫零值。</p></li>
<li><p>数值：所有数值类型的零值都是0</p>
<ul>
<li>整数，零值是0。byte, rune, uintptr也是整数类型，所以零值也是0。</li>
<li>浮点数，零值是0</li>
<li>复数，零值是0+0i</li>
</ul></li>
<li><p>bool，零值是false</p></li>
<li><p>字符串，零值是空串""</p></li>
<li><p>指针：var a *int，零值是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">num := <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> a * <span class="type">int</span> = &amp;num</span><br></pre></td></tr></table></figure></li>
<li><p>切片：var a []int，零值是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a []<span class="type">int</span> = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">list := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125; <span class="comment">//size为6的数组，前面2个元素是1和2，后面的是默认值0</span></span><br></pre></td></tr></table></figure></li>
<li><p>map：var a map[string] int，零值是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">dict := <span class="keyword">map</span>[<span class="type">string</span>] <span class="type">int</span>&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>函数：var a func(string) int，零值是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">function := <span class="function"><span class="keyword">func</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line">result := function(<span class="string">&quot;hello fans&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;result=&quot;</span>, result)</span><br></pre></td></tr></table></figure></li>
<li><p>channel：var a chan int，通道channel，零值是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">chan</span> <span class="type">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>接口：var a interface_type，接口interface，零值是nil</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">  speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">  age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cat Cat)</span></span> speak() &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;miao...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个接口变量a</span></span><br><span class="line"><span class="keyword">var</span> a Animal = Cat&#123;<span class="string">&quot;gaffe&quot;</span>, <span class="number">1</span>&#125;</span><br><span class="line">a.speak() <span class="comment">// miao...</span></span><br></pre></td></tr></table></figure></li>
<li><p>结构体: var instance
StructName，结构体里每个field的零值是对应field的类型的零值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">  radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 Circle</span><br><span class="line">c1.radius = <span class="number">10.00</span></span><br></pre></td></tr></table></figure>
<h2 id="变量作用域">变量作用域</h2></li>
<li><p>局部变量</p>
<ul>
<li>函数内声明的变量，作用域只在函数体内。函数的参数和返回值也是局部变量</li>
</ul></li>
<li><p>全局变量</p>
<ul>
<li><p>函数外声明的变量，全局变量作用域可以在当前的整个包甚至外部包(被导出后)使用</p></li>
<li><p>全局变量和局部变量名称可以相同，但是函数内的局部变量会被优先考虑</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> g <span class="type">int</span> = <span class="number">20</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;g=&quot;</span>,g)	 <span class="comment">// g=20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>函数形参</p>
<ul>
<li>函数定义中的参数，作为函数的局部变量来使用</li>
</ul></li>
<li><p>花括号{}可以控制变量的作用域：和C++类似</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">10</span></span><br><span class="line">	&#123;</span><br><span class="line">		a := <span class="number">5</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;a=&quot;</span>, a) <span class="comment">// a=5</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;a=&quot;</span>, a) <span class="comment">// a=10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="references">References</h2>
<ul>
<li>https://go.dev/ref/spec#The_zero_value</li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>05.Go中的常量</title>
    <url>/undefined/6c20ce37/</url>
    <content><![CDATA[<p>本文主要介绍Go中常量的定义方法和使用注意事项，包括常量的定义、iota的使用、常量的枚举等内容。
<span id="more"></span></p>
<h1 id="常量">常量</h1>
<ul>
<li><p>常量定义的时候必须赋值，定义后值不能被修改</p></li>
<li><p>常量(包括全局常量和局部常量)可以定义后不使用，局部变量定义后必须使用，否则编译报错</p></li>
<li><p>常量可以用来定义枚举</p></li>
<li><p>iota，特殊常量，可以理解为const语句块里的行索引，值从0开始</p></li>
<li><p>常量的定义方法</p>
<ul>
<li><p>方法1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> b <span class="type">bool</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li><p>方法2</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="literal">false</span></span><br></pre></td></tr></table></figure></li>
<li><p>多个常量同时定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a, b <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>iota，特殊常量，可以理解为每个独立的const语句块里的行索引</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a <span class="type">int</span> = <span class="literal">iota</span> <span class="comment">// the value of a is 0</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="literal">iota</span> <span class="comment">// the value of b is still 0</span></span><br></pre></td></tr></table></figure></li>
<li><p>定义枚举方法1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  unknown = <span class="number">0</span></span><br><span class="line">  male = <span class="number">1</span></span><br><span class="line">  female = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>定义枚举方法2</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  unknown = <span class="literal">iota</span> <span class="comment">// the value of unknown is 0</span></span><br><span class="line">  male <span class="comment">// the value of male is 1</span></span><br><span class="line">  female <span class="comment">// the value of female is 2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  c1 = <span class="literal">iota</span> <span class="comment">// the value of c1 is 0</span></span><br><span class="line">  c2 = <span class="literal">iota</span> <span class="comment">// the value of c2 is 1</span></span><br><span class="line">  c3 = <span class="literal">iota</span> <span class="comment">// the value of c3 is 2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<ul>
<li>iota的值是const语句块里的行索引，行索引从0开始</li>
<li>const语句块里，如果常量没赋值，那它的值和上面的保持一样，比如下面的例子里class2=0,
class6="abc"</li>
<li>某个常量赋值为iota后，紧随其后的常量如果没赋值，那后面常量的值是自动+1，比如下面的例子里，class3的值是iota，该行的行索引是2，所以class3=2，
class4常量紧随其后没有赋值，那class4=class3+1=3</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	class1 = <span class="number">0</span></span><br><span class="line">	class2 <span class="comment">// class2 = 0</span></span><br><span class="line">	class3 = <span class="literal">iota</span>  <span class="comment">//iota is 2, so class3 = 2</span></span><br><span class="line">	class4 <span class="comment">// class4 = 3</span></span><br><span class="line">	class5 = <span class="string">&quot;abc&quot;</span> </span><br><span class="line">	class6 <span class="comment">// class6 = &quot;abc&quot;</span></span><br><span class="line">	class7 = <span class="literal">iota</span> <span class="comment">// class7 is 6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>01.Go环境配置</title>
    <url>/undefined/3c040810/</url>
    <content><![CDATA[<p>本文主要介绍如何在Linux系统下安装Go开发环境，以及如何配置VS
Code开发工具。 <span id="more"></span><br />
## Go 安装</p>
<p>下载地址：</p>
<ul>
<li>Go 官网下载地址：https://golang.org/dl/</li>
<li>Go 官方镜像站（推荐）：https://golang.google.cn/dl/</li>
</ul>
<p><img
src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokeimage-20240811192036599.png"
alt="image-20240811192036599" />直接安装最新版本
go1.22.6，后续文章都会在此版本下开发，测试。</p>
<h3 id="linux-下安装">Linux 下安装</h3>
<p>下载安装包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://golang.google.cn/dl/go1.22.6.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压到 /usr/local 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo tar -zxvf go1.22.6.linux-amd64.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure>
<p>然后配置环境变量，打开 $HOME/.bash_profile
文件，增加下面两行代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/usr/local/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin</span><br></pre></td></tr></table></figure>
<p>最后使环境变量生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> <span class="variable">$HOME</span>/.bash_profile</span><br></pre></td></tr></table></figure>
<p>安装完成后，在终端执行查看版本命令，如果能正确输出版本信息，那就说明安装成功了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go version</span><br><span class="line">go version go1.22.6 linux/amd64</span><br></pre></td></tr></table></figure>
<h3 id="配置环境变量">配置环境变量</h3>
<p><code>GOROOT</code> 和 <code>GOPATH</code> 都是环境变量，其中
<code>GOROOT</code> 是我们安装 Go 开发包的路径，<code>GOPATH</code>
会有一个默认目录。</p>
<p>由于 go1.11 之后使用 go mod 来管理依赖包，不再强制我们必须把代码写在
<code>GOPATH/src</code> 目录下，所以使用默认即可，无需修改。</p>
<p>默认 <code>GOPROXY</code> 配置是
<code>GOPROXY=https://proxy.golang.org,direct</code>，由于国内访问不到，所以我们需要换一个
PROXY，这里推荐使用：</p>
<ol type="1">
<li>https://goproxy.io</li>
<li>https://goproxy.cn</li>
</ol>
<p>配置 <code>GOPROXY</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GO111MODULE=on</span><br><span class="line">$ go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure>
<p>go mod 先这样配置就可以了，后续再来写文章详细介绍。</p>
<h2 id="开发工具-vs-code">开发工具 VS Code</h2>
<p>开发工具可以根据自己的喜好来，可以用 Goland，VS Code，当然 Vim
也可以。</p>
<p>我比较喜欢 VS Code，插件丰富，而且免费。</p>
<p>官方下载地址：https://code.visualstudio.com/Download</p>
<p>安装 Go 插件，并重启：</p>
<figure>
<img
src="https://dl-poke.oss-cn-beijing.aliyuncs.com/pokeimage-20240811192914982.png"
alt="image-20240811192914982" />
<figcaption aria-hidden="true">image-20240811192914982</figcaption>
</figure>
<h2 id="第一个-go-程序">第一个 Go 程序</h2>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">/ <span class="number">00</span>_hello.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main  <span class="comment">// 声明 main 包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  <span class="comment">// 导入内置 fmt 包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;  <span class="comment">// main函数，程序执行入口</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World!&quot;</span>)  <span class="comment">// 在终端打印 Hello World!</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>go build</code> 命令编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build 00_hello.go</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">00_hello  00_hello.go go.mod</span><br></pre></td></tr></table></figure>
<p>可以看到在目录下生成了可执行文件
<code>00_hello</code>，然后运行一下试试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./00_hello</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<p>还可以直接使用 <code>go run</code>
命令来执行代码，在调试的时候更加方便。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go run 00_hello.go</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Golang</category>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>程序开发的开闭原则</title>
    <url>/undefined/f0115136/</url>
    <content><![CDATA[<h1 id="什么是开闭原则">什么是开闭原则</h1>
<p>GPT的解释如下：</p>
<blockquote>
<p>开闭原则是面向对象设计中的一个重要原则，指的是软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着一个软件实体应该通过扩展来实现新功能，而不是通过修改已有的代码来实现。这样做可以保持原有代码的稳定性，降低修改代码引入错误的风险，并且更容易维护和扩展软件系统。
在程序开发中，遵循开闭原则可以通过以下方式实现：
使用接口和抽象类定义可扩展的接口，通过实现接口或继承抽象类来新增功能，而不是修改原有代码。
使用设计模式如策略模式、装饰器模式等来实现可插拔的功能，而不是直接修改现有代码。
使用配置文件、扩展点等机制来实现功能的动态配置和扩展。
避免硬编码具体实现，使用依赖注入等方式来实现松耦合，方便替换和扩展功能。</p>
</blockquote>
<p>简单而言开闭原则是软件功能的扩展尽可能通过外部模块进行而不是修改原来功能的源代码。
<span id="more"></span><br />
# 开闭原则的实现方法</p>
<h2
id="策略模式工厂模式模板模式的混合模式方案">策略模式+工厂模式+模板模式的混合模式方案</h2>
<p>参考下面这个视频
<iframe src="//player.bilibili.com/player.html?aid=456530918&bvid=BV1b5411a7oa&cid=220746663&p=1&autoplay=false&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="720">
</iframe></p>
<p>其中的关键是策略模式，通过使用策略的方式对不同的业务逻辑进行模块化开发，然后使用工厂模式调用策略实现核心代码的一致性，进一步为了实现策略方法的可复用，使用模板模式进行进一步的封装。</p>
<h2 id="搭架子和串珠子">搭架子和串珠子</h2>
<iframe src="//player.bilibili.com/player.html?aid=403664982&amp;bvid=BV1bV411K7Z2&amp;cid=1203166154&amp;autoplay=false&amp;high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="720">
</iframe>
<p>使用模板编程(类似于python中的装饰器功能)封装业务流，最后使用流程业务将不同的<code>"珠子"</code>串起来，开发框架的中间件和过滤器通常就使用这样的开发方式</p>
]]></content>
      <tags>
        <tag>后端修炼的葵花宝典</tag>
      </tags>
  </entry>
</search>
